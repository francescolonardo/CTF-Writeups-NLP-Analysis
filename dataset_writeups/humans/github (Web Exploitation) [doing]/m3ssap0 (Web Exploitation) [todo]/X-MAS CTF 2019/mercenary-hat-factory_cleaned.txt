Registering a user and analyzing cookies you will find a cookie called `auth` containing a JWT.

You can check its creation inside `register` and `login` methods of the source code.

Analyzing the source code you can discover two interesting endpoints.

Considering the presence of template rendering operations into `/makehat` endpoint with a parameter read from the user, probably that functionality is vulnerable to Server Side Template Injection (SSTI) due to the insecure usage of Flask/Jinja2 template engine.

The first check to bypass for the `/authorize` endpoint is the following.

[Python code that checks whether the value associated with the key "type" in the dictionary "userData" is not equal to the string "admin", and if so, returns an error message using the Flask template "error.html".]

This can be easily bypassed forging a JWT like the following and testing that you are an admin connecting to the root of the website.

Checking it to the index endpoint.

At this point you have to break this check.

[Python code snippet that checks whether a form field "accessCode" matches a combination of user-specific values concatenated together, and if it does, grants the user access to administrative privileges by setting the corresponding key in the "authorizedAdmin" dictionary to True.]

Analyzing the code you will understand that variables are populated from Santa's data, that data is well known except its secret.

At this point I was stuck and I was not able to bypass this check, so I did something (stupid, lol) that led me to what I think was an **unintended solution** to bypass the check: I registered a user with username `Santa`.

The user with username `Santa` was already into `adminPrivileges`, so I only crafted the correct JWT to bypass the previous check and I added the `pass` field needed by the `/makehat` endpoint.

Here the request to the endpoint.

[HTTP request sent to a server requesting the resource "/makehat" with the parameter "hatName=test", along with various headers including the user agent, accept encoding, and cookies. The server responds with an HTTP 200 OK status code and sends back a webpage containing HTML, CSS, and JavaScript.]

Trying the auth token to the homepage will confirm our privileges.

Trying the `{{7*7}}` payload to the `/makehat` endpoint will reveal a SSTI vulnerability.

Usually, something like the following can be used to access classes loaded into the server and to invoke them.

[A Python code snippet that uses class manipulation to execute code that reads the contents of the file "/etc/passwd"]

But we have some restrictions, as you can see in the following blacklist used into `/makehat` endpoint.

[A Python list named "blacklist" containing strings that are presumably restricted keywords or characters in a particular context.]

So we have to use some tricks like the hexadecimal encoding of the strings and the `attr` filter of Jinja2.

An HTTP GET request can be used to enumerate all classes.

You can use the `__dir__()` method to enumerate all the methods that can be called from this result.

There is an interesting `__getitem__()` method that can be used to retrieve the data from the list using the index but without using `[]`.

The `<class 'subprocess.Popen'>` class is at position number `215` and allow us to launch commands.

We can setup a server listening on port `1337` with `nc -lk 1337` and then encode a reverse shell that will be launched on the victim host in order to connect to our server.

On the victim host an interesting file can be found: `unusual_flag.mp4`.

At this point you have to remove the HTTP headers inserted into the created file by `nc` and then you can launch the MP4 video.

Into the video there is the flag.