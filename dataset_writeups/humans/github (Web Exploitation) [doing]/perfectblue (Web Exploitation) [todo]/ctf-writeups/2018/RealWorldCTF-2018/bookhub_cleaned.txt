Hint: "www.zip"

When I started the challenge, there was no hint. But running a quick dirserach, I found the /login/ endpoint and www.zip.

As you would suspect, www.zip contained the source code of all the web app. Fortunately for me, it was written in Flask and I'm quite familiar with Flask.

The login happens in `bookhub/forms.user.py`
[Python code: A LoginForm class with username, password, and remember_me fields. The class has a validate_password function that checks if the IP address is in the whitelist and verifies the username and password.]
  
The server first checks if our IP address is one of the whitelisted IP addresses (or is the debug mode enabled) and if it is, it logs us in. The function `get_remote_addr()` is defined in `bookhub/helper.py`
[Python code: A function that returns the user's IP address from the 'X-Forwarded-For' header or the remote address, and checks if it's a valid IP]

But unfortunately, adding the header changed nothing. It still showed that we are not allowed to log in because we are not in the whitelist.

According to the server, the whitelist was `10.0.0.0/8,127.0.0.0/8,172.16.0.0/12,192.168.0.0/16,18.213.16.123` and 127.0.0.1 is not in that range. This doesn't sound right....

My hypothesis was that this is probably a reverse proxy which is stripping the X-Forwarded-For header. All the IP ranges in the whitelist were local IPs except one, which stuck out like a sore thumb. It was the following IP: `18.213.16.123`. 

With nothing to go on, I began my normal recon process with a nmap scan on the IP
[Nmap command: Scan the IP for open ports and services]
So port 5000 is open which also runs pwnhub and there's also a weird service on port 10010. Opening http://18.213.16.123:5000/, I'm greeted with a lovely message.

Oh, this is convienient. The webapp is run in debug mode. Let's take a look at the source to see what does the debug mode expose as "security issues". In the file `bookhub/views/user.py`, we identify the following additional code for debug mode
[Python code: Debug mode adds routes for system management, change_name, and refresh_session, which are only accessible when logged in and running in debug mode]

This is where I got stuck for hours. All of the endpoints are supposedly protected by @login_required identifier and we don't have a admin session, so we can't access any of them. 

But if we take a closer look (like real close), we can identify a subtle but dangerous bug:
[Python code: The @login_required decorator is incorrectly placed above the @user_blueprint.route, which means the "/admin/system/refresh_session/" endpoint can be accessed without authentication.]

The @login_required identifier is above the @user_blueprint_route whereas it should be below. This means we can access the "/admin/system/refresh_session/" endpoint without authentication. (This is so real world)

Down below in the same function, we can identify some really sketchy code:
[Python code: There is a code block that uses 'redis.eval()' to run a Lua script, which deletes all sessions except the one for the logged-in user when the 'submit' form field is set to '1'.]
 
There is a redis.eval() call with our sessionID in it. It's supposed to delete all the admin sessions except ours and it does through redis.eval() which accepts a lua script and the redis functions in it can be called through redis.call(). (The server actually uses redis to store session related data)

Since we can control our sessionID on client side, we basically have a redis injection. Since I have no experience with lua or redis, I cloned the server environment as I would probably need it to write my exploit. 

As I was setting up the redis server and making sure it works properly, I stumbled upon this:
[Redis CLI output: A serialized Python pickle object]
This looks like a pickle serialized python object. You can easily identify a serialized pickle with the `\x80\x03` at the start. This points to your typical pickle deserialization vuln. The server stores our session as data as a serialized object and if we can control it, we can make it deserialize a malicious pickle object which runs our code.

I wrote a quick script which changed my sessionID to valid lua, refreshed my CSRF token and then sent a POST request to "/admin/system/refresh_session/" endpoint (to store the code). 

My final payload was to do a `redis.call("SET", "bookhub:session:hacker", {pickle RCE code serialized})` and then send a GET request to "/login/" to make sure our serialized object is deserialized.

Here is my final script which sends the flag to my server (I used lua's string.char() function to send non readable bytes because URL encoding was fucking me over).
[Python script:
Define a malicious command for RCE.
Create a malicious pickle object that executes the RCE command when deserialized.
Convert the pickle object into a Lua string representation.
Set up the payload to use the redis.call() function to store the malicious object.
Send a GET request to "/login/" to fetch the CSRF token.
Send a POST request to "/admin/system/refresh_session/" with the CSRF token to store the payload in the session.
Send a GET request to "/login/" again with the malicious session identifier to trigger deserialization and RCE.]
