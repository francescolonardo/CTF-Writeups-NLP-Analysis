[
	{
		"documentName": "inspector-general_cleaned.txt",
		"document": "Press `Ctrl + U` on your browser to view the source code of the `HTML` file. Search for `flag{...}`. \n[HTML source code with flag]\n",
		"tokens": [
			{
				"text": "`Ctrl + U` on your browser",
				"start": 6,
				"end": 32,
				"token_start": 1,
				"token_end": 8,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "HTML source code",
				"start": 103,
				"end": 119,
				"token_start": 32,
				"token_end": 34,
				"entityLabel": "TARGET_COMPONENT"
			}
		],
		"relations": [
			{
				"child": 32,
				"head": 1,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "flask_caching_cleaned.txt",
		"document": "When you look at the documentation for the source for the `flask_caching` module, you can optionally store a python pickle in the redis by prepending it with `'!'`. You can use python pickles for RCE, when the caching modules uses `pickle.load()` to load the cached data.\n\nSet up a netcat listener on your server and run the following script with your IP and PORT.\n[Python script: Create a payload for RCE and send it to the server]\n\nOn your netcat listener, you would get the flag.\n[HTTP POST request with the flag]\n",
		"tokens": [
			{
				"text": "`flask_caching` module",
				"start": 58,
				"end": 80,
				"token_start": 11,
				"token_end": 14,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "RCE",
				"start": 196,
				"end": 199,
				"token_start": 42,
				"token_end": 42,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "redis",
				"start": 130,
				"end": 135,
				"token_start": 25,
				"token_end": 25,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "python pickle",
				"start": 109,
				"end": 122,
				"token_start": 21,
				"token_end": 22,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "netcat listener",
				"start": 282,
				"end": 297,
				"token_start": 64,
				"token_end": 65,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "RCE",
				"start": 402,
				"end": 405,
				"token_start": 89,
				"token_end": 89,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "Python script",
				"start": 366,
				"end": 379,
				"token_start": 82,
				"token_end": 83,
				"entityLabel": "TOOL_USED"
			}
		],
		"relations": [
			{
				"child": 42,
				"head": 11,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 42,
				"head": 25,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 42,
				"head": 21,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			},
			{
				"child": 89,
				"head": 64,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			},
			{
				"child": 89,
				"head": 82,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "gif2png_cleaned.txt",
		"document": "The critical line in the code is:\n[Python code: Use subprocess.Popen to call FFmpeg]\n\nHere, you can perform Remote Code Execution (RCE) with the file name. The idea is to grep the flag from the main.py file and write it on the image to which the GIF is going to be converted. This can be done with the -vf drawtext=... option. The payload used is:\n[Payload: Include grep and drawtext options in the file name]\n\nWhen you upload a GIF with this payload as the file name, you will receive a resulting PNG with the flag written on it.\n",
		"tokens": [
			{
				"text": "subprocess.Popen",
				"start": 52,
				"end": 68,
				"token_start": 14,
				"token_end": 16,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "Remote Code Execution (RCE)",
				"start": 108,
				"end": 135,
				"token_start": 27,
				"token_end": 32,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "Payload",
				"start": 349,
				"end": 356,
				"token_start": 83,
				"token_end": 83,
				"entityLabel": "TOOL_USED"
			}
		],
		"relations": [
			{
				"child": 27,
				"head": 14,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 83,
				"head": 27,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "hunt_cleaned.txt",
		"document": "In this challenge, you see a bunch of captcha's floating around on your screen, and the goal is to successfully get 5 captchas. There's many ways to solve this, here's what was done:\n\nWhen you see the source, this is the function which creates the captchas and makes them move:\n[JavaScript code: Captcha creation and movement function]\n\nTo make it easier to solve the captchas, modify this function using your browser's developer tools, removing the part where it runs the loop, which is responsible for moving the captchas.\n[Modified JavaScript code: Captcha creation function without movement]\n\nNow, you can manually add 5 captchas and get them. Just call the function `addCaptcha()` and keep clicking the boxes. When you're done with 5, click on `GET FLAG`, and copy the flag from the screen!\n",
		"tokens": [
			{
				"text": "browser's developer tools",
				"start": 410,
				"end": 435,
				"token_start": 87,
				"token_end": 90,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "Captcha creation and movement function",
				"start": 296,
				"end": 334,
				"token_start": 66,
				"token_end": 70,
				"entityLabel": "TARGET_COMPONENT"
			}
		],
		"relations": [
			{
				"child": 66,
				"head": 87,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "curly-fries-1_cleaned.txt",
		"document": "The challenge gives us the following text:\n\"Normal fries are nice, but everything's better with a curl in it. The flag is right in front of you.\"\n\nUpon opening the link, an image is displayed, which hints at Sweden. So, the solution involves setting the language headers to Swedish using a \"curl\" command.\n[Shell command: Set Accept-Language header to Swedish]\n\nExecuting this command returns the flag.\n",
		"tokens": [
			{
				"text": "language headers",
				"start": 254,
				"end": 270,
				"token_start": 58,
				"token_end": 59,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "\"curl\" command",
				"start": 290,
				"end": 304,
				"token_start": 64,
				"token_end": 67,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "Accept-Language header",
				"start": 326,
				"end": 348,
				"token_start": 75,
				"token_end": 78,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "Shell command",
				"start": 307,
				"end": 320,
				"token_start": 71,
				"token_end": 72,
				"entityLabel": "TOOL_USED"
			}
		],
		"relations": [
			{
				"child": 64,
				"head": 58,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 71,
				"head": 75,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "curly-fries-2_cleaned.txt",
		"document": "The challenge gives us the following text:\n\"Normal fries are nice, but everything's better with a curl in it. Why do logos make things so recognizable?\"\n\nUpon opening the link, an image is displayed that shows the logos of Xbox and Linux. This is viewed on a Windows device.\n\nTo change the User-Agent to Linux, use the following command:\n[Shell command: Set User-Agent header to Linux]\n\nExecuting this command returns a response with the Linux logo gone.\n\nNext, set the User-Agent to both Linux and Xbox:\n[Shell command: Set User-Agent header to Linux Xbox]\n\nExecuting this command gives the flag inside the body of the page.\n",
		"tokens": [
			{
				"text": "User-Agent header",
				"start": 525,
				"end": 542,
				"token_start": 122,
				"token_end": 125,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "Shell command",
				"start": 506,
				"end": 519,
				"token_start": 118,
				"token_end": 119,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "Shell command",
				"start": 339,
				"end": 352,
				"token_start": 78,
				"token_end": 79,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "User-Agent header",
				"start": 358,
				"end": 375,
				"token_start": 82,
				"token_end": 85,
				"entityLabel": "TARGET_COMPONENT"
			}
		],
		"relations": [
			{
				"child": 118,
				"head": 122,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 82,
				"head": 78,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "curly-fries-3_cleaned.txt",
		"document": "The challenge provides the following hint: \"Normal fries are nice, but everything's better with a curl in it. I'm with you, every step of the way.\"\n\nUpon opening the link, an image is displayed. To solve the challenge, a series of curl commands were executed with various headers, cookies, and JSON data. Here's the process:\n\nChange the method to POST and send a request to the URL.\n\nSet the Referer header to Google and send a request to the URL. In response, you receive a hint to attend a dinner party hosted by dscvit.\n\nSet the Host header to dscvit.com and send a request to the URL. The response mentions potatoes, carrots, milk, and cookies.\n\nSet the user cookie to \"root\" and send a request to the URL, as potatoes and carrots are root vegetables. The response contains a JSON-related hint.\n\nSet the Content-Type header to application/json, include JSON data, and send a request to the URL. The response points out that \"messi\" is required in the JSON data.\n\nAdd \"messi\" to the JSON data and send a request to the URL. The response asks for the club Messi is in.\nChange the \"messi\" value to \"psg\" and send a request to the URL, since Messi is playing for PSG at the time.\n\nAfter executing the final command, the flag is returned.",
		"tokens": [
			{
				"text": "headers",
				"start": 272,
				"end": 279,
				"token_start": 60,
				"token_end": 60,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "curl commands",
				"start": 231,
				"end": 244,
				"token_start": 54,
				"token_end": 55,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "cookies",
				"start": 281,
				"end": 288,
				"token_start": 62,
				"token_end": 62,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "JSON data",
				"start": 294,
				"end": 303,
				"token_start": 65,
				"token_end": 66,
				"entityLabel": "TARGET_COMPONENT"
			}
		],
		"relations": [
			{
				"child": 54,
				"head": 60,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 62,
				"head": 54,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 54,
				"head": 65,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "hungry-man_cleaned.txt",
		"document": "The challenge begins with the given text: \"There is nothing here I promise! ;)\"\n\nUpon opening the link, an image is displayed. By checking the network tab, a response header with a specific string is found. A curl request is then sent, setting the cookie to the given string.\n\nThe response contains another string. A new curl request is sent with this new string as the cookie.\n\nTo automate this process, a Python script is written:\n[Define the initial URL and the first flag value.\nCreate a loop that continues until the final flag value, 'EOF', is found.\nIn each iteration, send an HTTP GET request to the URL with the current flag value as a cookie.\nAppend the received string to the list of flags and continue iterating.\nOnce the loop is finished, print the received strings.]\n\nThe output contains multiple strings, which appear to be MD5 hashes. After decoding these hashes, a sequence of characters is obtained, which is the flag.\n",
		"tokens": [
			{
				"text": "cookie",
				"start": 370,
				"end": 376,
				"token_start": 79,
				"token_end": 79,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "curl request",
				"start": 321,
				"end": 333,
				"token_start": 69,
				"token_end": 70,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "Python script",
				"start": 407,
				"end": 420,
				"token_start": 88,
				"token_end": 89,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "cookie",
				"start": 645,
				"end": 651,
				"token_start": 144,
				"token_end": 144,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "curl request",
				"start": 209,
				"end": 221,
				"token_start": 46,
				"token_end": 47,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "response header",
				"start": 158,
				"end": 173,
				"token_start": 36,
				"token_end": 37,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "cookie",
				"start": 248,
				"end": 254,
				"token_start": 54,
				"token_end": 54,
				"entityLabel": "TARGET_COMPONENT"
			}
		],
		"relations": [
			{
				"child": 69,
				"head": 79,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 144,
				"head": 88,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 36,
				"head": 46,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 46,
				"head": 54,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "taxi-union_cleaned.txt",
		"document": "This solution demonstrates a SQL Injection attack to solve a CTF challenge. The script also works for the `Gate Keeper` challenge. Here's a high-level explanation of the Python script:\n[Import the necessary libraries: `requests` and `string`.\nInitialize an empty `flag` variable, and define the search domain containing all possible characters.\nSet the challenge, URL, check, key, and column variables based on the challenge being solved (either \"taxi union\" or \"gate keeper\").\nEnter an infinite loop that iterates through each character in the search domain.\nFor each character, create a payload containing a SQL injection query using the current flag and character.\nSend an HTTP POST request to the URL with the payload as the data.\nCheck if the expected response text is found in the received response.\nIf the expected response is found, add the character to the flag and print it.\nBreak the loop once the flag is found.]\n\nThe script automates the process of testing various payloads to exploit the SQL Injection vulnerability and retrieve the flag.\n",
		"tokens": [
			{
				"text": "SQL Injection",
				"start": 29,
				"end": 42,
				"token_start": 4,
				"token_end": 5,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "Python script",
				"start": 170,
				"end": 183,
				"token_start": 34,
				"token_end": 35,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "various payloads",
				"start": 970,
				"end": 986,
				"token_start": 206,
				"token_end": 207,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "SQL Injection vulnerability",
				"start": 1002,
				"end": 1029,
				"token_start": 211,
				"token_end": 213,
				"entityLabel": "VULNERABILITY"
			}
		],
		"relations": [
			{
				"child": 34,
				"head": 4,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			},
			{
				"child": 211,
				"head": 206,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "log-me-in_cleaned.txt",
		"document": "When you examine the source code, you'll notice the application uses `bodyParser.urlencoded` with `extended: true`. This allows arrays and objects to be passed in the request body. In the `/login` POST route, the output has not been stringified, so it is possible to pass an object in the query statement.\n[JavaScript code: Configure bodyParser and create SQL query]\n\nThe exploit is to pass an object as the password parameter, with a known attribute. This causes the SQL query to be evaluated in a way that allows logging in without knowing the correct password. We'll refer to the official `mysql` docs for more information on how objects are converted into comma-separated attributes in SQL queries.\n\nThe final payload for this exploit is:\n[HTTP POST request: Send payload with object as password]\n\nFrom here, you can just take the cookie you received, and use that to visit `/flag`. Alternatively, you can use a Python script to automate the process:\n[Python script: Send payload, get the flag, and print it]\n\nYou can run this script and use `grep` to find the flag.\n",
		"tokens": [
			{
				"text": "`bodyParser.urlencoded`",
				"start": 69,
				"end": 92,
				"token_start": 13,
				"token_end": 15,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "examine the source code",
				"start": 9,
				"end": 32,
				"token_start": 2,
				"token_end": 5,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "JavaScript code",
				"start": 307,
				"end": 322,
				"token_start": 66,
				"token_end": 67,
				"entityLabel": "TARGET_COMPONENT"
			}
		],
		"relations": [
			{
				"child": 2,
				"head": 13,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 2,
				"head": 66,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "template-shack_cleaned.txt",
		"document": "When you visit the website, you find that there's a cookie containing a JWT. It's hashed using `HS256`. The JWT secret was brute-forced using `rockyou.txt` and John The Ripper, which revealed the secret as `supersecret`. Using this secret, a JWT with `username: admin` was created and added to the cookie, logging in as admin.\n\nVisiting a random route starting with `/admin/` that throws a 404 error, it was observed that there's scope for template injection in the 404 page. By climbing up the Python MRO using `__class__` and `__bases__`, etc., a list of all available classes was found. At index 405, the `subprocess.Popen` class was discovered.\n\nUsing this class, a reverse shell was spawned by sending a specially crafted URL. A netcat listener was started on the server at the specified port, which ultimately led to gaining a shell.\n\nUpon listing the files and reading the content of `flag.txt`.\n",
		"tokens": [
			{
				"text": "template injection",
				"start": 440,
				"end": 458,
				"token_start": 99,
				"token_end": 100,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "netcat listener",
				"start": 734,
				"end": 749,
				"token_start": 173,
				"token_end": 174,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "the 404 page",
				"start": 462,
				"end": 474,
				"token_start": 102,
				"token_end": 104,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "JWT secret",
				"start": 108,
				"end": 118,
				"token_start": 26,
				"token_end": 27,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "`rockyou.txt",
				"start": 142,
				"end": 154,
				"token_start": 33,
				"token_end": 34,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "John The Ripper",
				"start": 160,
				"end": 175,
				"token_start": 37,
				"token_end": 39,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "a cookie containing a JWT",
				"start": 50,
				"end": 75,
				"token_start": 11,
				"token_end": 15,
				"entityLabel": "TARGET_COMPONENT"
			}
		],
		"relations": [
			{
				"child": 173,
				"head": 99,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			},
			{
				"child": 99,
				"head": 102,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 33,
				"head": 26,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 26,
				"head": 37,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 11,
				"head": 33,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 37,
				"head": 11,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "agent-95_cleaned.txt",
		"document": "The challenge is very simple once you know what to do.\nThis is the hint:\n\"We will only give our flag to our Agent 95! He is still running an old version of Windows...\"\n\nWe assume Agent 95 uses Windows 95. So just change the `User-Agent` header to `Mozilla/4.0 (compatible; MSIE 4.01; Windows 95)`.\n\nWe use a Python script:\n[Python code: using `requests` to send a GET with the `User-Agent` header]\n\nIn the response, you got the flag.\n",
		"tokens": [
			{
				"text": "Python script",
				"start": 308,
				"end": 321,
				"token_start": 79,
				"token_end": 80,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "`User-Agent` header",
				"start": 224,
				"end": 243,
				"token_start": 55,
				"token_end": 60,
				"entityLabel": "TARGET_COMPONENT"
			}
		],
		"relations": [
			{
				"child": 55,
				"head": 79,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "login_cleaned.txt",
		"document": "This is a beginner SQL Injection challenge. To retrieve the flag, you need to inject a malicious SQL query into the login form.\n\nSimply pass the username and the password as ' or 1=1 -- , which will be interpreted as a SQL query that always returns true, and comment out the rest of the query with the -- symbol. This will cause the server to execute the SQL query as if you had provided valid login credentials, resulting in an alert box displaying the flag.\n",
		"tokens": [
			{
				"text": "login form",
				"start": 116,
				"end": 126,
				"token_start": 23,
				"token_end": 24,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "SQL Injection",
				"start": 19,
				"end": 32,
				"token_start": 4,
				"token_end": 5,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "a malicious SQL query",
				"start": 85,
				"end": 106,
				"token_start": 17,
				"token_end": 20,
				"entityLabel": "TOOL_USED"
			}
		],
		"relations": [
			{
				"child": 4,
				"head": 23,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 4,
				"head": 17,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			},
			{
				"child": 17,
				"head": 23,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "panda-facts_cleaned.txt",
		"document": "[This challenge involves exploiting a vulnerability in the `generateToken` function in a JavaScript file. The function generates a token for a given `username`, where the `username` is included as a string in a JSON object that is encrypted using `aes-192-cbc`. However, the function forms the JSON object in a way that allows the \" character to be closed with the help of the string passed in the `username` parameter, and sets the `member` field to a non-zero value.]\n\nYou really just need to notice this function. Notice, the token is not created like `token.username = username`. It's formed in the following way:\n```\nconst token = `{\"integrity\":\"${INTEGRITY}\",\"member\":0,\"username\":\"${username}\"}`\n```\n\nTo exploit the vulnerability, we can pass the `username` as `\",\"member\":\"1` which will close the `\"` character and set `member` to `1`. Then, we can visit `/api/flag` to get the flag in JSON format.\n",
		"tokens": [
			{
				"text": "vulnerability",
				"start": 38,
				"end": 51,
				"token_start": 6,
				"token_end": 6,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "`generateToken` function in a JavaScript file",
				"start": 59,
				"end": 104,
				"token_start": 9,
				"token_end": 16,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "`username` as `\",\"member\":\"1`",
				"start": 754,
				"end": 783,
				"token_start": 164,
				"token_end": 173,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "vulnerability",
				"start": 723,
				"end": 736,
				"token_start": 158,
				"token_end": 158,
				"entityLabel": "VULNERABILITY"
			}
		],
		"relations": [
			{
				"child": 9,
				"head": 6,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 158,
				"head": 164,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "static-pastebin_cleaned.txt",
		"document": "This challenge uses XSS to get the flag from the `admin bot's` cookies.\n\nFirst, try a random `<h1>Hello</h1>` tag to see if you can put HTML in your pastebin.\n\nInspecting the `js` file of the page we can can infer 2 things:\n- the content of the page is obtained from the URL, which is a base64 encoded form of the text you entered.\n- the `clean` function will not allow writing of text if bracket pairs do not match.\n\nIt is rather easy to break this `clean` function, by adding an extra `>` at the starting of your XSS script. Here's the payload:\n[Payload for XSS attack with an extra \">\" at the beginning of the script]\n\nYour payload has the following URL:\n[URL with base64 encoded payload]\n\nYou can simply set up a `netcat listener` using `nc -l port` on your server, and pass the link to the `Admin Bot`. The admin bot is basically a headless chrome browser which has the flag in it's cookies. When it visits your site, the XSS steals the cookies from the admin bot and sends it to your server. You get a request which looks like:\n[HTTP GET request with the flag in the cookie]\n",
		"tokens": [
			{
				"text": "Payload",
				"start": 548,
				"end": 555,
				"token_start": 139,
				"token_end": 139,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "XSS",
				"start": 560,
				"end": 563,
				"token_start": 141,
				"token_end": 141,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "XSS",
				"start": 20,
				"end": 23,
				"token_start": 3,
				"token_end": 3,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "cookies",
				"start": 63,
				"end": 70,
				"token_start": 15,
				"token_end": 15,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "netcat listener",
				"start": 718,
				"end": 733,
				"token_start": 180,
				"token_end": 181,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "XSS",
				"start": 927,
				"end": 930,
				"token_start": 229,
				"token_end": 229,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "cookies",
				"start": 942,
				"end": 949,
				"token_start": 232,
				"token_end": 232,
				"entityLabel": "TARGET_COMPONENT"
			}
		],
		"relations": [
			{
				"child": 141,
				"head": 139,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			},
			{
				"child": 15,
				"head": 3,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 229,
				"head": 180,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			},
			{
				"child": 180,
				"head": 232,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 232,
				"head": 229,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "static-static-hosting_cleaned.txt",
		"document": "This site allows you to write HTML, so it's basically shouting at you to perform an XSS attack. The URL of the webpage created actually consists a base64 encoded form of the content of the page. We can see the `js` in the source.\n\nThe main thing we notice is that it prevents `script` tags and it allows only the following attributes for an element: `'src', 'width', 'height', 'alt', 'class'`. So we have to perform an XSS with these attributes. So, here's the payload:\n[Payload for XSS attack using an iframe and the 'src' attribute]\n\nNote that here, the site is supposed to be `https`, otherwise there will be a Content Security Policy Bypass (CSP Bypass) error, and the request won't be sent. We can get the URL of the resulting webpage:\n[URL with base64 encoded payload]\n\nOn the server, we can create a simple Node.js backend which accepts the cookie as a query param and logs it. Here's an example of the backend code:\n[Node.js code for a simple backend to log the stolen cookie]\n\nWhen the link for the website is sent to the `admin bot`, which is basically a headless chrome browser, it visits the page and it's cookie is stolen and sent to the server at `myserver.tld`. The cookie stores the `flag`.\n",
		"tokens": [
			{
				"text": "stolen cookie",
				"start": 970,
				"end": 983,
				"token_start": 232,
				"token_end": 233,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "Node.js code",
				"start": 925,
				"end": 937,
				"token_start": 223,
				"token_end": 224,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "XSS",
				"start": 483,
				"end": 486,
				"token_start": 120,
				"token_end": 120,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "Payload",
				"start": 471,
				"end": 478,
				"token_start": 118,
				"token_end": 118,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "site",
				"start": 5,
				"end": 9,
				"token_start": 1,
				"token_end": 1,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "XSS",
				"start": 84,
				"end": 87,
				"token_start": 18,
				"token_end": 18,
				"entityLabel": "VULNERABILITY"
			}
		],
		"relations": [
			{
				"child": 223,
				"head": 232,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 118,
				"head": 120,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			},
			{
				"child": 18,
				"head": 1,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "gate-keeper_cleaned.txt",
		"document": "This Python script demonstrates an SQL Injection attack against the web application's database to solve the \"Taxi Union\" and \"Gate Keeper\" challenges. The script performs the following steps:\n[Import the necessary libraries and initialize the variables.\nSet the appropriate URL, check string, key, and column values based on the selected challenge (either \"Taxi Union\" or \"Gate Keeper\").\nIterate through each character in the domain (letters, digits, and special characters) while searching for the flag.\nFor each character, create an SQL injection payload that checks if the current flag value concatenated with the character is a prefix of the targeted column's value.\nSend an HTTP POST request to the URL with the payload as the form data.\nIf the check string is found in the response, it means the character is part of the flag. Add the character to the flag and continue iterating through the domain.\nRepeat the process until the entire flag is discovered.]\n\nThe Python script helps to find the flag by exploiting SQL injection vulnerability in the web application.\n",
		"tokens": [
			{
				"text": "SQL injection vulnerability",
				"start": 1019,
				"end": 1046,
				"token_start": 206,
				"token_end": 208,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "web application",
				"start": 1054,
				"end": 1069,
				"token_start": 211,
				"token_end": 212,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "SQL Injection",
				"start": 35,
				"end": 48,
				"token_start": 5,
				"token_end": 6,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "database",
				"start": 86,
				"end": 94,
				"token_start": 13,
				"token_end": 13,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "script",
				"start": 155,
				"end": 161,
				"token_start": 29,
				"token_end": 29,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "Python script",
				"start": 968,
				"end": 981,
				"token_start": 197,
				"token_end": 198,
				"entityLabel": "TOOL_USED"
			}
		],
		"relations": [
			{
				"child": 211,
				"head": 206,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 13,
				"head": 5,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 5,
				"head": 29,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			},
			{
				"child": 206,
				"head": 197,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			}
		]
	},
	{
		"documentName": "localghost_cleaned.txt",
		"document": "Well, if you happen to look at the local storage, you'll get the flag directly. But that's not how we got it because we're stupid. So, here's what we did.\n\nYou see a JS file in the sources: `jquery.jscroll2.js`. Now, to understand what exactly it does, we first convert the huge list on `line 1` from `hex` to `string` to be able to make sense of it. So let's convert it using a script written in `python2`.\n\nOnce you convert it, you will see some meaningful strings such as `localStorage`, `setItem`, `data`, `defaults`, `extend`, `function`, etc..\nNow we can try to make sense of the rest of the code.\n\nWe see an interesting line. Now that we have the strings figured out:\n[JavaScript code: stores the decoded base64 string in local storage with the key 'flag']\n\nSo the script basically converst the `base64` string `SkNURntzcG9vb29va3lfZ2hvc3RzX2luX3N0b3JhZ2V9` and stores it in local storage with the key `flag`. Well, now you can just check the local storage, or just convert this string to ASCII using BASH.\n",
		"tokens": [],
		"relations": []
	},
	{
		"documentName": "google-source-code_cleaned.txt",
		"document": "The first part of the challenge is a sort of vague guesswork. In the challenge description, there are two words - `page` and `upload` - which the author wants you to notice. Also, when you view the homepage source, it has a comment `<!-- get the 'page' :eyes: -->`. \n\nSo, the first try was to pass a query `page` in the flag. So, we tried to visit `?page=flag`. Here, we get a gif.\n\nNow, since the description had the word `upload` in it, we tried to checkout if there is a page called upload, and there was!\n\nHere, we can assume that we have to do some sort of local file inclusion. So we created a file called `payload.php`, and tried to `ls` the directory. We saw a lot of files called `flag`, so we just decided to print all files and just search on the browser.\n\nHere's the final payload for the PHP code:\n[PHP code payload for local file inclusion to find all files and print them]\n\nNow you can visit the route `/?page=payload` (name of the file you uploaded). This gives a page with a lot of stuff.\n\nSo, the contents of all the files are now on the browser. All you have to do is open the source code and search for the flag format.\n",
		"tokens": [
			{
				"text": "PHP code payload",
				"start": 812,
				"end": 828,
				"token_start": 213,
				"token_end": 215,
				"entityLabel": "TOOL_USED"
			},
			{
				"text": "local file inclusion",
				"start": 833,
				"end": 853,
				"token_start": 217,
				"token_end": 219,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "local file inclusion",
				"start": 562,
				"end": 582,
				"token_start": 151,
				"token_end": 153,
				"entityLabel": "VULNERABILITY"
			},
			{
				"text": "a page called upload",
				"start": 472,
				"end": 492,
				"token_start": 128,
				"token_end": 131,
				"entityLabel": "TARGET_COMPONENT"
			},
			{
				"text": "`payload.php`",
				"start": 612,
				"end": 625,
				"token_start": 161,
				"token_end": 163,
				"entityLabel": "TOOL_USED"
			}
		],
		"relations": [
			{
				"child": 217,
				"head": 213,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			},
			{
				"child": 128,
				"head": 151,
				"relationLabel": "VULNERABILITY-AFFECTS-TARGET_COMPONENT",
				"propertiesList": []
			},
			{
				"child": 151,
				"head": 161,
				"relationLabel": "TOOL_USED-EXPLOITS-VULNERABILITY",
				"propertiesList": []
			},
			{
				"child": 128,
				"head": 161,
				"relationLabel": "TOOL_USED-TARGETS-TARGET_COMPONENT",
				"propertiesList": []
			}
		]
	}
]
