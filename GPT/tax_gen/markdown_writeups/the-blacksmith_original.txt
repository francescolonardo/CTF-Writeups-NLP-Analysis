<hr />

<h2>description: Python is weird.</h2>

<h1>The Blacksmith</h1>

<h2>Introduction</h2>

<p>This was one of the more interesting Web challenges from this CTF, because it taught me something new about Python and how it handles augmented assignment statements.</p>

<p>The challenge centered around a "market" API, where customers could buy "regular" and "exclusive" items.</p>

<p><code>python
SHOP = {
    "customers": [],
    "inventory": {
        "regular": (
            Weapon("brokensword", 5, 0),
            Weapon("woodensword", 5, 1),
            Weapon("stonesword", 10, 2),
            Weapon("ironsword", 50, 10),
            Weapon("goldsword", 100, 20),
            Weapon("diamondsword", 500, 100),
        ),
        "exclusive": (Weapon("flagsword", 5, 0),),
    },
}
</code></p>

<p>The customer's eligibility to purchase exclusive items depends on the customer's <code>tier</code>, which checks if the customer's <code>fame</code> and the sum of their loyalty <code>point_history</code> exceeds 1337.</p>

<p>```python
@dataclass
class Customer:
    id: str
    gold: int
    loyalty: Loyalty | RestrictedLoyalty</p>

<pre><code>@property
def tier(self):
    if (self.loyalty.fame + sum(self.loyalty.point_history)) &gt; 1337:
        return "exclusive"
    return "regular"

@staticmethod
def index_from_id(id):
    for idx, customer in enumerate(SHOP["customers"]):
        if customer.id == id:
            return idx
    return None
</code></pre>

<p>```</p>

<h2>Exploring the API</h2>

<p>The first bug that might have been immediately obvious when visiting the page is that the index page is unauthenticated. Although the <code>customer_id</code> parameter is checked, a <code>HTTPException</code> is called but <em>not raised</em>.</p>

<p>```python
@app.get("/")
def index(customer<em>id=""):
    customer = Customer.index</em>from<em>id(customer</em>id)</p>

<pre><code>if customer is None:
    HTTPException(status_code=401)

shop_items = [
    *SHOP["inventory"]["exclusive"],
    *SHOP["inventory"]["regular"],
]
if LOYALTY_SYSTEM_ACTIVE:
    return shop_items

return [item for item in shop_items if item.loyalty_points == 0]
</code></pre>

<p>```</p>

<p>This pattern does not repeat itself in any of the other API routes, though. We can see that we in fact need a valid <code>customer_id</code> to access the rest of the features.</p>

<p><code>python
if customer_idx is None:
    raise HTTPException(status_code=401)
</code></p>

<p>Let's register a new user. Because <code>LOYALTY_SYSTEM_ACTIVE</code> is set to <code>False</code>, we are given a <code>RestrictedLoyalty</code>  which is a <code>namedtuple</code>. This is an <a href="https://realpython.com/courses/immutability-python/">immutable</a> data structure. We also start with 5 <code>gold</code>.</p>

<p>```python
LOYALTY<em>SYSTEM</em>ACTIVE = False</p>

<p>...</p>

<p>RestrictedLoyalty = namedtuple("RestrictedLoyalty", ["fame", "point_history"])</p>

<p>...</p>

<p>@app.get("/customer/new")
def register():
    if LOYALTY<em>SYSTEM</em>ACTIVE:
        customer = Customer(id=uuid4().hex, gold=5, loyalty=Loyalty(1, []))
    else:
        # Ensure loyalty immutable
        customer = Customer(
            id=uuid4().hex, gold=5, loyalty=RestrictedLoyalty(1, [])
        )</p>

<pre><code>SHOP["customers"].append(customer)
print(SHOP['customers'])

return {"id": customer.id}
</code></pre>

<p>```</p>

<p>Visiting this endpoint provides us with a new customer ID.</p>

<p>```http
HTTP/1.1 200 OK
date: Wed, 07 Dec 2022 08:28:52 GMT
server: uvicorn
content-length: 41
content-type: application/json
Connection: close</p>

<p>{"id":"710eab1db93e413192e908358c38c168"}
```</p>

<p>A <code>/battle</code> endpoint provides a potential way to increase our <code>fame</code>, but as we saw earlier, <code>LOYALTY_SYSTEM_ACTIVE</code> is <code>False</code> so this is not possible.</p>

<p>```python
@app.get("/battle")
def battle(customer<em>id=""):
    customer</em>idx = Customer.index<em>from</em>id(customer<em>id)
    if customer</em>idx is None:
        raise HTTPException(status_code=401)</p>

<pre><code>is_victorious = choice([True, False])

if is_victorious and LOYALTY_SYSTEM_ACTIVE:
    SHOP["customers"][customer_idx].loyalty.fame += 1

message = "You won!" if is_victorious else "You lost!"

return {"result": message}
</code></pre>

<p>```</p>

<p>Since our goal is to purchase the <code>flagsword</code>, we should take a look at the <code>/buy</code> endpoint. Since this function is rather long, I'll break it up into parts.</p>

<p>First, we have to provide our <code>customer_id</code> and a list of <code>items</code> that we want to buy.</p>

<p>```python
def weapon<em>from</em>name(weapons, name):
    for weapon in weapons:
        if weapon.name == name:
            return weapon
    return None</p>

<p>...</p>

<p>@app.get("/buy")
def buy<em>item(customer</em>id="", items: list[str] | None = Query(default=[])):
    customer<em>idx = Customer.index</em>from<em>id(customer</em>id)</p>

<pre><code>if customer_idx is None:
    raise HTTPException(status_code=401)

if items is None:
    return {"purchased": ""}
</code></pre>

<p>```</p>

<p>The weapons that we are eligible to purchase depends on our customer <code>tier</code>. Since we are a <code>regular</code> plebeian, we can only get to purchase regular weapons. Among the regular weapons, we only have enough gold to buy either a <code>brokensword</code> or a <code>woodensword</code>.</p>

<p>```python
    match SHOP["customers"][customer<em>idx].tier:
        case "regular":
            get</em>weapon = partial(
                weapon<em>from</em>name, SHOP["inventory"]["regular"]
            )
        case "exclusive":
            get<em>weapon = partial(
                weapon</em>from<em>name,
                [
                    *SHOP["inventory"]["regular"],
                    *SHOP["inventory"]["exclusive"],
                ],
            )
        case _:
            raise HTTPException(status</em>code=500)</p>

<pre><code>cart = []
for item in items:
    weapon = get_weapon(item)
    if weapon is None:
        raise HTTPException(status_code=404)
    cart.append(weapon)
</code></pre>

<p>```</p>

<p>If any of the items we are attempting to buy exceeds our available <code>gold</code>, a 403 Forbidden is returned. The total price of all items is summed up and the loyalty points of the items are stored in a <code>point_history</code> list.</p>

<p><code>python
    total_price = 0
    point_history = []
    for item in cart:
        if item.price &gt; SHOP["customers"][customer_idx].gold:
            raise HTTPException(status_code=403)
        total_price += item.price
        if item.loyalty_points &gt; 0:
            point_history += [item.loyalty_points]
</code></p>

<p>If there are any loyalty points involved, the code attempts to add the <code>point_history</code> list to our customer <code>point_history</code> record, <a href="https://realpython.com/python-lbyl-vs-eafp/#the-easier-to-ask-forgiveness-than-permission-eafp-style">EAFP</a>-style.</p>

<p><code>python
    try:
        if len(point_history) &gt; 0:
            SHOP["customers"][
                customer_idx
            ].loyalty.point_history += point_history
        if SHOP["customers"][customer_idx].gold &lt; total_price:
            raise HTTPException(status_code=403)
        SHOP["customers"][customer_idx].gold -= total_price
    except Exception as e:
        raise HTTPException(status_code=403)
</code></p>

<p>Note that because our loyalty object is an immutable <code>namedtuple</code>, this will definitely raise an exception. In fact, attempting to set any attribute in the <code>namedtuple</code> will cause an <code>AttributeError</code> when performing the assignment.</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>from collections import namedtuple
      RestrictedLoyalty = namedtuple("RestrictedLoyalty", ["fame", "point<em>history"])
      my</em>loyalty = RestrictedLoyalty(0, [])
      my_loyalty.fame = 1
      Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
      AttributeError: can't set attribute
      ```</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>Finally, if we managed to purchase a <code>flagsword</code>, then we are presented with the flag.</p>

<p>```python
    if "flagsword" in [weapon.name for weapon in cart]:
        return {"purchased": FLAG}</p>

<pre><code>return {"purchased": cart}
</code></pre>

<p>```</p>

<h2>Immutability is Misleading</h2>

<p>I didn't manage to spot this bug for quite a while, but luckily this challenge is one that can be solved by fuzzing and logging out as many things as possible.</p>

<p>If we just analyze the behaviour of the application when attempting to set the <code>point_history</code>, we would quickly find that something weird is going on.</p>

<p><code>python
try:
    if len(point_history) &gt; 0:
        SHOP["customers"][
            customer_idx
        ].loyalty.point_history += point_history
    if SHOP["customers"][customer_idx].gold &lt; total_price:
        raise HTTPException(status_code=403)
    SHOP["customers"][customer_idx].gold -= total_price
except Exception as e:
    print("Exception: ", e)
    print("Point history: ", SHOP["customers"][customer_idx].loyalty.point_history)
    raise HTTPException(status_code=403)
</code></p>

<p>By sending a request to buy a <code>woodensword</code> (costing 5 gold and having 1 loyalty point) as follows</p>

<p><code>
/buy?customer_id=96d04a31cdca47dba99e588f85d28b1b&amp;items=woodensword
</code></p>

<p>We see that the <code>AttributeError</code> is raised as expected, but somehow, our point history has actually been modified!</p>

<p><code>
Exception:  can't set attribute
Point history:  [1]
INFO:     172.17.0.1:59960 - "GET /buy?customer_id=96d04a31cdca47dba99e588f85d28b1b&amp;items=woodensword HTTP/1.1" 403 Forbidden
</code></p>

<p>Wait... what??? I thought the <code>namedtuple</code> is immutable?</p>

<h2>Digging Deeper</h2>

<p>I wanted to dig a little deeper to investigate the root cause of this weird behaviour that challenged my <em>Introduction to Programming</em> Python knowledge.</p>

<p>Immutability in Python is tricky - while the tuple itself is immutable, if a tuple contains a mutable object, that object can still be modified <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a>. For example, if we have a <code>list</code> within a <code>tuple</code>, that list can still be modified in-place using a method such as <code>append</code>.</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tup = (["hello"], )
      tup[0].append("world")
      tup
      (['hello', 'world'],)
      ```</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>But wasn't the code performing <em>assignment</em> instead of an in-place operation? Didn't the exception get raised anyway?</p>

<p>Turns out, all the <em>Introduction to Programming</em> lessons that taught me <code>x += y</code> was the same as <code>x = x + y</code> were wrong. Taking a look at Python's <a href="https://docs.python.org/3/reference/simple_stmts.html">documentation</a> on statements, we would see that it is explained that these two statements are not quite the same.</p>

<blockquote>
  <p>An augmented assignment expression like <code>x += 1</code> can be rewritten as <code>x = x + 1</code> to achieve a similar, but not exactly equal effect. In the augmented version, <code>x</code> is only evaluated once. Also, when possible, the actual operation is performed <em>in-place</em>, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead.</p>
</blockquote>

<p>Hmm... ok, but if the operation is only performed in-place, why raise the error?</p>

<p>I then looked up Python's <a href="https://docs.python.org/3/library/operator.html">in-place operators</a>, and found that the <code>+=</code> operator is just syntactic sugar for the <code>__iadd__</code> method. Basically, when doing <code>x += y</code>, we are really doing:</p>

<p><code>python
x = x.__iadd__(y)
</code></p>

<p>and because some objects like tuples are immutable, it is not <em>guaranteed</em> that the operation would be in-place, so there is still an assignment step regardless of whether the operation was in-place or not.</p>

<p>For list objects, the <code>__iadd__</code> method (implemented as <a href="https://github.com/python/cpython/blob/main/Objects/listobject.c#L985"><code>list_inplace_concat</code></a> in the CPython source) is just a wrapper for <code>list_extend</code>, an in-place method. We see that the original list object is still returned to make the assignment step work.</p>

<p>```c
static PyObject *
list<em>inplace</em>concat(PyListObject *self, PyObject *other)
{
    PyObject *result;</p>

<pre><code>result = list_extend(self, other);
if (result == NULL)
    return result;
Py_DECREF(result);
return Py_NewRef(self);
</code></pre>

<p>}
```</p>

<p>It is at the <em>assignment</em> step that an error is raised, because the immutable <code>namedtuple</code> does not support item assignments. But by the time this happens, the list has already been modified.</p>

<h2>Back to the Challenge</h2>

<p>In order to solve this challenge, we just have to buy the <code>woodensword</code> 1337 times. Note that because our gold amount is checked against <code>total_price</code> only <em>after</em> the <code>point_history</code> assignment is attempted, we can just add the <code>woodensword</code> to our cart 1337 times.</p>

<p><code>python
if len(point_history) &gt; 0:
    SHOP["customers"][
        customer_idx
    ].loyalty.point_history += point_history
if SHOP["customers"][customer_idx].gold &lt; total_price:
    raise HTTPException(status_code=403)
SHOP["customers"][customer_idx].gold -= total_price
</code></p>

<p>First, we send a request to increase our loyalty point history 1337 times.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2022-12-07 at 5.35.10 PM.png" alt=""><figcaption></figcaption></figure>

<p>Then we could unlock and buy the <code>flagsword</code>!</p>

<p><code>
/buy?customer_id=96d04a31cdca47dba99e588f85d28b1b&amp;items=flagsword
</code></p>

<p>```http
HTTP/1.1 200 OK
date: Wed, 07 Dec 2022 09:35:01 GMT
server: uvicorn
content-length: 83
content-type: application/json
Connection: close</p>

<p>{"purchased":"STF22{this<em>is</em>a<em>dummy</em>flag<em>for</em>your<em>personal</em>testing<em>do</em>not_submit}"}
```</p>
