{
    "AttackModel": {
        "Steps": [
            {
                "StepNumber": 1,
                "StepString": "Received a Markdown Editor web application to host notes for a challenge with an admin bot that visits URL submissions"
            },
            {
                "StepNumber": 2,
                "StepString": "Wanting to create an XSS payload, started by analysing how the web application processes Markdown"
            },
            {
                "StepNumber": 3,
                "StepString": "Found that the preview feature on the right side is an iframe of /demo"
            },
            {
                "StepNumber": 4,
                "StepString": "Found that the Preview button posts a message to the iframe, ensuring that the message is only sent to the intended receiver"
            },
            {
                "StepNumber": 5,
                "StepString": "Found that the iframe's message is received and processed in /demo, with data POST-ed to the /api/filter endpoint and sanitized HTML added to document.body.innerHTML"
            },
            {
                "StepNumber": 6,
                "StepString": "Noticed that the iframe also posts the response from the /api/filter endpoint to window.parent, meaning any site can create an iframe of the web application and receive the message"
            },
            {
                "StepNumber": 7,
                "StepString": "Found that the user's cookies are sent along with the POST request, and if /api/filter endpoint returns sensitive, user-specific data based on these cookies, this information could be read"
            },
            {
                "StepNumber": 8,
                "StepString": "Realised that the server code for /api/filter endpoint does indeed return the hash of the user's token in the response"
            },
            {
                "StepNumber": 9,
                "StepString": "Created a payload that loads /demo in an iframe, posts a message to trigger the /api/filter POST request in the admin's context, then catches and sends the response, containing the admin's hash, to an exploit server"
            },
            {
                "StepNumber": 10,
                "StepString": "Received the admin's hash on the exploit server, but realized that this is not enough to access the flag - admin's token access is required, which needs a CSRF to /api/flag, necessitating an XSS on the challenge server"
            },
            {
                "StepNumber": 11,
                "StepString": "Noted that when the admin's hash is used, the /api/create handler does not sanitize data. Hence, XSS payload is generated by sending a POST request to /api/create"
            },
            {
                "StepNumber": 12,
                "StepString": "Created a CSRF payload that fetches /api/flag and makes a callback to the exploit server with the page contents. Utilized fromCharCode() to avoid escaping single and double quotes"
            },
            {
                "StepNumber": 13,
                "StepString": "Finally, received the /api/flag contents, URL-decoded the output, and obtained the flag"
            }
        ]
    }
}