Connecting to the website and analyzing the HTML you can find a link to a js script.

Connecting to `source` endpoint will reveal the following.

[Javascript code that sets up a web server using the Express.js framework. The server provides various routes for handling HTTP requests, such as serving static files, rendering HTML templates, and interacting with a Google Cloud Datastore to store and retrieve notes. It also uses various middleware functions to parse request bodies, handle reCAPTCHA challenges, and handle caching.]

The service is similar to Pastebin, you can create a message that will be stored with an ID and then you can share it. Analyzing the page of a created message, you can find an interesting comment.

So the exploitation process should involve the creation of a Stored XSS in order to exfiltrate session cookies.

An interesting snippet can be here, where the `escape_string` method is called.

[Javascript code defining a route for an Express.js web application that retrieves a note from a database based on its ID, escapes the note's content to prevent cross-site scripting (XSS) attacks, and renders the note's content in a view along with a CAPTCHA.]

The method definition is the following.

[JavaScript function that takes a string and escapes any HTML angle brackets it contains, by replacing them with the corresponding Unicode escape sequences using the backslash-x notation.]

The content of the note is reflected here in the source code, then inserted into the HTML.

In the HTML is inserted after the `DOMPurify.sanitize` method, so the XSS must be triggered before.

Using double quotes to try to close the constant, i.e. `"; alert(); "`, will fail.

Trying to escape their escape, i.e. `\";alert();//`, will not work.

The presence of the following snippet means that you can POST "nested object", because `extended` is `true`.

[JavaScript code that configures the Express app to use the bodyParser middleware to parse incoming URL-encoded form data with the "extended" option set to "true".]

So a request like the following can be crafted.

[HTTP POST request with various headers and a payload in the form of URL-encoded key-value pairs.]

The result produced will be the following.

[HTML script that declares a JavaScript variable "note" containing a JSON-like string, sets a variable "note_id" to a UUID, gets two HTML elements by their IDs, sanitizes "note" using the DOMPurify library, sets the innerHTML property of one element to the sanitized "note" and the href and innerHTML properties of the other element to "/{note_id}" and "{note_id}", respectively.]

So the JavaScript `const` can be altered, closing the string and inserting arbitrary JavaScript.

A working XSS can be obtained with the following payload.

[HTTP POST request with form data that includes a payload in the "content" field containing the string ";alert();//".]

The result will be the following.

[HTML script element containing JavaScript code that retrieves a note with a specific ID and populates the content of a web page element with the note's sanitized contents, and updates the href and innerHTML properties of another web page element to display the note ID and link to the note's URL.]

At this point it is sufficient to have a listening host with `nc -lkv 1337`.

A request like the following can be crafted.

[HTTP POST request headers and body with form data containing a JavaScript code that aims to exploit a vulnerability in a web application by sending the user's cookie information to an attacker-controlled server.]

The result will be the following. 

[JavaScript code that sets a cookie and sends it to an IP address on port 1337. It also retrieves an element by ID and sets its innerHTML to the sanitized value of a variable named "note", and sets the href and innerHTML of another element to a specific note ID.]

To bypass problems with reCAPTCHA, it is sufficient to create another note and to change the HTML source, in order to signal it to TJMike passing the previous, malicious, `note_id`.

[Terminal output showing the flag.]