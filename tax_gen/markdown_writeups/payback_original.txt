<h1>Payback</h1>

<h2>Description</h2>

<blockquote>
  <p>We got ourself a premium flag shop.</p>
</blockquote>

<p>{% file src="../../.gitbook/assets/payback.zip" %}</p>

<h2>Solution</h2>

<h3>Code Review</h3>

<p>The app consists of two parts - the frontend and the payment backend (<code>front</code> and <code>payment</code>). Interestingly the user accounts for the frontend and backend are separate!</p>

<p>When performing a transaction, a message is signed using ED25519 to prevent tampering. The message format is <code>user{u}amount{amount}nonce{nonce}</code>. The amount is checked, and since our balance is 0, we can only use 0 for the amount.</p>

<p>```python
@app.route('/pay', methods=['GET', 'POST'])
def pay():
    if 'logged<em>in' not in session:
        return redirect(url</em>for('login', next=request.url))</p>

<pre><code>if request.method == "GET":
    return render_template('amount.html')

amount = int(request.form.get('amount', 0))

user = User.query.filter_by(name=session['name']).first()

if amount &gt; user.balance:
    return "Insufficient balance", 400

if amount &lt; 0:
    return "Invalid amount", 400

cb = request.args['callback']
u = request.args['user']
nonce = request.args['nonce']

m = f"user{u}amount{amount}nonce{nonce}".encode()

sig = SIG_KEY.sign(m, encoding='hex')

user.balance -= amount
db.session.commit()

return redirect(f"{cb}/callback?user={u}&amp;amount={amount}&amp;nonce={nonce}&amp;sig={sig.decode()}", code=302)
</code></pre>

<p>```</p>

<p>The user is redirected to <code>/callback</code> on the frontend application.</p>

<p>This message is then verified by the frontend.</p>

<p>```python
def callback():
    message, signature = b"", b""</p>

<pre><code>for param in request.args:
    if param == "sig":
        signature = request.args[param].encode()
        continue

    for value in request.args.getlist(param):
        message += param.encode()
        message += value.encode()

print("Message", message, flush=True)

try:
    verify_key.verify(signature, message, encoding='hex')

    user = User.query.filter_by(name=session['name']).first()
    nonce = int(request.args['nonce'])

    if nonce &lt;= user.nonce:
        raise Exception

    user.nonce = nonce
    user.balance += int(request.args.get('amount', 0))
    db.session.commit()
except:
    traceback.print_exc()
    return "Something went wrong", 400

return redirect('home')
</code></pre>

<p>```</p>

<p>Notice that it iterates through the list of GET query parameters and adds them to the message before verifying that the message is the same as the one generated above.</p>

<p>Then, <code>request.args.get('amount')</code> is added to the user balance.</p>

<h3>Parameter Pollution</h3>

<p>Well, what if there are two <code>amount</code> arguments? Only the first occurrence is returned by <code>request.args.get</code> (so the amount added to the user's balance is the first <code>amount</code> argument), yet both occurrences are added to the message to be verified.</p>

<p>Since the message format is <code>user{u}amount{amount}nonce{nonce}</code> we can simply create a user with the username <code>FRONTEND_USERNAMEamount1337</code>. The resulting message is then <code>userFRONTEND_USERNAMEamount1337amount0nonceNONCE</code>.</p>

<p>The server gives us the signature for this message.</p>

<p>Then, we perform parameter pollution on the frontend:</p>

<p><code>GET /callback?user=FRONTEND_USERNAME&amp;amount=1337&amp;amount=0&amp;nonce=NONCE&amp;sig=SIGNATURE</code>.</p>

<p>Due to the way the frontend processes the parameters, this will result in the exact same message as above being checked, although carrying a different meaning.</p>

<p><img src="../../.gitbook/assets/image (83) (1) (1) (1).png" alt="" /></p>

<p>We have successfully added 1337 coins to our account!</p>

<p>The flag is <code>CSR{sometimes_it's_really_hard_to_create_good_flags}</code></p>
