This is a PHP `eval()` injection challenge. 

When submitting the form, the input is wrapped around an `echo` statement and added to the `print` GET parameter:

The first thing we tried was to modify the GET parameter to test for arbitrary code execution:

By checking the `debug` option, we are presented with the page's source code. The following code implements the input blacklist and the `eval()` vulnerability:

Many useful functions have been blocked! But note that the `eval()` statement is called _after_ the `$blocked`, `$special_block` and `$$special_block` variables are defined. This allows us to reference these variables in our `eval`-ed code.

Note that `$$` has a special meaning in PHP: [https://stackoverflow.com/questions/4169882/what-is-in-php](https://stackoverflow.com/questions/4169882/what-is-in-php)

What happens here is that the value of  `$foo` is used as a variable name, and so `$$foo` becomes `$hello` (think of it as replacing `$foo` in `$$foo`).

Here, the value of `$special_block` is used as a variable name. The second line defines a new variable, `$nc`, which has the value of `"../flag.txt"`.

Our final payload is

which leads to the following code being `eval`-ed:

Note that `$[a-zA-Z]` is blocked in the regex, so we must use `${...}` instead (which achieves the same purpose). Also, `eval()` executes `file_get_contents("../flag.txt")` but doesn't display anything to us yet. By returning and printing the output, we retrieve the flag.
