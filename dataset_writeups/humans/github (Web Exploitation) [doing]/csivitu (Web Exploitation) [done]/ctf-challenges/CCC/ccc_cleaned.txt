Description: "You can steal a car if you steal its key."

First, in the website source, you can see that there's a route to login (`/login`) and a route to get the names of the admins (`/adminNames`). So, when you try to visit `/login`, you see a form. Post that and check the response on the Network Tab in your browser. You can see there's a header called `token` which stores a JWT. You can decode the token (maybe on `jwt.io` to see that the payload is the following (I typed username: asd, password: asd):
`{ "username": "nfq", "password": "nfq", "admin": "snyfr", "iat": 1593506966 }`

We can see that the `username` changed from `asd` to `nfq`. So this hints that this could be `rot13`. When you apply the `rot13` cipher on the admin value `snyfr`, you see that it returns a string `false`. So, we can change this to a rot13 encrypted string for `true`, but to do that, we need the JWT secret.

On going back to the page, you see there's a route called `/adminNames`. It downloads a file for you, which has sort of a URL: `csivitu/authorized_users/blob/master/`. Seems familiar? This looks like a GitHub URL. So, if you visit that repository on GitHub, and checkout the `root`, you can see a list of usernames. These are the usernames of the website admins!

Now, in the JWT you were creating, you can change the `username` key to a rot13 encrypted version of one of these, for example, `ebrebuna` is the rot13 encrypted ciphertext for `roerohan`. Here's what our JWT payload looks like now:
`{ "username": "ebrebuna", "password": "nfq", "admin": "gehr", "iat": 1593506966 }`

But, we still need the JWT secret. If you observe the request on `/adminNames`, you see that it actally redirects to `/getFile?file=admins`. This route seems suspicious. We can try to include other files using this. When you try `/getFile?file=.env`, it returns `No such file or directory: /app/public/.env`. So, we can try `../.env` to come out of the public folder. You get a file in return, which is the `.env` containing the secret!

Now, visit the /admin route. It says that the token is invalid, so you'll have to pass the JWT in the headers. Auth tokens are generally passed in the Authorization header, so let's try that. When you pass the new formed JWT in the Authorization header, you can do this using python.
[Python snippet: Send a GET request to the /admin route with the JWT in the Authorization header]

The text in the response is:
"Hey roerohan! Here's your flag: pfvpgs{1a_gu3_3aq_1g_q0rfa'g_3i3a_z4gg3e}"

rot13 decrypt this flag to get the real flag.
