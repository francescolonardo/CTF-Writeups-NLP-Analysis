1. Looking at the source code we see that in the `challenge/helpers/JWTHelper.js` file, both the "RS256" and "HS256" algorithms are allowed for decryption. This is CVE-2016-5431/CVE-2016-10555.

2. The HS256 algorithm is symmetric, which means it uses the sane secret key to sign and verify each message. The RS256 algorithm is asymmetric, which means it uses a private key to sign the message and a public key for verification. However, if we change the algorithm from RS256 to HS256, the backend code will use the public key as the symmetric secret key. In other words, the HS256 algorithm will be used to verify the signature with the public key as the HS256 secret key. We know the public key so we can, in theory, easily modify the JWT and sign it.

3. However, before we can do this we need to get the JWT token and get the public key. So, make an account on the website, open up your browser's cookie page in the developer tools, and copy the `session` cookie. We can use [JWT.io](https://jwt.io/) or [ticarpi/jwt_tool](https://github.com/ticarpi/jwt_tool) to decode the cookie.
[Python command: Use jwt_tool.py to decode the JWT token]

4. Fortunately for us, the public key is encoded in the JWT. So, to get access to the `/api/elf/edit` and `/api/elf/list` endpoints, we need to tamper with this token to change the `username` to "admin" using the RS256-to-HS256 exploit.

5. There are an abundance of ways that you can perform the RS256-to-HS256 exploit: [3v4Si0N/RS256-2-HS256](https://github.com/3v4Si0N/RS256-2-HS256), [ticarpi/jwt_tool](https://github.com/ticarpi/jwt_tool), manually via [JWT.io](https://jwt.io/), by running the commands in [this excellent guide](https://habr.com/en/post/450054/). However, you have to be very careful about newlines in the public key. I tried all of these methods with about every option possible. One way that worked is by running a command using `jwt_tool.py`, providing the JWT and public key as input, applying the key confusion exploit and specifying the username to be changed to "admin".
Alternatively, see [Alternative JWT Decoding Steps](#alternative-jwt-decoding-steps) for an approach using [JWT.io](https://jwt.io/).

The output of this command has the tampered token.

6. Anyway, once you have the tampered token, swap it out with the non-admin token in your browser's developer tools. Now, we can access the admin dashboard and the `/api/elf/edit` and `/api/elf/list` endpoints.

7. Back in the source code, if we look at the `challenge/routes/index.js` file we see that the `/` endpoint uses the `CardHelper` class to generate the card with a list of the elf's names. Since we are now an admin, we can edit the names of these elfs, and thus we control this value. Looking at `challenge/helpers/CardHelper.js`, we notice that the `nunjucks` templating engine is used and that we can contol what is passed to a `nunjucks` template. Thus, this is a `nunjucks` SSTI (Server-Side Template Injection).

8. Searching for "nunjucks ssti" reveals [this great guide](http://disse.cting.org/2016/08/02/2016-08-02-sandbox-break-out-nunjucks-template-engine) about breaking out of the `nunjucks` templating engine. We can run `{{range.constructor("return global.process.mainModule.require('child_process').execSync('cat /flag*')")()}}` to print the contents of the `/flag` file. We determined that this is where the flag is by looking at the `Dockerfile` in the challenge ZIP. The `flag` file is copied to `/flag` within the container.

9. So, in the admin dashboard, we copy and paste out payload `{{range.constructor("return global.process.mainModule.require('child_process').execSync('cat /flag*')")()}}` into one off the elf's name field, submit the changes, and then we navigate back to the home page, `/`, and there's the flag. You can view the source of this page to make copy and pasting the flag easier.

### Alternative JWT Decoding Steps

1. Get a JWT token from the application by signing into any account and paste it into [JWT.io](https://jwt.io/).

2. Copy the public key and make sure that there is no new line at the end. I got this public key from [JWT.io](https://jwt.io/):
[Public key obtained from JWT.io]

3. Base64 encode the public key with `echo -en "public key" | base64`. We use the `-e` and `-n` flags with `echo` to tell it to intepret escape sequences and to not output a newline at the end.
[Bash command: Base64 encode the public key]

4. Paste the JWT into [JWT.io](https://jwt.io/) again. Then, change change the algorithm to "HS256" and change the `username` field to "admin". Next, paste the base64 encoded key into the "your-256-bit-secret" field. Check the "secret base64 encoded" box, and now you should have your tampered JWT.
