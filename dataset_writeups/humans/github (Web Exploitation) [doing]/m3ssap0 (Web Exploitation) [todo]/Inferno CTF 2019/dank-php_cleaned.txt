The website will show its own source code.

You have to bypass some checks in order to get the flag. The first part of the flag, i.e. `$flag1`, is printed after the first check, the second part of the flag can be obtained executing `echoFlag()` method when the `eval($cap)` instruction is reached.

First of all you have to replicate a serialized input to pass via `id` HTTP GET parameter.

The result is a payload with a serialized object.

The first check to bypass is the following.

[PHP code setting a value to a property "secret" of an object "usr", and checking if the object's "name" property is "admin" and the object's "pass" property is equal to the "secret" property.]

This can be achieved referencing `$usr->secret` field from the `$usr->pass` field, so when the assign operation with `$flag1` will be performed, both fields will be equals.

In PHP serialization, this can be done with the `R` clause, pointing to the index of the referenced object.

The complete URL is the following.

[URL containing query parameters, with the value of the "id" parameter being a serialized PHP object.]

The answer will contain the first part of the flag.

The second check to bypass is the following.

[PHP code that takes a "caption" parameter from the URL and performs checks on its length and content. If the caption contains only alphanumeric characters, the script will terminate with an error message. Otherwise, it will execute the caption as PHP code using the eval() function, potentially running arbitrary code.]

This is quite hard, because there are two strong constraints.

Usually, `preg_match` can be bypassed using arrays, but in this case I was not able to use the content of the array into the `eval` instruction.

Googling around, I learned about a technique to bypass WAF using non-alfanumeric input, performing logic operations on non-alfanumeric chars using non-alfanumeric variables.

Considering the check on the length, and the overhead of this kind of payloads, probably the best way to attack the endpoint is to read another HTTP GET parameter, with non-alfanumeric name, e.g. `_`.

I started crafting my payload.

Using bitwise XOR operation in PHP, you can craft `_GET` string using non-alfanumeric chars and assign this value to a variable with a non-alfanumeric name.

[A PHP code snippet that assigns the string "GET" to the variable $ using bitwise XOR operations.]

Then you can specify the execution of the content of a GET parameter with the following code.

[PHP code that invokes the function specified in the value of the _ parameter passed through the $_GET superglobal array.]

So the complete payload that will be executed by the `eval` instruction will be the following.

[This is an obfuscated PHP code snippet that executes a function denoted by the underscore character "_".]

Putting everything together, you can craft the final URL to invoke. The last thing to do is to specify the HTTP GET parameter called `_` where the name of the function to call will be passed.

The web page will give the complete flag.