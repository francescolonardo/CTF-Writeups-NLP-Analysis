<h1>knock-knock</h1>

<h2>Description</h2>

<blockquote>
  <p>Knock knock? Who's there? Another pastebin!!</p>
</blockquote>

<p>{% tabs %}
{% tab title="index.js" %}
```javascript
const crypto = require('crypto');</p>

<p>class Database {
  constructor() {
    this.notes = [];
    this.secret = <code>secret-${crypto.randomUUID}</code>;
  }</p>

<p>createNote({ data }) {
    const id = this.notes.length;
    this.notes.push(data);
    return {
      id,
      token: this.generateToken(id),
    };
  }</p>

<p>getNote({ id, token }) {
    if (token !== this.generateToken(id)) return { error: 'invalid token' };
    if (id &gt;= this.notes.length) return { error: 'note not found' };
    return { data: this.notes[id] };
  }</p>

<p>generateToken(id) {
    return crypto
      .createHmac('sha256', this.secret)
      .update(id.toString())
      .digest('hex');
  }
}</p>

<p>const db = new Database();
db.createNote({ data: process.env.FLAG });</p>

<p>const express = require('express');
const app = express();</p>

<p>app.use(express.urlencoded({ extended: false }));
app.use(express.static('public'));</p>

<p>app.post('/create', (req, res) =&gt; {
  const data = req.body.data ?? 'no data provided.';
  const { id, token } = db.createNote({ data: data.toString() });
  res.redirect(<code>/note?id=${id}&amp;token=${token}</code>);
});</p>

<p>app.get('/note', (req, res) =&gt; {
  const { id, token } = req.query;
  const note = db.getNote({
    id: parseInt(id ?? '-1'),
    token: (token ?? '').toString(),
  });
  if (note.error) {
    res.send(note.error);
  } else {
    res.send(note.data);
  }
});</p>

<p>app.listen(3000, () =&gt; {
  console.log('listening on port 3000');
});
```
{% endtab %}</p>

<p>{% tab title="Dockerfile" %}
```docker
FROM node:17.4.0-buster-slim</p>

<p>RUN mkdir -p /app</p>

<p>WORKDIR /app</p>

<p>COPY package.json .</p>

<p>RUN yarn</p>

<p>COPY . .</p>

<p>USER node</p>

<p>CMD ["node", "index.js"]
```
{% endtab %}
{% endtabs %}</p>

<h2>Solution</h2>

<p>A programming error lies in the fact that <code>crypto.randomUUID</code> (the function) is used as the <code>secret</code>, instead of calling the function.</p>

<p>```javascript
const crypto = require('crypto');</p>

<p>class Database {
  constructor() {
    this.notes = [];
    this.secret = <code>secret-${crypto.randomUUID}</code>;
    console.log(this.secret);
  }
```</p>

<p>Therefore, the secret is actually:</p>

<p>```
secret-function randomUUID(options) {
  if (options !== undefined)
    validateObject(options, 'options');
  const {
    disableEntropyCache = false,
  } = options || {};</p>

<p>validateBoolean(disableEntropyCache, 'options.disableEntropyCache');</p>

<p>return disableEntropyCache ? getUnbufferedUUID() : getBufferedUUID();
}
```</p>

<p>Therefore, we just have to generate the token for <code>id=0</code>, which is the same every time.</p>

<p><code>java
console.log(db.generateToken(0));
</code></p>

<p>The flag is <code>dice{1_d00r_y0u_d00r_w3_a11_d00r_f0r_1_d00r}</code></p>
