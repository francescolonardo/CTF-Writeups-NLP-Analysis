This challenge had the same premise as [Undocumented js-api](undocumented-js-api.md). This time, the JavaScript source is different (and slightly more complex).

The important part is, once again, the message event handler. Just like the previous challenge, we had to use a subdomain takeover to serve an exploit page from a `.jsapi.tech` subdomain.

One interesting feature in this version of the challenge is that we can "preview" our HTML _without saving it_. Everything is still sanitized through DOMPurify.

In the preview feature, we can insert sanitized HTML without changing `this.noteData`. When using the search feature, the original `this.noteData` is the one being searched for our input text.

The search feature checks for `window.enable_experimental_features`, which is a property that doesn't exist... or does it?

DOMPurify doesn't protect against DOM clobbering, so we can pollute this property by inserting the following HTML through the preview feature.

### Unintended Solution

When the text that we are searching is found in the victim's note, a new `<div>` is rendered with the search results (`#note-text-highlight-wrapper` has its `hidden` class removed).

For instance, the following shows a correct search (where the searched content is a substring of the flag).

And the following shows an incorrect search, where no matches are found. Notice how the extra `<div>` in the correct search was sufficient to push the previewed content out of the viewport.

We can make use of [image lazy loading](https://web.dev/browser-level-image-lazy-loading/) to only load an image if it is within the browser viewport. This way, we are able to tell if the results section was rendered.

If we do _not_ receive a request for a particular character, that means that the results section was rendered, and therefore the search was a correct guess.

The following script implements this exploit.

### Intended Solution

The intended solution was to use the [PerformanceLongTaskTiming API](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) to identify if the search was taking more than 50ms.

It turns out, however, any timing attack with `performance.now()` would have worked as well.

Because the JavaScript event loop is single-threaded, we just need to use `setTimeout` to temporarily pass control to the next thing in the callback queue (which is the message handler taking care of the `search` request), then find out how long it took for control to be passed _back_ to our exploit script.

Although the `setTimeout` is only for 1ms, it takes much longer in reality for execution to resume because the expensive `search` function blocks the event loop. By measuring this discrepancy, we can find out if our guess was correct.
