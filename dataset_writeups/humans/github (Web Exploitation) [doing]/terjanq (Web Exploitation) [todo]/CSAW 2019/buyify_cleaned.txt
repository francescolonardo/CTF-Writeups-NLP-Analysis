We are provided with a simple [website] where we can:
- visit `flag store` and buy `flag` there
- create new store
- update created store description
- create items in created store

After playing around with the webiste I noticed an interesting template in *update store description* page

Given that, I suspected the problem to be [Server-side Template Injection] related.

The first thing to try with templates is always `{{7*7}}`. 
That can quickly confirm whether we hit the mentioned Template Injection or not. When doing so a wild error appeared:

From reading through the error, we can see that the library responsible for compiling that template is [handlebars]. Quick research led me to a great article [Handlebars template injection and RCE in a Shopify app] about a vulnerability in that library. The mentioned in there vulnerability was unfortunately patched but all the details, starting with the challenge name, clearly point to *bypassing* the fix.

However, there was also a hint included

> *HINT: Templates are a prototype for fun and also, don't worry, you don't need rce*

that suggests that there is no need for searching for another critical vulnerability in the library. 

In the following sections, I will present a solution split into pieces that are required to understand the problem and omit all the wrong directions I took.

When visiting http://web.chal.csaw.io:1002/store/flag/ we could try to purchase the flag with the following request beside:

After decoding the token which is an encoded [JSON Web Token] we get a `JSON` object:

Unfortunately, we only get `$100` on the start so the purchase will not be completed.

The `id` in the token is created by concatenating `store_name` and the `item_name`. We can see that happening in [server.js]:

The token itself is a `jwt` signed with `store.key` which we can find in [store.js]: 

In the [store.js] we can also notice that the `store` has the following structure:

A very odd thing is that the `key` attribute is not defined here, but we saw earlier that `store.key` was used to encode the token.

In [store.js] we can find a place where `store.key` is actually defined: 

From cryptographic perspective this looks impossible to crack. Let's see when `update_store()` function is called. 

From reading the above function it becomes obvious that `store.key` is defined via `update_store()` and that happens when a new item is created. That will also update all the previous items in the process. This will come in handy very soon.

If we knew the secret key from `store` object we could sign an object `{'id': 'flag.flag', 'price':'1'}` with that key and then by sending a `/checkout` request from [#Purchase-the-flag](#Purchase-the-flag) section, receive the flag. That is because of the following part of the[server.js]:

There are some security checks being done before accessing the flag but the crucial one is in `checkout(req, res)` function.

Basically, to access the flag we must make verify function not to throw an error, i.e. the signature must match the key.

So, I mentioned earlier about this great bug in `Shopify` store that allowed to get an `RCE` and that does not work anymore. The reason why we cannot get the remote code execution using that trick is that any attempt to calling the `constructor` of any object will return `undefined`. Without a `constructor` it is not trivial to iterate over contexts or to evaluate a string. But in the hint, it was said that we do not need to achieve `RCE`.

To solve the challenge we would either want to read the `store.key` or override it with a value known to us. The syntax of [handlebars] is limited but it has [helper functions] that can do some crazy things. To take advantage of [#Store-object](#Store-object) we would ideally want to override the Object prototype and define our own [setter] and [getter] on `key` property so we can either read the key or replace it with controlled by us value. 

In plain `javascript` it could look like:

Since we cannot access any `constructor` property, getting reference to `Object` is a challenging task. But there is another way to define [setter] or [getter]. There are deprecated features like [\_\_defineSetter\_\_] and [\_\_defineGetter\_\_] that still work. These can be called in [handlebars] for example in that payload: `{{this.__proto__.__defineGetter__}}`. I managed to use this and override the prototype with the following payload:

It is equivalent to the `Object.defineProperty` mentioned above. What it does is:
1) Setting a context to the prototype of `[object]` and aliasing it to `|o|` via [#with] helper.
2) Calling [\_\_defineSetter\_\_] and [\_\_defineGetter\_\_] on `Object.prototype` with `key` as attribute and `this.toString()` as a callback that override [setter] and [getter]. 
3) After that, accessing `[object].key` on newly created objects shall now return `[object Object]` as a string and it cannot be overriden using `[object].key = ...` because we overrode a setter function. 

So now, the last missing piece is to forge a valid `token` with `[object Object]` as a key and `flag.flag` as an id.

Then using it to purchase the flag for `$1` in our store. 

I automated the process with [solve.py] where I briefly described each step. By executing the exploit I got the flag.