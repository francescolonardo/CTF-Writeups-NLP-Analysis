Going to the index page, we are told that this is yet another SQL injection challenge ™️

However, once we start fuzzing some classic SQLi payloads, we would quickly find that the challenge is not so simple. We are instead greeted with a 403 Forbidden page.

One would notice, however, that the `Server` header is now present. We know that the application is put behind an AWS ELB, so we could guess that the AWS WAF is the one blocking our SQLi requests.

### Dangerous Defaults

A quick look at the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields.html) would sound some alarm bells with these red warning boxes:

Wait... this can't be... can it? Surely there must be some other default rule that says that anything longer than 8kB is blocked without even being passed to the WAF... right?

Well, a simple test showed otherwise. Even a trivial payload like `aaa...[8kB]...aaa' or '1` would succeed. We could therefore dump the database using SQLi payloads longer than 8kB!

I was too lazy to do this manually, so I just wrote a simple SQLMap tamper script that prepends 8192 `"a"`s to the payload.

Dumping the database with SQLMap then gave the flag

### Is There a Mitigation?

Looking at the [managed rule groups changelog](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-changelog.html), it seems the `SizeRestrictions_BODY` rule in the Core Rule Set was recently changed to block payloads larger than 8kB instead of 10kB, likely due to [this blog post](https://osamaelnaggar.com/blog/aws\_waf\_dangerous\_defaults/).

If we use the above rule together with SQLi detection, this would be mitigated. But this is not a default rule added out of the box, and a developer would likely not be aware that one has to use it in order to make their WAF effective. :thinking:
