In the front-end JavaScript source code, we can see that Meteor is being used to fetch data from a MongoDB backend.

First, let's find all the exposed Meteor methods. We can see that `notes.count`, `notes.add` and `notes.remove` are publically callable methods.

In particular, though, `notes.count` is unauthenticated. Let's start there! From the above code, it seems like `notes.count` applies some kind of filter and the backend server returns the number of notes that pass the filter.

In Burp Suite, I found that this method was being called through websockets. Upon connecting to the webpage, this was being sent to the server: 

`["{\"msg\":\"method\",\"method\":\"notes.count\",\"params\":[{\"body\":{\"$ne\":\"\"}}],\"id\":\"1\"}"]`

The `$ne` filter checks whether the body of the notes is not equal to an empty string. After a bit of fiddling, I found that `$regex` was accepted too. This allows us to specify a regex pattern for the note contents. To verify, I checked that the following only returned one result:

`["{\"msg\":\"method\",\"method\":\"notes.count\",\"params\":[{\"body\":{\"$regex\":\"flag{.*}\"}}],\"id\":\"1\"}"]`

Here, we are checking for notes that match the regex pattern `flag{.*}`, which is the flag format. The result will be 1, because only one note contains the flag.

We could extend this to bruteforce every character of the flag. By appending each possible character at the end of the flag, we can check which character causes the count to return 1 \(the rest will return 0\).