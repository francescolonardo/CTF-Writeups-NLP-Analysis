### OTP Verification

After we first register an account, we will quickly find that we won't be able to log in to our registered account yet - we need to verify our OTP first.

Let's take a look at how the verification is performed.

Hmm... no dice. Looks like the verification logic itself is sound, so we have to find our OTP through some other vulnerability. Since the rest of the functions require us to be authenticated, we are only left with the `/search` URL.

### Bypassing SQL Injection Protection

Sure enough, the MySQL query builder function looks like it's vulnerable to SQL injection. If we are able to control the `username` being substituted, we can escape out of the string.

The only problem is that spaces, `AND`, and `OR` are replaced with empty strings in our query.

To bypass this, we make use of the fact that in MySQL, comments (`/**/`) can serve as spaces, and the above replacement is non-recursive.

Our payload would then be:

Which will be translated into the MySQL query:

where `GUESS` can be varied to bruteforce the character at `POSITION` (and `socengexp` is my username :smile:)

Here's the script to find our OTP, though a custom SQLMap tamper script would probably work too.

With the OTP we found, we can verify and log in to the application.&#x20;

### Bypassing SSRF Protection

This gives us access to `/cornelia`, which performs a GET request to a URL of our choice.

This looks like it might be vulnerable to SSRF, but the following validation prevents us from specifying `localhost` or `127.0.0.1` etc. directly.

That's fine, since the server follows redirects. By redirecting to `localhost:8081/flag`, we can access the flag.

The flag is
