
description: Browser-based Port Scan + Puppeteer Remote Debugging
Wild DevTools
Challenge
{% hint style="info" %}
Web, 10 Solves
{% endhint %}

One of our hackers stole the source code for a top-secret screenshot service. However, he wasn't able to get the flag.
He kept saying it was impossible. That made me think of you, think you can do it?

{% file src="../../.gitbook/assets/wild-devtools-source.zip" %}
Solution
The goal was to read the flag file, which is written to disk when the server starts up.
```javascript
async function main() {
    const port = 8080;
    const server = express();
// write flag to disk
fs.writeFileSync('/tmp/flag.txt', process.env.FLAG);

...

```
This was essentially a "screenshotter" service that allows us to enter arbitrary URLs to be rendered by a Chromium instance.
The validateScreenshotRequest middleware makes sure that we specify a HTTP(S) URL, so the file:// protocol will not work here.
```javascript
function validateScreenshotRequest(req, res, next) {
    if (!req.query.url || typeof req.query.url !== 'string') {
        return res.status(400).json({ error: 'url is required' });
    }
try {
    let url = new URL(req.query.url);
    if (url.protocol !== 'http:' && url.protocol !== 'https:') {
        return res.status(400).json({ error: 'invalid protocol' });
    }
} catch {
    return res.status(400).json({ error: 'invalid URL' });
}

next();

}
```
Of particular interest, however, is the way that the browser instance is launched.
```javascript
async function getBrowserWithTimeout(seconds) {
    log('launching browser...');
    let browser = null;
for (let i = 0; i < 5; i++) {
    if (browser !== null) {
        continue;
    }
    try {
        browser = await puppeteer.launch({
            timeout: 5000,
            headless: true,
            dumpio: true,
            ignoreDefaultArgs: [
                '--disable-popup-blocking'
            ],
            args: [
                '--no-sandbox',
                '--ignore-certificate-errors',
                '--disable-setuid-sandbox',
                '--disable-accelerated-2d-canvas',
                '--disable-gpu',
                '--proxy-server=smokescreen:4750',
                `--remote-debugging-port=${getRandomPort()}`
            ]
        });
    } catch (err) {
        browser = null;
        log(err);
    }
}

...

```
A remote debugging port is exposed. This normally allows us to send commands to the browser through the DevTools protocol. In this case, however, we can see that the debugging port is randomised.
javascript
export default function () {
    let port = 9000 + Math.floor(Math.random() * 2000);
    return port;
}

Leaking the Debugging Port
We had a range of 2000 possible ports to scan, but the browser will only live for 30 seconds before it was closed.
javascript
setTimeout(async () => {
    try {
        await browser.close();
    } catch (err) {
        log('browser.close() failed:', err.message);
    }
}, seconds * 1000);

If we could leak the debugging port, then we could communicate with the Chromium instance to open a new page with the file:///tmp/flag URL, and read its contents. 
There are many ways to do this, but my first reaction was to do it through a common XS-Leaks technique. The idea is that if the port is closed, trying to load it as a resource would yield a Connection Refused error, triggering the onerror event handler. Otherwise, the onload event handler would be fired instead on successful loading.
```markup


