Title: Super Serial

Going to the robot file, we notice that `admin.phps` is disallowed. This indicates that the phps extension is enabled within the php configuration for this webserver. Files with the phps extension contain php code but instead of running when they are accessed, they return an HTML representation of the literal php code. "phps" stands for "PHP source".
We can access `index.phps` code, that points us in the direction of `authentication.php`. Looking at the code, it points us in the direction of `cookie.php`. We look at its code.
OK. A few things to note here. The `cookie.php` file is included in every page. In it we have a code segment that will deserialize our cookie and print the object when an error occurs: `("Deserialization error. ".$perm)`.
I start thinking we are in the context of a deserialization vulnerability.
We can store any object in the cookie and it will be unserialized. One option is to exploit the `__construct` function, since this is ran immediately when the object is created. However, in both the access_log and permissions classes, there does not appear to be a valid gadget chain.
Conveniently, the `access_log` class in `authentication.php` has the `__toString()` method, that is one of the PHP magic methods that override PHP's default behaviour. This method is called when the object is converted to a string. So if we could get the above `$perm` variable to be our custom `access_log` object, we could achieve arbitrary file read on the target system.
To do this, we simply serialize our custom `access_log` object, where we set `log_file` to `../flag`. The php serialized `access_log` object looks like this: ```O:10:"access_log":1:{s:8:"log_file";s:7:"../flag";}```. Fore more details about this syntax, we can search for "exploiting php deserialization" on Google.
Let's encode that to base64 and url encode it using CyberChef.
Now, we can add it as the `login` cookie on our browser and go to `authentication.php`. Note that we need to use `authentication.php` because that is the file where the required `access_log` class is defined. Our custom `access_log('../flag')` object will be deserialized into `$perm`. This will most definitely generate an error because the `access_log` class has no such methods. This will catch the error and concatenate `$perm` to the `"Deserialization error. "` string. In doing so, `$perm` is converted to a string. This invokes the `__toString()` method which reads `../flag`!
