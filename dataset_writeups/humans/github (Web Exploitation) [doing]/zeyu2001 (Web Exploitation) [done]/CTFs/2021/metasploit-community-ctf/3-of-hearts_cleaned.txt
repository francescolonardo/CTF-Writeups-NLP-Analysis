In the `Server` response header, we could see that the Apache Traffic Server (ATS) 7.1.1 was used,

This is vulnerable to CVE-2018-8004, a request smuggling vulnerability, and I came across a nice writeup [here](https://medium.com/@knownsec404team/protocol-layer-attack-http-request-smuggling-cc654535b6f). The relevant patch we are looking at is [here](https://github.com/apache/trafficserver/pull/3231) - a lack of validation for `Content-Length` headers.

In the vulnerable version, even if the `Transfer-Encoding` header exists, the `Content-Length` header is used. This leads to a request smuggling vulnerability if the backend server processes the `Transfer-Encoding` header instead of the `Content-Length` header to decide where the request ends.

It was observed that whenever a request is made to `/save.php`, an entry is appended to a "log file", which contains the cookies and the value of the `X-Access` header.

Assuming that an admin visits the site, we could use a CL-TE request smuggling attack to direct the admin to `/save.php`.

Consider the following payload:

The ATS server processes the `Content-Length` header, and thus forwards the entire payload as a single request to the Nginx backend.&#x20;

However, Nginx sees the `Transfer-Encoding` header and decides that the first request ends early. This is a full, complete request.

This is then followed by a second request, which is _not yet completed._

When the admin visits the site (the third request), his request is appended to the above incomplete request - the second and third request thus are processed as one single request.

Crucially, this request contains the admin's `Cookie` and `X-Access` headers.

In the log file, we can view the cookie:

Then, visit `private.php` to view the flag.
