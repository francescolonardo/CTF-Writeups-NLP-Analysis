### Dumping S3 Bucket

Visiting the webpage, we see the following clues in the HTML source.

Here's what this is referring to - CloudFront is Amazon's CDN and can be configured to use an S3 bucket as its origin. The CloudFront site will then use files on the S3 buckets to serve the static page. But even so, the user could just access the S3 instance directly. The missing step here is to restrict direct access to the S3 bucket except from authenticated requests from CloudFront using Origin Access Identity (OAI).

The S3 bucket in its current state is readable by all authenticated users, so we could simply login to our own AWS account and use the AWS CLI to access the `palindromecloudynekos` bucket.

This gives us the next clue.

As we saw earlier, the passcode is `X-Cat-Header: cats_rule_the_world`. By sending the appropriate request to the API endpoint, we get a set of AWS credentials.

### Enumerating Permissions

It was at this point that I tried different enumeration tools such as [enumerate-iam](https://github.com/andresriancho/enumerate-iam) and [pacu](https://github.com/RhinoSecurityLabs/pacu). Pacu came with a ton of useful modules which came in handy later on.

Here are the results that `enumerate-iam` gave.

Pacu also gave similar results during my initial privileges scan.

### Some Useful Information

By trying each of these privileges one by one, I found some interesting information that would come in handy later.

For instance, `aws iam list-roles` gave a list of roles, some of which looked interesting:

`aws iam list-instance-profiles` also yielded a particularly interesting instance profile, `ec2_agent_instance_profile`.

### Getting lambda\_agent\_development\_role

A few more hours of staring at AWS documentation later, I decided to use Pacu's `whoami` command and surprisingly, there was a ton of useful information that Pacu has stored already.

In particular, we had `lambda:CreateFunction`, `lambda:InvokeFunction` and `iam:PassRole` privileges.&#x20;

The reason these did not show up in `enumerate-iam` is probably because `enumerate-iam` only does a naive bruteforce by attempting to invoke each privilege without any specific format as required in this challenge (e.g. `arn:aws:lambda:ap-southeast-1:051751498533:function:${aws:username}-*`)

At this point we can consult this [great resource](https://github.com/BishopFox/iam-vulnerable/blob/main/README.md) by Bishop Fox that provides a nice table breakdown of different AWS privilege escalation techniques. Our current permissions correspond to technique 15 [here](https://bishopfox.com/blog/privilege-escalation-in-aws), which involves creating a Lambda function that assumes a privileged role, thus executing code with higher privileges.

First, we create a Python script that gives us a reverse shell.

Then we zip this into a zip file like `function.zip`, and create a lambda function adhering to the name format above. Using `--role`, we pass the `lambda_agent_development_role` to this lambda function.

After invoking the lambda function, we get a reverse shell on our listener!

### Getting ec2\_agent\_role

Now that we have access to `lambda_agent_development_role`, let's see how we can leverage our newfound permissions. After enumerating permissions again with our trusty enumeration scripts, we find out that we now have the permission to create EC2 instances.

At this point we need to remember this piece of information given to us early in the challenge, telling us the tags that are required.

Our current permissions now correspond to technique 3 [here](https://bishopfox.com/blog/privilege-escalation-in-aws), involving the `iam:PassRole and ec2:RunInstances` permissions. Essentially, we could pass in an `--iam-instance-profile` to assign a role to the EC2 instance.

But in order to gain access to our newfound privileges we would need a way to gain access to our newly created EC2 instance. In this article, the authors leveraged the assigning of SSH key pairs and gained access through the public IP address of the EC2 instance.

> * The user needs to have some way to SSH into the newly created instance.
>   * In the example below, the user assigns a public SSH key stored in AWS to the instance and the user has access to the matching private key.

In this challenge, however, this method does not seem quite so feasible (in particular, I had a hard time figuring out how to get the public IP of the instance since we only had access to `run-instances` but _not_ `describe-instances`).&#x20;

It turned out there was a way to do this by using idempotency tokens, which allowed us to get updated information on the result of a previous command. As this was not my solution, I won't discuss it in detail.

> Idempotency ensures that an API request completes no more than one time. With an idempotent request, if the original request completes successfully, any subsequent retries complete successfully without performing any further actions. However, the result might contain updated information, such as the current creation status.

After a bit more googling, I came across this [blog post](https://s3cur3.it/home/practicing-aws-security-with-iamvulnerable-part-2) containing a similar scenario as the one we have here. It turns out that the [`user-data`](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) option can be used to execute a script on startup. This is meant to help perform common configuration and setup tasks when provisioning an EC2 instance.

Piecing it all together, we can modify our previous lambda function to spawn an EC2 instance that runs a reverse shell on startup.

And we're in! We now have the `ec2_agent_role`.

### Getting the Flag

Once again, we obtain the credentials through the metadata endpoint and enumerate our privileges. This time, we only really had access to `dynamodb`.

The flag was stored in `flag_db` and easily retrievable using `aws dynamodb scan --table-name flag_db`.
