<h1>Bigspin</h1>

<p><strong>Category</strong>: Web</p>

<p>424 Points</p>

<p>26 Solves</p>

<p><strong>Problem description</strong>:
This app got hacked due to admin and uberadmin directories being open. Was just about to wget -r it, but then they fixed it :( Can you help me get the files again? </p>

<hr />

<p>We are provided with a link to a site. Opening it, it shows a simple HTML page with the following text.</p>

<p><code>
What's it gonna be? Are you an uberadmin, an admin, a user, or (most likely) just a pleb? 
</code></p>

<p>The <code>uberadmin</code>, <code>admin</code>, <code>user</code> and <code>pleb</code> are hyperlinks to their respective directories. The <code>uberadmin</code> and <code>user</code> directories returned 403 forbidden while <code>admin</code> returned 404. The <code>pleb</code> directory returned the same page example.com domain</p>

<p>Appending anything after the <code>pleb</code> directory (like <code>/pleb/whatever</code>) also returned the same page, acting just like example.com, weird huh?</p>

<p>After some more recon, I noticed changing <code>/pleb</code> to <code>/pleb.</code> worked the same way as before, <code>/pleb~</code> returned a 404 while <code>/pleb{anythingElse}</code> retuslted in a 502.</p>

<p>The <code>pleb</code> and <code>pleb.</code> are working just like domain TLDs, any time we visit <code>example.com</code>, we are actually sending a DNS request to <code>example.com.</code> because a fully qualified domain needs to have a trailing dot at the end. That's why visiting <code>example.com</code> and <code>example.com.</code> produce the same result.</p>

<p>To confirm my supicions, I set up a wildcard DNS listener at dnsbin.zhack.ca and sent a request to <code>/pleb.mysub.dnsbin.zhack.ca</code> and sure enough, I received a DNS query for example.com. </p>

<p>So the pattern here is that the server is actually forwarding our request from <code>/pleb{anything}</code> to <code>example.com{anyhing}</code>.</p>

<p>In the exploitation process, I used nip.io to provide extensively awesome wildcard DNS service. Sending a request to <code>/pleb.127.0.0.1.nip.io</code> returned the localhost, which was the same index page as before. But this time, I could visit the <code>user</code> directory.</p>

<p>```
Index of /user/</p>

<p>../
nginx.cÃ¶nf                                        05-Apr-2019 11:51                1253
```
Well, looks like there a file which seems like nginx.conf but with a couple of UTF-8 characters.</p>

<p>For some reason, I wasn't able to download it, so I set up a listener on my VPS and realized that the <code>/pleb</code> proxy wasn't forwarding non-ASCII chars. </p>

<p>It basically stopped at the occurance of the first non-ASCII char, but percents (%) were allowed. Since nginx would urldecode whatever we send before forwarding them, what if double URL encode (encode %ff as %25ff, so when nginx decodes, it becomes %ff and gets forwaded). This trick worked and I was able to download the nginx.conf.</p>

<p>```
    server {
        listen 80;</p>

<pre><code>    location / {
        root /var/www/html/public;
        try_files $uri $uri/index.html $uri/ =404;
    }

    location /user {
        allow 127.0.0.1;
        deny all;
        autoindex on;
        root /var/www/html/;
    }

    location /admin {
        internal;
        autoindex on;
        alias /var/www/html/admin/;
    }

    location /uberadmin {
        allow 0.13.3.7;
        deny all;
        autoindex on;
        alias /var/www/html/uberadmin/;
    }

    location ~ /pleb([/a-zA-Z0-9.:%]+) {
        proxy_pass   http://example.com$1;
    }

    access_log /dev/stdout;
    error_log /dev/stdout;
}
</code></pre>

<p>}
```</p>

<p>So it's using proxypass to forward our requests. The <code>/admin</code> directory is internal only whereas the <code>/uberadmin</code> will only shown if our IP is 0.13.3.7. </p>

<p>The internal directive here means that only the requests sent internally (rewritten by nginx) will be allowed to access that. But there are no rewrite rules in this config...</p>

<p>After some googling, I came across the <a href="https://kovyrin.net/2006/11/01/nginx-x-accel-redirect-php-rails/">X-Accel-Redirect</a> which apparently if returned by the backend server/proxy_pass will allow us to access the internaal directive because it acts as a rewrite rule.</p>

<p>So I set up a quick php script with the following</p>

<p><code>
&lt;?php header("X-Accel-Redirect: /admin/"); ?&gt;
</code></p>

<p>This showed me the contents of /admin/ when I visited <code>/pleb.my.ip.nip.io</code>. There was a flag.txt in there but it was fakenews and just directed us towards <code>/useradmin</code>..</p>

<p>So how do we access <code>/uberadmin</code>? If you are current on your security news, you must've heard about the <a href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf">Off-by-Slash</a> bug in many nginx configurations.
<code>
        location /admin {
            internal;
            autoindex on;
            alias /var/www/html/admin/;
        }
</code></p>

<p>Basically if we're using the alias directive with a location directive, nginx would directly concat them them together. In this case, a request to <code>/admin../uberadmin/</code> would actually open the uberadmin directory.</p>

<p>This was my final payload</p>

<p><code>
&lt;?php header("X-Accel-Redirect: /admin../uberadmin/flag.txt"); ?&gt;
</code></p>

<p>Overall, this was an awesome challenge and I loved every part of it</p>
