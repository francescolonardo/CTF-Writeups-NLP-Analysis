`/readfile` is vulnerable to length extension attack, so read source file of web app and exploiting the node-deserialization attack

So from webpage source code we see that there are total 3 functionalities of the web app: registration, login, readfile.

After login we get token using that token to readfile we can read the `68696e742e747874` (hex decode as hint.txt)

[Command: Send a POST request to log in and receive a token]
[Output: JSON object with the token]

[Command: Send a POST request with the token and filename to read the file]
[Output: JSON object with the file data containing a hint]
"Implementing MAC and adding cheese to it and cheese length is less than 30 chars".
This suggest it to length extension attack with password length less than 30 chars given

Web app is running on nodejs so `package.json` must be present on the system

We get the contents of package.json at `22` so password length is `22`
[Python script: Use hashpumpy to generate the modified hash and input, then send a POST request to read package.json]
[Response: Contents of package.json]
From the response we can also read the `app.js` which leads to the file `/models/User.js` 

`node-serialize` is used in User.js for creating the user specific `token`
[JavaScript code: encrypter and decrypter functions for user tokens]

A little bit of google search for `node-serialize` leads to that the npm package is vulnerable to node-deserialization rce attack 

[JavaScript code: readfile route implementation]

And from `readfile` route we can check that the app first verifies the token and then forwards it to `decrypter` function which calls the `unserialize` function which can give rce

So for that to work we need to sign our payload with valid signature, so the AUTH_SECRET is comming from .env file which we can easily read.

Solution Script
[Python script: Create a payload for RCE and send it to the server using the provided token and HMAC signature]

This script creates an RCE payload and sends it to the server using the provided token and HMAC signature. It then prints the response received from the server.
