In this challenge, we can create notes and search for them.

In particular, the search function is rather interesting. We can see that if a note is found with the given query, then a server-side 302 redirect is issued to `/view`.

Since the redirect is only issued if the query is part of the note, we can use the redirect as an oracle to detect whether our flag is correct and bruteforce the flag.

Just to be sure, we can also check that the `SameSite` attribute of the cookies is set to `None`, enabling cross-origin requests to carry the victim's cookies.

I read [some slides](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63e29d5a06\_0\_0) on this exact scenario a while back. The attack relies on the fact that the Fetch API has a maximum redirect count of 20. If the redirect count exceeds this value, a network error is returned.

Therefore, we can leak whether a redirect occurred in the cross-origin request by catching the network error.

On the client, we will make a request to our own attacker server. This server should redirect to itself 19 times, before redirecting to the actual target URL.

If the target URL then performs a further 302 redirect, then the redirect limit is reached - we can catch the error and exfiltrate the flag so far.

On our server, we run the following PHP script to redirect to ourself 19 times, before redirecting to the target URL.

Here's the result! Thankfully the admin bot waits long enough for us to slowly bruteforce the flag letter by letter.
