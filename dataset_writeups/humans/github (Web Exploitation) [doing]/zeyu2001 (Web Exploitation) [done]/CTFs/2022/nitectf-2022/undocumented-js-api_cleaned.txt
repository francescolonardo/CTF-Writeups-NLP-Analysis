### Initial Analysis

The challenge was hosted at `https://chall1.jsapi.tech`, which we can easily tell is a GitHub pages site.

The page provides an interface to write and save notes in HTML. This is implemented by the `script.js` script.

Analyzing the JavaScript source, we see that a [message event](https://developer.mozilla.org/en-US/docs/Web/API/Window/message\_event) handler is only added to the window if several conditions are met.

This is a very long line of code that

* checks if the `enableapi` query parameter is set to `true`
* checks if the `recv` query parameter is a subdomain of `jsapi.tech`
* checks if the window is framed or opened by another window
* sets `window.a` to the `recv` query parameter
* finally, adds the message event handler

Next, we see that `parseUrl` is called on `event.origin`. In order to pass this check, the origin that our `postMessage` call comes from must be a subdomain of `jsapi.tech`.

### Subdomain Takeover

This part is similar to [Yana from UIUCTF 2021](../../2021/uiuctf-2021/yana.md). Because a wildcard configuration is used (i.e. `*.jsapi.tech`), _any_ `.jsapi.tech` subdomain would point to `sohomdatta1.github.io`.

To confirm this, we just have to use `dig` on any `.jsapi.tech` subdomain that currently does not have an associated GitHub pages site.

From GitHub's [documentation](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site), users are explicitly warned against using wildcard DNS records to prevent subdomain takeovers.

When requesting for `asdf.jsapi.tech`, GitHub tries to find a matching repository with a `CNAME` file containing `asdf.jsapi.tech`. Because no such repository currently exists, _anyone_ can create a new repository with this `CNAME` file and serve a GitHub pages site at `asdf.jsapi.tech`.

### Aside: Stealing Exploits

I'm not sure if the challenge initially took this into account, but services like [crt.sh](https://crt.sh/) allow users to search for certificates issued by major certificate authorities (CAs) by scraping their transparency logs. Using crt.sh, I was able to find all the subdomains created by other players attempting the challenge.

At the time of solving, there were two other solvers. Making an educated guess landed me on `squ1rrel`'s exploit page, `squ1rrel.jsapi.tech`, where I pretty much found the flag and a working PoC. For completeness, I'll explain the exploit anyway :)

### CSS Injection

Taking a closer look at the JavaScript source, we see that when a note is saved and `self.set()` is called, the note's contents go into the `data-last` attribute of the `#note-text-area` element.

Additionally, DOMPurify v2.3.0 is used to sanitize our note, with `link` and `style` tags being explicitly allowed.

We can send a `postMessage` starting with `NOTE_APP_SET_REQUEST` to save a note, allowing us to insert DOMPurify-sanitized HTML into the child iframe.

The Content Security Policy (CSP) is quite restrictive, but one part stands out - stylesheets can be loaded from `*.jsapi.tech`, allowing us to load a CSS file from our exploit domain.

By the way, because a tag like `<link>` will get [removed](https://github.com/cure53/DOMPurify/issues/257) by the browser if it's the first thing in the HTML, passing `<link rel="stylesheet" href="...">` to DOMPurify will just return an empty string. However, adding anything _before_ the `<link>` tag fixes this behaviour. For example, I will use `asdf<link rel="stylesheet" href="...">`.

Since we are interested in the victim's saved note, we can exfiltrate the `data-last` attribute of the `#note-text-area` element using [CSS attribute selectors](https://www.w3schools.com/css/css\_attribute\_selectors.asp).

For instance, the URL specified in the `background` of the following CSS rule is only fetched if the `data-last` attribute starts with the string `nite{a`.

This can be extended to bruteforce all possible characters in each position of the flag, with each character having a background URL corresponding to the guessed flag.

To generate the CSS I used the following script.

Our exploit page will simply load the challenge page as an `iframe`, wait for the API to be loaded, then send a `postMessage` linking the CSS we created above to the target page. This is added to a GitHub repository together with the CSS, and deployed to GitHub pages under a `.jsapi.tech` subdomain.

Exfiltrating each character is slightly annoying, as it involves redeploying our exploit GitHub page with the updated CSS.
