### Authentication Logic

The end-goal, of course, is to get to `/flag`, but there is a `role` attribute in the JWT token that we must change to `admin` in order to pass the `IsAdmin` check.

Let's look at the registration and login flow. This time, it seems like `user.Otp` is actually the JWT key - each user's key would be different!

The JWT key is then used to sign the token when we log in.

What's interesting, though, is that there is a caching mechanism that stores each user's JWT key in a Redis cache after logging in. Presumably, in real-world applications such a caching mechanism would save time in performing database lookups each time JWT authentication occurs.

Sidenote: the key is only stored for two seconds, so we have to be quick here!

### SSRF and Obtaining Cached Secrets

There exists a non-admin path, `/sakura` that does allow us to interact with the Redis cache.

However, we could see in the cache-fetching mechanism that the client URL is validated to be `127.0.0.1`.

That leaves us with `/rin`. The handler logic presents us with the all-too-familiar SSRF code:

Again, the client IP is checked. But this time, the logic is slightly different. Instead of using `remoteaddr.Parse().IP(r)`, the server is directly looking at the `X-Forwarded-For` header!

By adding `X-Forwarded-For: 127.0.0.1`, we can access this function and perform an SSRF to the `/sakura` endpoint.

As mentioned earlier, the cached secret only exists for 2 seconds after logging in, so we must make the above request right after logging in.

### Gaining the Admin Role

When we have the JWT secret, we could essentially craft any JWT attributes we want.

Using [https://jwt.io/](https://jwt.io) (or any JWT-signing library), supply the JWT secret and change the `role` to `admin`. We now have a new JWT token with an admin role.

Using this new JWT token, simply make a request to `/flag` to get the flag!

The flag is