In this challenge, we were allowed to send an assembly source file that would be assembled with `as`. There are a number of filters that were being applied to our input.

The assembled library is then linked against `main`. A `libflag.so` is also compiled with `flag` defined, allowing it to have the `win()` function.

### Unintended Solution

My unintended solution was to simply tackle the challenge the way it was presented, and evade the filters.

Let's first assume that the filters weren't there. Our goal would be to export a `win` function in our shared library, which is run by `main`. The following shellcode spawns a `/bin/sh` shell.

The first challenge we face is that we cannot have any of the characters in `"/bi/sh"`.

This can be evaded in our instructions by simply using uppercased code (which the assembler accepts), but dealing with the `win` label itself is a bit more tricky. We can't just use `WIN` since that would export a different symbol than the lowercased `win` we need.

We ended up creating the `win` label using `.set`, which expects a symbol name that can be a quoted value. To set the correct address, we use `.` which means the current position.

> `.set` symbol, expression
>
> The `.set` directive assigns the value of expression to symbol. Expression can be any legal expression that evaluates to a numerical value.

Great! This cursed code actually works, and linking it against `main` spawns a shell when running `main`.

The final piece of the puzzle is to get rid of all digits `0` to `5`, since they correspond to the ASCII codes `\x30` to `\x35`.

Since the `MOV` operands are expressions, we could make use of mathematical operations to arrive at the number we need. For instance:

And that was just what we needed to complete the shellcode!

Popping this into the challenge gives us a shell.

### Intended Solution

The `libflag.so` was there for a reason! Notice that since `os.system()` does not raise an exception if the executed commands error out, we could just write to the `libyour_input.so` directly without ever writing assembly code.

This meant that we could write a [linker script](https://users.informatik.haw-hamburg.de/\~krabat/FH-Labor/gnupro/5\_GNUPro\_Utilities/c\_Using\_LD/ldLinker\_scripts.html) that just links `libflag.so`.

