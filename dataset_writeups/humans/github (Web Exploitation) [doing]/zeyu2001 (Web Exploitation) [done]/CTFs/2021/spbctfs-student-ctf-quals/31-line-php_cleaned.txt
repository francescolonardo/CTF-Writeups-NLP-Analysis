Here's the challenge source code:

### XXE Injection

We can quite clearly see that this must have something to do with XML parsing. One part of the code stood out in particular:

The comments seem reasonable. Does this mean that there is no XXE here?

It turns out that this part was inspired by a [WordPress bug](https://blog.sonarsource.com/wordpress-xxe-security-vulnerability) a while back this year. While the above justification is correct, the nuance lies in how `loadXML()` is called.

It turns out that the `LIBXML_NOENT` flag actually _enables_ entity substitution - the flag means that no entities will be left in the result, i.e. external entities will be fetched and substituted.

So, surprisingly, we _do_ have an XXE here. Here's an LFI payload:

### PHP Code Injection

I started searching for flag files but had no luck. After asking the organizers, they confirmed that I must get an RCE somehow.

This got me looking back at the source code. Note that we have a remote file upload here - the uploaded file is at `/var/www/html/upload/$id/$name` and we have access to this file through the web server (the web root is `/var/www/html`). The only caveat is that the file is deleted as soon as the XML parsing is done.

This still allows us to request the file _while_ the XML parsing is being performed. If we upload a PHP file, we can request that file again within the XML and use `php://filter/` to reflect the output into the `<user>` tag.

Using the `phpinfo()` output, we can see the `disable_functions` configuration.

As we can see, all of the functions that can give us a shell command execution are disabled.

### disable\_functions Bypass

The challenge hinted at a zero-day being needed for the last step.

A recent (published just 5 days ago) [PoC](https://github.com/mm0r1/exploits/tree/master/php-filter-bypass) allowed us to bypass `disable_functions` on all PHP versions.

This allowed us to get shell RCE and run the `/readflag` binary to read the flag.