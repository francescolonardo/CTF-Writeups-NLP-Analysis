We can see the dependencies in package.json:

A quick search tells us that `jsonwebtoken` 3.2.2 is vulnerable to an authentication bypass vulnerability.

And we can see that in the response for `/localization-file`, the JWT token is checked and the language is set according to the token value.

JWT tokens are essentially encoded JSON data. However, normally we cannot tamper the data because there is a signature that is verified at the server-side.

However, in this particular exploit, as long as we are able to get hold of the public key, we can trick the server into thinking that the received public key is actually an HMAC secret key. Since we would know the public key, we would be able to generate a valid private key!

How do we get the key? Well, we know that the key file is in the `__dirname` directory.

In the POST handler for `/localization-language`, we are able to control the `language` parameter to make the server generate a JWT token with the corresponding language in the `language` field.

Then, in the GET handler for `/localisation-file`, the server would send us the file at `<__dirname>/<language>`. Hence, we are able to read arbitrary files.

However, since we have to pass the following regex:

we cannot read `flag.txt` or `key.priv`.

Let's test out this theory. I sent a POST request to the `/localization-language` endpoint, with the JSON data:

This sets the `"language"` parameter to `"key"` in the JWT token.

Then, let's send a GET request to `/localisation-file` to get the key file.

We can sign the token using the public key, then send it to the server. Although the server expects an RSA public key, because of the vulnerability mentioned earier, it thinks that this is an HMAC private key.

Since the private key was generated from the server's public key, it is definitely valid and the server would accept it.

Here's the script that would generate the JWT payload:

Note that you'll have to downgrade `jsonwebtoken` to version 3.2.2 to test whether the exploit works.

The token is successfully verified, which means that our payload worked. We have changed the `language` parameter to `flag.txt`.

Plugging in this token value to our `lion-token` cookie, we can read `flag.txt`.

