<hr />

<h2>description: MD5 collisions</h2>

<h1>It Is My Birthday (100)</h1>

<h2>Problem</h2>

<p>I sent out 2 invitations to all of my friends for my birthday! I'll know if they get stolen because the two invites look similar, and they even have the same md5 hash, but they are slightly different! You wouldn't believe how long it took me to find a collision. Anyway, see if you're invited by submitting 2 PDFs to my website.</p>

<p>{% embed url="http://mercury.picoctf.net:50970/" %}</p>

<h2>Solution</h2>

<p>It is now trivial to generate an MD5 collision of two images / PDF files.</p>

<p>Take any two PDFs of different contents, we can make them have the same MD5 hash.</p>

<p>BTW, there is a size limit so choose small PDFs.</p>

<p>```python
import os
import sys
import hashlib</p>

<p>def EnclosedString(d, starts, ends):
  off = d.find(starts) + len(starts)
  return d[off:d.find(ends, off)]</p>

<p>def getCount(d):
  s = EnclosedString(d, "/Count ", "/")
  count = int(s)
  return count</p>

<p>def procreate(l): # :p
  return " 0 R ".join(l) + " 0 R"</p>

<p>if len(sys.argv) == 1:
  print("PDF MD5 collider")
  print("Usage: pdf.py <file1.pdf> <file2.pdf>")
  sys.exit()</p>

<p>os.system('mutool merge -o first.pdf %s' % sys.argv[1])
os.system('mutool merge -o second.pdf %s' % sys.argv[2])
os.system('mutool merge -o merged.pdf dummy.pdf %s %s' % (sys.argv[1], sys.argv[2]))</p>

<p>with open("first.pdf", "rb") as f:
  d1 = f.read()</p>

<p>with open("second.pdf", "rb") as f:
  d2 = f.read()</p>

<p>with open("merged.pdf", "rb") as f:
  dm = f.read()</p>

<p>COUNT1 = getCount(d1)
COUNT2 = getCount(d2)</p>

<p>kids = EnclosedString(dm, "/Kids[", "]")</p>

<h1>we skip the first dummy, and the last " 0 R" string</h1>

<p>pages = kids[:-4].split(" 0 R ")[1:]</p>

<p>template = """%%PDF-1.4
1 0 obj
&lt;&lt;
  /Type /Catalog
  %% for alignements (comments will be removed by merging or cleaning)
  /MD5<em>is</em>_ /REALLY<em>dead</em>now__
  /Pages 2 0 R
  %% to make sure we don't get rid of the other pages when garbage collecting
  /Fakes 3 0 R
  %% placeholder for UniColl collision blocks
  /0123456789ABCDEF0123456789ABCDEF012
  /0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0</p>

<blockquote>
  <p>&gt;
  endobj
  2 0 obj
  &lt;</Type/Pages/Count %(COUNT2)i/Kids[%(KIDS2)s]&gt;&gt;
  endobj 
  3 0 obj
  &lt;</Type/Pages/Count %(COUNT1)i/Kids[%(KIDS1)s]&gt;&gt;
  endobj
  4 0 obj %% overwritten - was a fake page to fool merging
  &lt;&lt; &gt;&gt;
  endobj
  """</p>
</blockquote>

<p>KIDS1 = procreate(pages[:getCount(d1)])</p>

<p>KIDS2 = procreate(pages[getCount(d1):])</p>

<p>with open("hacked.pdf", "wb") as f:
  f.write(template % locals())
  # adjust parents for the first set of pages
  f.write(dm[dm.find("5 0 obj"):].replace("/Parent 2 0 R", "/Parent 3 0 R", COUNT1))</p>

<h1>let's adjust offsets - -g to get rid of object 4 by garbage collecting</h1>

<h1>(yes, errors will appear)</h1>

<p>print
print "KEEP CALM and IGNORE THE NEXT ERRORS"
os.system('mutool clean -gggg hacked.pdf cleaned.pdf')</p>

<p>with open("cleaned.pdf", "rb") as f:
  cleaned = f.read()</p>

<h1>some mutool versions do different stuff :(</h1>

<p>cleaned = cleaned.replace(
  " 65536 f \n0000000016 00000 n \n",
  " 65536 f \n0000000018 00000 n \n",
  1)</p>

<p>with open("pdf1.bin", "rb") as f:
  prefix1 = f.read()</p>

<p>with open("pdf2.bin", "rb") as f:
  prefix2 = f.read()</p>

<p>file1 = prefix1 + "\n" + cleaned[192:]
file2 = prefix2 + "\n" + cleaned[192:]</p>

<p>with open("collision1.pdf", "wb") as f:
  f.write(file1)</p>

<p>with open("collision2.pdf", "wb") as f:
  f.write(file2)</p>

<p>os.remove('first.pdf')
os.remove('second.pdf')
os.remove('merged.pdf')
os.remove('hacked.pdf')
os.remove('cleaned.pdf')</p>

<p>md5 = hashlib.md5(file1).hexdigest()</p>

<p>assert md5 == hashlib.md5(file2).hexdigest()</p>

<p>print
os.system('mutool info -X collision1.pdf')
print
print
os.system('mutool info -X collision2.pdf')</p>

<p>print
print "MD5: %s" % md5
print "Success!"
```</p>

<p>These are the PDFs I generated. Note that they have different content, yet the same MD5.</p>

<p>{% file src="../../.gitbook/assets/collision1.pdf" %}</p>

<p>{% file src="../../.gitbook/assets/collision2.pdf" %}</p>

<p>After we've generated the two colliding PDFs, uploading them to the challenge page unlocks the flag and source code.</p>

<p><img src="../../.gitbook/assets/663d0425c8f64bd08ea2790b0832853e.png" alt="" /></p>

<h2>References</h2>

<ol>
<li><a href="https://github.com/corkami/collisions">https://github.com/corkami/collisions</a></li>
</ol>
