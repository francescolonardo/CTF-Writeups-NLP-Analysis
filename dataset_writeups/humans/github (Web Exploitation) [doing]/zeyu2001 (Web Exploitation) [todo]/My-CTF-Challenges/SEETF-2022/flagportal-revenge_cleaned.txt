Conditions that make this possible:

- ATS interprets `"chunked"` as `chunked`
- Puma ignores invalid / unsupported TE values

First, we need to smuggle a request to `/admin` in `flagportal` to perform an SSRF.

Here's how this works.

For ATS:

- ATS interprets `"chunked"` as `chunked`.
- It sees the first two characters of `DELETE`, and interprets `0xDE` as the chunk size.
- Using the padding header, we add enough bytes so that we have `0xDE` bytes when we reach `0: x`.
- The `0: x` line is parsed as the chunk terminator.
- ATS only sees one request, `GET /`.

For Puma:

- Puma ignores the invalid `"chunked"` transfer encoding.
- The content length of the first request is then 0.
- Puma sees two requests, `GET /` and `DELETE /admin`.

By hosting our own server, we can catch the request, including the `Admin-Key`.

This gives us the first flag, `SEE{n0w_g0_s0lv3_th3_n3xt_p4rt_bf38678e8a1749802b381aa0d36889e8}`.

Note that with the above request smuggling method, we won't be able to get the second response from Puma, which is why there are two parts to this challenge. ATS will only show the first response even if we add more requests after the `DELETE` request above.

## 2) Between ATS and Waitress

Conditions that make this possible:

- ATS processes LF as line endings (instead of CRLF)
- Waitress allows LF in chunked extensions

Notice a `\n` is added to the chunk extension. Since ATS processes the LF as the end-of-line, it sees the following:

The second request is encapsulated in the chunked content of the first request.

Waitress, on the other hand, would see both requests:

`python3 payload.py | nc localhost 8000`

From our receiving server, we can see the flag: `SEE{y4y_r3qu3st_smuggl1ng_1s_fun_e28557a604fb011a89546a7fdb743fe9}`