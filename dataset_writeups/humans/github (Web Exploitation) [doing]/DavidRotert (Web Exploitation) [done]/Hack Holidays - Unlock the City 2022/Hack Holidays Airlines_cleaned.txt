The app represents an airline website. You can
- Sign up with a username, password and airline ticket number
- Then sign in with the username and password
- After that, the flight info will be displayed as a static image (it does not seem to contain any usefull information though at first glance)

## Code Review
After downloading the offered code, I looked into the folder with the app. Some JavaScript files, our (fake) Flag (hurray! No guessing where I neet to search for) and the `package.json`. Ok, so I ran `npm install` and:
[bash command: Install npm packages and display audit report]

Wow, interesting! "Code Execution through IIFE in node-serialize", thats the description from the GitHub [security advisory](https://github.com/advisories/GHSA-q4v7-4rhw-9hqm). Damn, 9.8/10, this must be something. But what the heck is "IIFE"? Okay Google ... or just opening the directly linked Wikipedia article in the advisory saves few clicks.
- https://developer.mozilla.org/en-US/docs/Glossary/IIFE
- https://en.wikipedia.org/wiki/Immediately_invoked_function_expression
After reading the advisory, it is clear thet `unserialize()` is the dangerous function here. Okay, let's remember that for later!

Were were we? Ah yes, review of the code. Ooops, just forgot about that and thought about this IIFE thing. But I have to calm down, you cant run before learning to crawl! So lets open it in VS Code and take a look. **No wait, a better idea!** Let's start the app first and see it in action. So lets try `npm run start` and ... rjagsdfgkafg!!!
[Error log: Permission denied while trying to start the app]

Yikes, it tried to open a priviliged port. Okay then let's try `npm run dev` (oh BTW, you can find scripts executed by the `npm run` command in the `scripts` section of the `package.json`). Ahh, failed again. So I looked into our `index.js` and spotted `const port = process.env.PORT || 80;`. Ah, makes sense, so the command would be `PORT=8080 npm run ...`. Yeahhhh, worked. Oh, and a new file named `storage.db` appeared in our directory. Okay, lets take a look at the app.

Nothing special. So lets go on. Interested in what the database looks like? Me too. So let's see what database engine seemed to be used (guess it was SQLite), open `package.json` again and ... yes it is SQLite as the dependecies say. Ok let's open the file in "DB Browser for SQLite".

Ok, nothing special at first. Although the `id` is weird. Just a ... double as a varchar?? Yeah, let's don't ask why exactly and just continue by reviewing the source now.

Firs't, let's open the `routes folder` which contains:
- index.js
- login.js
- logout.js
- signup.js

Pretty clear what they do, no spaghetti code, yay! So let's open index and ...
[JavaScript code snippet: Import cookie-parser, escape-html, and node-serialize, and set up a route for handling the root path]

Well, this was not what I expected. **RED ALERT!** `unserialize()`. So, the cookie is a serialized JS object which contains the user info. So if we control the cookie => BOOM! Remote Code execution. So let's see if we can execute a malicious payload ...

## Tried soloutions
First, let's try a basic Unserialize without Cookies and all that stuff. Just an additional javascript file with our tests:
[JavaScript code: Test basic serialization and unserialization with a simple payload]

And yeah, this works without a problem. So I can craft the malicious payload (at least I thought so).

The payload needs to read our flag file and return the result as the username, so that we can see it in our website. Remember, it's shown there already as "Welcome xxx".
[JavaScript code: Create a payload that reads the flag file and returns it as a username]

Aaaand ... oh, I made a stupid mistake!

### Problems

#### Payload was executed BEFORE serialization
Yeah, as the heading says, the payload was not serialized there and only executed before serializing. I mean makes sense because the function is executed. So I experimented a bit and looked up documentation.
https://github.com/luin/serialize

Oh, this is how functions can be executed. The function is encoded into the string and then gets executed.

### Solution
[JavaScript code: Craft a serialized payload with a function that reads the flag file and returns it as a username]

We can set the resulting payload shown in the console as our `session` Cookie.

## Attack real target
Attacking the sandbox gave me the flag without any problems

## Better solution (after solving)
[JavaScript code: Create a serialized payload using node-serialize, then modify it and unserialize it to get the flag]

Can serialize the payload istself without hand crafting.
