First thing I was searching for in the given logs, were `HTTP` packets. I quickly noticed `POST requests` to `/login.php` which showed the login credentials.

We see that there are parameters: `username`, `cnonce` and `hash`, but no `password` given. The existence of `hash` argument indicates that  `javascript code` had to be used. And indeed there is [bundle.js] file provided as a response of the `GET /dist/bundle.js` request.

There is another interesting packet `HTTP/1.1 101 Switching Protocols` which indicates that `WebSocket tunnel` has started.

As mentioned earlier I fetched the [bundle.js] and the first thing I have tried was to search for part of the code where `hash` is calculated.

It can be seen, that in order to calculate the `hash` I need to know: `password`, `nonce` and `cnonce`, but from these three only last two are known. By looking at the `function i()` I assume that the function creates a valid, not vulnerable `SHA256` hash.  
As the result of this assumption, I have remembered about `WebSocket protocol` I noticed before and quickly searched for `WebSocket` word in the source code.

After some formatting, I get the injected by an attacker code ([injected.js]) which looks like following:

We can see that communication *client-server* is encoded (`ws.send(encode(message, key))`) using two keys `key` and `key2`. Initially, our key is equal to `MeitamANbcfv2yXDH1RjPTzVqnLYFhE54uJUkdwCgGB36srQ8o9ZK7WxSp` and then after some _shuffling_ it transforms to `key2`. Also, the first message sent via `sockets` is just client's `User-Agent` value, which is also used to transform the `key`. 

`User-Agent` is not a secret, because we can easily fetch it from `HTTP headers`.

> User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36

To confirm that encode function returns the same encoded message as unmasked packet from `Wireshark` I evaluated `encode()` function with `User-Agent` value as the message and `MeitamANbcfv2yXDH1RjPTzVqnLYFhE54uJUkdwCgGB36srQ8o9ZK7WxSp` as the key. As expected, the trial has succeeded.

> WebSocket: T4N8jgYZ5ChvnMJyKyAPCvwAcAmjAhVLt12DeE6SXJQxKsXyv3HL2xKXgASRLHpkDDYRxYQVJt1rNGH6KxyWkkK2gQep84LG33j5N1fzFaxDeXmKfcargKYanYq66KKs9U2XTWEerSwBMCPbsj7faMHQzSkNH

By looking at functions `hash`, `rand` and `shuffle` we see that there is no any randomization made or any desire of reversing them. So, I just use them to generate they transformed key `key2`. 

The attacker attached a *keylogger* on every input on the site, which is sending each pressed by user key to external server as an encoded message in form of `ws.send("{random} {input_key}", key2)`. 

I searched for `WebSockets` packets in `Wireshark` and I noticed that there are packets of three lengths: *~219*, *~60*, *~85*. First ones are encoded `User-Agent messages`, second - `pings` and the last ones are the ones I need - `user input`.

I dumped those packets into [sockets.txt]

In order to solve the task, we would like to decode at least the last character of the message. As mentioned already, we don't need to reverse anything except the function `encode(msg, key)`. Let's have a closer look at it with removing unused parts.

After decent analyze of the function I came to the following conclusions:
- each `element` of `encoded_arr` is between [0, 58)
- `msg` is converted to `Uint8Array` so its value is between [0, 255]
- `key` is of length 58 and is used only as a dictionary in return function
- each letter of `msg` is used as the transofrmation seed of `encoded_arr`

These observations pushed me to the solution of reversing this function by brute-forcing all the possible seeds and all the possible transformations. 

Reversing `return encoded_arr.reverse().map( x => key[x] ).join("")` is quite easy, since it just replaces each character of reversed `encoded_arr` with corresponding character in dictionary `key[]`. The reversion of the code can be done by  `encoded_arr.split("").map( x => key.indexOf(x) ).reverse()`

To fetch the last character of the word we have to solve the equation: 

where we only know `encoded_arr[0]`, and the `seed` is the searched character of  `msg`

It has to be said, that there will be a lot of solutions `(c, prev_encoded_arr[0])`, so we should repeat the process deep enough for succeeding elements of `prev_encoded_arr[]` and our solutions will quickly zip into one-way solution. 


In my initial solution, I had used a simple recursive function with deep of 10, and it was enough to solve the task.

The only issue of this solution was, that not every character is of length 1 (e.g. `Shift`), and the recieved text contained unwanted `t` characters: `irizaki_tmeibuteute_tdamashiilaeHtarekazeCTF{t7r1663r_th4ppy_t61rl}t `.
It wasn't too hard to remove them though and the final flag was: **HarekazeCTF{7r1663r_h4ppy_61rl}**

However this is the simplest solution I can think of, and after the competition ended I've improved the code of [decoder.js] and decoded the whole strings, which are as follows :)

The complete improved solution is included in: